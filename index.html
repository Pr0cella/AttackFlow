<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        img-src 'self' data:;
        connect-src 'self';
        frame-src 'self' blob:;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
        frame-ancestors 'self';
    ">
    <meta http-equiv="X-Frame-Options" content="SAMEORIGIN">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <title>AttackFlow - Kill Chain Editor</title>
    <script src="config.js"></script>
    <script src="stix-config.js"></script>
    <style>
        :root {
            --phase-in: #10b981;
            --phase-through: #06b6d4;
            --phase-out: #ef4444;
            --bg-dark: #1a1a1a;
            --bg-card: #242424;
            --bg-phase: #2d2d2d;
            --text-primary: #e5e5e5;
            --text-secondary: #a3a3a3;
            --border-color: #404040;
            --accent: #71717a;
            --capec-color: #8b5cf6;
            --cwe-color: #f59e0b;
            --attack-color: #3b82f6;
            --danger: #ef4444;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            padding: 8px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
        }

        .header-title {
            font-size: 1rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 18px;
            flex: 1;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-logo {
            display: inline;
            vertical-align: middle;
            width: 1.5rem;
            height: 1.5rem;
        }

        .header-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
            justify-self: center;
        }

        .header-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 0.7rem;
        }

        .header-theme {
            display: flex;
            align-items: center;
        }

        .version-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 2px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            transition: all 0.15s;
            border: 1px solid var(--border-color);
        }

        .version-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .help-link {
            color: var(--text-secondary);
            text-decoration: none;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-phase);
            border-radius: 50%;
            font-weight: 600;
            transition: all 0.15s;
            border: 1px solid var(--border-color);
        }

        .help-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
            justify-self: end;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .theme-toggle {
            width: 24px;
            height: 24px;
            border-radius: 24px;
            border: 1px solid var(--border-color);
            background: var(--bg-phase);
            color: var(--text-primary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
            overflow: hidden;
        }

        .theme-toggle:hover {
            border-color: var(--accent);
        }

        .theme-icon {
            width: 16px;
            height: 16px;
            position: absolute;
            opacity: 0;
            transform: scale(0.8) rotate(-15deg);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .theme-toggle[data-mode="dark"] .theme-icon.theme-dark,
        .theme-toggle[data-mode="light"] .theme-icon.theme-light {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }

        .theme-toggle[data-mode="dark"]:hover .theme-icon.theme-dark > svg {
            fill: #ffd42d;
        }

        .theme-toggle[data-mode="light"]:hover
        {
            background: var(--text-primary);
        }

        .theme-toggle[data-mode="light"]:hover .theme-icon.theme-light > svg
        {
            fill: beige;
        }

        .theme-icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
            display: block;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 4px;
            background: var(--bg-phase);
            border-radius: 4px;
            padding: 2px;
        }

        .view-tab-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px;
            border-radius: 3px;
        }

        .view-tab-group.active {
            background: rgba(113, 113, 122, 0.25);
        }

        .view-btn > svg
        /* #view-killchain > svg,
        #view-relationship > svg */
         {
            width: 1.2rem;
            height: 1.2rem;
            vertical-align: middle;
            fill: var(--text-secondary);
        }

        #view-relationship.active > svg,
        #view-relationship:hover > svg,
        #view-killchain.active > svg,
        #view-killchain:hover > svg {
            fill: var(--capec-color);
        }

        #view-explorer:hover > svg,
        #view-explorer.active > svg {
            fill: var(--attack-color);
        }

        #view-builder:hover > svg,
        #view-builder.active > svg {
            fill: var(--cwe-color);
        }
        

        .view-btn {
            padding: 5px 12px;
            border: none;
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .view-btn.active {
            background: rgba(113, 113, 122, 0.15);
            color: var(--text-primary);
        }

        .view-btn:hover {
            background: var(--meta-default-bg);
            color: var(--text-primary);
        }

        .view-breadcrumb {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .breadcrumb-sep > svg {
            color: var(--text-secondary);
            font-size: 0.7rem;
            height: 0.8rem;
            width: 1rem;
            vertical-align: middle;
            transform: rotate(180deg);
            fill: currentColor;
        }

        .view-btn.view-btn-crumb {
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid transparent;
        }

        .view-btn.view-btn-crumb.active {
            background: rgba(113, 113, 122, 0.35);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        /* Layer Toggles */
        .layer-toggles {
            display: flex;
            gap: 12px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .layer-toggle input {
            display: none;
        }

        .layer-toggle .checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .layer-toggle input:checked + .checkbox {
            background: var(--accent);
            border-color: var(--accent);
        }

        .layer-toggle input:checked + .checkbox::after {
            content: 'âœ“';
            font-size: 10px;
            color: white;
        }

        .layer-toggle.attack .checkbox { border-color: var(--attack-color); }
        .layer-toggle.attack input:checked + .checkbox { background: var(--attack-color); border-color: var(--attack-color); }
        .layer-toggle.capec .checkbox { border-color: var(--capec-color); }
        .layer-toggle.capec input:checked + .checkbox { background: var(--capec-color); border-color: var(--capec-color); }
        .layer-toggle.cwe .checkbox { border-color: var(--cwe-color); }
        .layer-toggle.cwe input:checked + .checkbox { background: var(--cwe-color); border-color: var(--cwe-color); }
        .layer-toggle.custom .checkbox { border-color: var(--custom-color); }
        .layer-toggle.custom input:checked + .checkbox { background: var(--custom-color); border-color: var(--custom-color); }

        .legend-layers {
            display: flex;
            gap: 12px;
            padding: 6px 8px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
            align-items: center;
        }

        /* Buttons */
        .btn {
            padding: 5px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        /*.btn:hover:not(.danger) { 
            color: var(--text-primary);
            background: var(--accent);
            border-color: var(--accent); 
        }*/

        .btn.active { background: var(--accent); border-color: var(--accent); }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn:not(.danger):hover { color: var(--text-primary); border-color: var(--accent); }
        .danger:hover { border-color: var(--danger) !important; color: var(--danger) !important; background: var(--bg-phase)!important; }

        /* Dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 100px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .dropdown.open .dropdown-content { display: block; }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 0.7rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.15s;
        }

        .dropdown-item:hover { background: var(--bg-phase); }
        .dropdown-item.active { background: var(--bg-phase); color: var(--text-primary); }
        .dropdown-item:first-child { border-radius: 4px 4px 0 0; }
        .dropdown-item:last-child { border-radius: 0 0 4px 4px; }

        #export-dropdown svg {
            width: 1rem;
            height: 1rem;
            fill: currentColor;
            vertical-align: middle;
            transition: all 0.15s;
        }

        #export-dropdown.dropdown.open svg {
            transform: rotate(180deg);
        }

        /* Main Layout */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .explorer-container {
            flex: 1;
            display: none;
            background: var(--bg-dark);
        }

        .explorer-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        .stix-builder-container {
            flex: 1;
            display: none;
            background: var(--bg-dark);
        }

        .stix-builder-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        .app.explorer-view .sidebar,
        .app.explorer-view .content {
            display: none;
        }

        .app.explorer-view .header-controls {
            visibility: hidden;
            pointer-events: none;
        }

        .app.explorer-view .explorer-container {
            display: block;
        }

        .app.stix-builder-view .sidebar,
        .app.stix-builder-view .content {
            display: none;
        }

        .app.stix-builder-view .header-controls {
            visibility: hidden;
            pointer-events: none;
        }

        .app.stix-builder-view .stix-builder-container {
            display: block;
        }

        .app.sidebar-collapsed .sidebar {
            width: 44px;
        }

        .app.sidebar-collapsed .sidebar-tabs,
        .app.sidebar-collapsed .sidebar-content {
            display: none;
        }

        .app.sidebar-collapsed .search-bar {
            display: none;
        }

        /* Sidebar */
        .sidebar {
            width: 340px;
            background: var(--bg-card);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.2s ease;
        }

        .sidebar-toggle {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sidebar-toggle:hover {
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .sidebar-toggle-icon {
            font-size: 0.7rem;
            transition: transform 0.2s;
            display: inline-block;
        }

        .sidebar-toggle-icon svg {
            width: 14px;
            height: 14px;
            display: block;
            fill: currentColor;
        }

        .app.sidebar-collapsed .sidebar-toggle-icon { transform: rotate(180deg); }

        .content-title-wrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            justify-self: start;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px 8px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
        }

        .sidebar-tab:hover { color: var(--text-primary); }
        .sidebar-tab.active { color: var(--text-primary); border-bottom-color: var(--accent); }
        .sidebar-tab.attack.active { border-bottom-color: var(--attack-color); }
        .sidebar-tab.capec.active { border-bottom-color: var(--capec-color); }
        .sidebar-tab.cwe.active { border-bottom-color: var(--cwe-color); }
        .sidebar-tab.custom.active { border-bottom-color: var(--custom-color); }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .tab-panel.active { display: flex; }

        /* Search & Filters */
        .search-bar {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .global-search {
            position: relative;
        }

        .global-search-input {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .global-search-sticky {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        .global-search-sticky input {
            accent-color: var(--accent);
        }

        .global-search-expand {
            border: 1px solid var(--border-color);
            background: var(--bg-phase);
            color: var(--text-secondary);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.15s;
        }

        .global-search-expand:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .global-search-results {
            display: none;
            margin-top: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-phase);
            border-radius: 6px;
            padding: 6px;
            max-height: 220px;
            overflow-y: auto;
        }

        .global-search.open .global-search-results {
            display: block;
        }

        .global-search.expanded .global-search-results {
            max-height: 50vh;
        }

        .global-search-item {
            width: 100%;
            text-align: left;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-primary);
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .global-search-item:hover {
            border-color: var(--accent);
            background: rgba(113, 113, 122, 0.15);
        }

        .global-search-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .global-search-type {
            padding: 1px 6px;
            border-radius: 999px;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            border: 1px solid var(--border-color);
        }

        .global-search-type.attack { border-color: var(--attack-color); color: var(--attack-color); }
        .global-search-type.capec { border-color: var(--capec-color); color: var(--capec-color); }
        .global-search-type.cwe { border-color: var(--cwe-color); color: var(--cwe-color); }

        .global-search-empty {
            padding: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .search-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .search-input:focus { outline: none; border-color: var(--accent); }

        .filter-row {
            display: flex;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 3px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .filter-btn.active { background: var(--accent); border-color: var(--accent); color: var(--text-primary); }

        /* Entity List */
        .entity-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .entity-item {
            display: flex;
            flex-direction: column;
            padding: 8px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .entity-item:hover { border-color: var(--accent); }
        .entity-item.selected { border-color: var(--accent); background: rgba(113, 113, 122, 0.2); }
        .entity-item.assigned { opacity: 0.5; border-style: dashed; }
        .entity-item.dragging { opacity: 0.4; transform: scale(0.95); }
        .entity-item[draggable="true"] { cursor: grab; }
        .entity-item[draggable="true"]:active { cursor: grabbing; }

        .entity-item.attack { border-left: 3px solid var(--attack-color); }
        .entity-item.capec { border-left: 3px solid var(--capec-color); }
        .entity-item.cwe { border-left: 3px solid var(--cwe-color); }

        .entity-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .entity-id {
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .entity-item.attack .entity-id { color: var(--attack-color); }
        .entity-item.capec .entity-id { color: var(--capec-color); }
        .entity-item.cwe .entity-id { color: var(--cwe-color); }

        .entity-name {
            font-size: 0.75rem;
            color: var(--text-primary);
            margin-top: 2px;
        }

        .entity-meta {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .entity-badge {
            font-size: 0.6rem;
            padding: 1px 5px;
            border-radius: 2px;
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .entity-badge.severity-high { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .entity-badge.severity-medium { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .entity-badge.severity-low { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .list-info {
            padding: 8px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        /* Import Section */
        .import-section {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .import-btns {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .import-btn {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--bg-phase);
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .import-btn:hover { 
            border-color: var(--attack-color); 
            color: var(--text-primary); 
        }

        /* Main Content */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-header {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 720px) minmax(0, 1fr);
            align-items: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
        }

        .kill-chain-title-wrap {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: center;
            justify-self: center;
        }

        .kill-chain-title {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            padding: 2px 8px;
            width: 100%;
            min-width: 0;
            max-width: 700px;
            outline: none;
            text-overflow: ellipsis;
        }

        .kill-chain-title::placeholder {
            color: var(--text-secondary);
            font-weight: 400;
            font-style: italic;
            opacity: 0.7;
        }

        .kill-chain-title:hover {
            border-color: var(--border-color);
        }

        .kill-chain-title:focus {
            border-color: var(--accent);
            background: var(--bg-card);
        }

        .app.compact-mode .kill-chain-title {
            font-size: 1rem;
            padding: 2px 8px;
            min-width: 0;
        }

        .view-controls {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
            justify-self: end;
        }

        /* Kill Chain Description */
        .kc-desc-bar {
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
        }
        .kc-desc-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 16px;
            cursor: pointer;
            user-select: none;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-transform: uppercase;
            width: 100%;
            text-align: left;
        }
        .kc-desc-toggle:hover { color: var(--text-primary); }
        .kc-desc-toggle .kc-desc-chevron {
            display: inline-block;
            width: 10px;
            height: 10px;
            transition: transform 0.2s ease;
            transform: rotate(90deg);
            flex-shrink: 0;
        }
        .kc-desc-bar.open .kc-desc-toggle .kc-desc-chevron {
            transform: rotate(-90deg);
        }
        .kc-desc-chevron svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .kc-desc-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            opacity: 0.5;
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 500px;
        }
        .kc-desc-bar.open .kc-desc-hint {
            display: none;
        }
        .kc-desc-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 16px;
        }
        .kc-desc-bar.open .kc-desc-body {
            max-height: 200px;
            padding: 0 16px 8px;
        }
        .kc-desc-textarea {
            width: 100%;
            min-height: 60px;
            max-height: 160px;
            resize: vertical;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            line-height: 1.5;
            padding: 6px 8px;
            outline: none;
        }
        .kc-desc-textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.5;
            font-style: italic;
        }
        .kc-desc-textarea:focus {
            border-color: var(--accent);
        }
        .kc-desc-counter {
            text-align: right;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 16px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
            padding: 4px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .stat-value { font-size: 1rem; font-weight: bold; }
        .stat-label { font-size: 0.6rem; color: var(--text-secondary); text-transform: uppercase; }

        /* Kill Chain View */
        .kill-chain-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }

        .app.compact-mode .kill-chain-container {
            overflow: hidden;
        }

        .app.compact-mode.compact-scroll .kill-chain-container {
            overflow: auto;
        }

        .kill-chain-container.hidden { display: none; }

        .kill-chain {
            display: flex;
            gap: 8px;
            min-height: 100%;
        }

        .super-phase {
            flex: 1;
            min-width: 240px;
            display: flex;
            flex-direction: column;
        }

        .super-phase-header {
            text-align: center;
            padding: 8px;
            border-radius: 4px 4px 0 0;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-left: 3px solid;
        }

        .super-phase.in .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-in); }
        .super-phase.through .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-through); }
        .super-phase.out .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-out); }

        .super-phase-content {
            background: var(--bg-card);
            border-radius: 0 0 4px 4px;
            padding: 6px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: 1px solid var(--border-color);
            border-top: none;
        }

        .phase {
            background: var(--bg-phase);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .phase.empty { opacity: 0.4; }
        .phase.hidden { display: none; }
        .phase.drop-target { border-color: var(--accent); background: rgba(113, 113, 122, 0.15); }
        .phase.minimized .phase-content { display: none; }

        .phase-header {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
        }

        .phase-header:hover { background: rgba(255, 255, 255, 0.03); }

        .phase-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .phase-header-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .app.compact-mode .phase-header-actions {
            gap: 4px;
        }

        .phase-name { font-weight: 500; font-size: 1rem; }

        .phase-count {
            background: var(--border-color);
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 600;
        }

        .phase-count.zero { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); }

        .phase-toggle {
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group-btn {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 2px;
            cursor: pointer;
        }

        .phase-group-btn:hover { color: var(--text-primary); border-color: var(--accent); }

        .phase-details-btn {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
        }

        .phase-details-btn:hover { 
            color: var(--text-primary); border-color: var(--accent); 
        }

        .phase-details-btn svg,
        .phase-group-btn svg{
            width: 0.8rem;
            height: 0.8rem;
            fill: currentColor;
            vertical-align: middle;
            text-align: center;
            margin-bottom: 0.1rem;
        }

        .phase.minimized .phase-toggle { transform: rotate(-90deg); }

        .phase-content {
            padding: 4px 6px 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .app.compact-mode .phase-header {
            padding: 4px 6px;
        }

        .app.compact-mode .phase-content {
            padding: 2px 4px 4px;
            gap: 3px;
            max-height: none;
            overflow: visible;
        }

        .app.compact-mode .phase-name { font-size: 0.85rem; }
        .app.compact-mode .phase-count { font-size: 0.6rem; padding: 1px 4px; }

        .app.compact-mode .phase-group-btn {
            font-size: 0.6rem;
            padding: 1px 4px;
        }

        .app.compact-mode .phase-group {
            padding: 2px;
            gap: 3px;
        }

        .app.compact-mode .phase-group-header {
            padding: 2px 4px;
        }

        .app.compact-mode .phase-group-title { font-size: 0.8rem; }
        .app.compact-mode .phase-group-count { font-size: 0.6rem; }

        .app.compact-mode .group-actions {
            opacity: 0;
            pointer-events: none;
        }

        .app.compact-mode .phase-group:hover .group-actions {
            opacity: 1;
            pointer-events: auto;
        }

        .phase-group {
            border: 1px dashed rgba(113, 113, 122, 0.35);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(17, 24, 39, 0.25);
        }

        .phase-group.collapsed .phase-group-content { display: none; }

        .phase-group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.4);
            cursor: pointer;
        }

        .phase-group-title { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
        .phase-group-count { font-size: 0.65rem; color: var(--text-secondary); }
        .phase-group-toggle {
            display: inline-block;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group.collapsed .phase-group-toggle { transform: rotate(-90deg); }

        .group-header-actions {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .group-actions {
            display: inline-flex;
            gap: 4px;
        }

        .group-action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .group-action-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .group-action-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .group-action-btn.delete:hover { border-color: #f87171; color: #f87171; }

        .phase-group-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .app.compact-mode .phase-group-content {
            gap: 2px;
        }

        /* Technique Tag */
        .technique-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .technique-tag:hover { border-color: var(--attack-color); background: rgba(59, 130, 246, 0.25); }

        .technique-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .app.compact-mode .technique-tag .tag-header-row,
        .app.compact-mode .capec-tag .tag-header-row,
        .app.compact-mode .cwe-tag .tag-header-row,
        .app.compact-mode .custom-tag .tag-header-row {
            gap: 4px;
        }

        .technique-tag .id {
            font-family: monospace;
            font-weight: 600;
            color: #fff;
            background: rgba(59, 130, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .app.compact-mode .technique-tag .id,
        .app.compact-mode .capec-tag .id,
        .app.compact-mode .cwe-tag .id,
        .app.compact-mode .custom-tag .id {
            font-size: 0.7rem;
            padding: 1px 3px;
        }

        .technique-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .technique-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .technique-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .technique-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .technique-tag:hover .remove { opacity: 1; }

        /* CWE Tag */
        .cwe-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .cwe-tag:hover { border-color: var(--cwe-color); background: rgba(245, 158, 11, 0.2); }

        .cwe-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .cwe-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(245, 158, 11, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .cwe-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .cwe-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .cwe-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .cwe-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .cwe-tag:hover .remove { opacity: 1; }

        /* CAPEC Tag */
        .capec-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .capec-tag:hover { border-color: var(--capec-color); background: rgba(139, 92, 246, 0.2); }

        .capec-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .domain-badge {
            font-size: 0.55rem;
            padding: 1px 4px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            background: var(--bg-phase);
            letter-spacing: 0.3px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .capec-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(139, 92, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .capec-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .capec-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .capec-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .capec-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .remove svg {
            fill: #ff6565f7;
        }

        .capec-tag:hover .remove { opacity: 1; }

        /* Custom/STIX Tag */
        .custom-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(20, 184, 166, 0.1);
            border: 1px solid rgba(20, 184, 166, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-tag:hover { border-color: var(--custom-color); background: rgba(20, 184, 166, 0.2); }

        .custom-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .custom-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(20, 184, 166, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .custom-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .custom-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .custom-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .custom-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .custom-tag:hover .remove { opacity: 1; }

        .stix-type-badge {
            font-size: 0.55rem;
            padding: 1px 4px;
            border-radius: 999px;
            border: 1px solid rgba(20, 184, 166, 0.4);
            color: var(--custom-color);
            background: rgba(20, 184, 166, 0.1);
            letter-spacing: 0.3px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        /* Create Custom Item Modal */
        .create-custom-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .create-custom-modal.visible { display: flex; }
        .create-custom-form {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            width: min(480px, 90vw);
            max-height: 80vh;
            overflow-y: auto;
        }
        .create-custom-form h3 {
            margin: 0 0 16px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        .create-custom-form label {
            display: block;
            margin-bottom: 4px;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        .create-custom-form select,
        .create-custom-form input,
        .create-custom-form textarea {
            width: 100%;
            padding: 6px 8px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        .create-custom-form textarea {
            resize: vertical;
            min-height: 60px;
        }
        .create-custom-form .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 8px;
        }
        .create-custom-form .form-actions button {
            padding: 6px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .create-custom-form .form-actions .btn-create {
            background: var(--custom-color);
            color: #fff;
            border-color: var(--custom-color);
        }
        .create-custom-form .form-actions .btn-cancel {
            background: var(--bg-phase);
            color: var(--text-primary);
        }
        #custom-typename-group { display: none; }

        /* Edit STIX Item Modal */
        .edit-stix-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2300;
            align-items: center;
            justify-content: center;
        }
        .edit-stix-modal.visible { display: flex; }
        .edit-stix-form {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: min(600px, 92vw);
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }
        .edit-stix-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .edit-stix-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1rem;
        }
        .edit-stix-header .stix-type-badge {
            background: var(--custom-color);
            color: #fff;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
        .edit-stix-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }
        .edit-stix-close:hover { color: var(--text-primary); }
        .edit-stix-body {
            overflow-y: auto;
            padding: 16px 20px;
            flex: 1;
        }
        .edit-stix-body .stix-field-group {
            margin-bottom: 14px;
        }
        .edit-stix-body .stix-field-group label {
            display: block;
            margin-bottom: 3px;
            color: var(--text-secondary);
            font-size: 0.78rem;
        }
        .edit-stix-body .stix-field-group label .field-required {
            color: #ef4444;
            margin-left: 2px;
        }
        .edit-stix-body .stix-field-group input,
        .edit-stix-body .stix-field-group select,
        .edit-stix-body .stix-field-group textarea {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        .edit-stix-body .stix-field-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        .edit-stix-body .stix-field-group .field-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        .edit-stix-body .stix-field-group input:read-only {
            opacity: 0.6;
            cursor: default;
        }
        .edit-stix-section-title {
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 18px 0 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border-color);
        }
        .edit-stix-section-title:first-child { margin-top: 0; }
        .edit-stix-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            padding: 12px 20px;
            border-top: 1px solid var(--border-color);
        }
        .edit-stix-footer button {
            padding: 6px 18px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .edit-stix-footer .btn-stix-save {
            background: var(--custom-color);
            color: #fff;
            border-color: var(--custom-color);
        }
        .edit-stix-footer .btn-stix-cancel {
            background: var(--bg-phase);
            color: var(--text-primary);
        }
        #edit-stix-error {
            color: #ef4444;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        /* Custom item sidebar entry */
        .entity-item.custom {
            border-left-color: var(--custom-color);
        }
        .entity-item.custom .entity-id {
            color: var(--custom-color);
        }
        .entity-badge.stix-badge {
            background: rgba(20, 184, 166, 0.15);
            color: var(--custom-color);
            border: 1px solid rgba(20, 184, 166, 0.3);
        }

        /* Filter dropdown for custom tab */
        .filter-select {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
            max-width: 140px;
        }

        .technique-tag .name,
        .capec-tag .name,
        .cwe-tag .name,
        .custom-tag .name {
            flex: 1;
            min-width: 0;
            font-size: 0.8rem;
        }

        .tag-actions {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .app.compact-mode .tag-actions {
            opacity: 0;
            pointer-events: none;
        }

        .app.compact-mode .technique-tag:hover .tag-actions,
        .app.compact-mode .capec-tag:hover .tag-actions,
        .app.compact-mode .cwe-tag:hover .tag-actions,
        .app.compact-mode .custom-tag:hover .tag-actions {
            opacity: 1;
            pointer-events: auto;
        }

        .tag-body {
            margin-top: 4px;
        }

        .tag-footer {
            margin-top: 4px;
        }

        .app.compact-mode .technique-tag,
        .app.compact-mode .capec-tag,
        .app.compact-mode .cwe-tag,
        .app.compact-mode .custom-tag {
            padding: 3px 5px;
        }

        .app.compact-mode .tag-body {
            display: none;
        }

        .app.compact-mode .tag-footer {
            margin-top: 2px;
        }

        /* Phase item inline collapsible (comment / STIX description) */
        .tag-comment-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            font-size: 0.65rem;
            color: var(--text-secondary);
            padding: 2px 0;
            user-select: none;
            margin-top: 2px;
        }

        .tag-comment-toggle:hover {
            color: var(--text-primary);
        }

        .tag-comment-chevron {
            display: inline-flex;
            width: 10px;
            height: 10px;
            transition: transform 0.2s ease;
        }

        .tag-comment-chevron svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        .tag-comment-toggle.expanded .tag-comment-chevron {
            transform: rotate(90deg);
        }

        .tag-comment-area {
            max-height: 0;
            overflow: hidden;
            margin-top: 0;
        }

        .tag-comment-area.open {
            max-height: 200px;
            margin-top: 4px;
            transition: 0.2s max-height;
            transition-duration: 0.1s;
        }

        .tag-comment-content {
            font-size: 0.75rem;
            line-height: 1.4;
            color: var(--text-secondary);
            background: var(--bg-phase);
            padding: 6px 8px;
            resize: vertical;
            overflow-y: auto;
            min-height: 2.4em;
            max-height: 200px;
            word-break: break-word;
            border: 1px dashed var(--border-color);
            border-radius: 6px;
        }

        .app.compact-mode .tag-comment-toggle,
        .app.compact-mode .tag-comment-area {
            display: none;
        }

        .tag-action-btn {
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text-secondary);
            font-size: 0.7rem;
            padding: 3px 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            line-height: 1.1;
        }

        .app.compact-mode .tag-action-btn {
            padding: 1px 3px;
        }

        .tag-action-btn:hover {
            color: var(--text-primary);
            border-color: var(--accent);
            background: rgba(113, 113, 122, 0.25);
        }

        .technique-tag .tag-action-btn.explore,
        .technique-tag .tag-action-btn.edit,
        .capec-tag .tag-action-btn.explore,
        .capec-tag .tag-action-btn.edit,
        .cwe-tag .tag-action-btn.explore,
        .cwe-tag .tag-action-btn.edit,
        .custom-tag .tag-action-btn.edit {
            opacity: 0;
            pointer-events: none;
        }

        .technique-tag:hover .tag-action-btn.explore,
        .technique-tag:hover .tag-action-btn.edit,
        .capec-tag:hover .tag-action-btn.explore,
        .capec-tag:hover .tag-action-btn.edit,
        .cwe-tag:hover .tag-action-btn.explore,
        .cwe-tag:hover .tag-action-btn.edit,
        .custom-tag:hover .tag-action-btn.edit {
            opacity: 1;
            pointer-events: auto;
        }

        .tag-action-btn.explore { color: #93c5fd; }
        .tag-action-btn.edit { color: #fcd34d; }

        /* ============================================================
           SCORE RIBBONS & METADATA INDICATORS
           ============================================================ */
        
        /* Score ribbon (left border only - preserves framework background colors) */
        .technique-tag[data-score="low"],
        .capec-tag[data-score="low"],
        .cwe-tag[data-score="low"] {
            border-left: 3px solid #22c55e;
        }
        
        .technique-tag[data-score="medium"],
        .capec-tag[data-score="medium"],
        .cwe-tag[data-score="medium"] {
            border-left: 3px solid #eab308;
        }
        
        .technique-tag[data-score="high"],
        .capec-tag[data-score="high"],
        .cwe-tag[data-score="high"] {
            border-left: 3px solid #f97316;
        }
        
        .technique-tag[data-score="critical"],
        .capec-tag[data-score="critical"],
        .cwe-tag[data-score="critical"] {
            border-left: 3px solid #ef4444;
        }

        /* Metadata indicators - displayed below title */
        .metadata-icons {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .app.compact-mode .metadata-icons {
            gap: 3px;
            margin-top: 2px;
        }

        .app.compact-mode .tag-header-row .metadata-icons {
            margin-top: 0;
        }
        
        .metadata-icons .meta-icon {
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--meta-default-bg);
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
            color: var(--meta-default-fg);
            white-space: nowrap;
            gap: 4px;
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .app.compact-mode .metadata-icons .meta-icon {
            min-width: 14px;
            height: 14px;
            padding: 0 3px;
            font-size: 10px;
        }

        .meta-icon svg,
        .tag-action-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            stroke: currentColor;
            flex: 0 0 auto;
        }

        .tag-action-btn:hover svg {
            fill: currentColor;
            stroke: currentColor;
        }
        
        .metadata-icons .meta-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .metadata-icons .meta-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .metadata-icons .meta-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .metadata-icons .meta-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .metadata-icons .meta-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }

        /* Score Legend */
        .score-legend {
            display: flex;
            gap: 12px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .metadata-legend {
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .metadata-legend .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .legend-icon {
            width: 14px;
            height: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            background: var(--meta-default-bg);
            color: var(--meta-default-fg);
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .legend-icon svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .legend-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .legend-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .legend-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .legend-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .legend-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-decoration: none;
            cursor: pointer;
            margin-left: auto;
        }

        .github-link a {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: inherit;
            text-decoration: none;
        }

        .github-link svg {
            fill: gray;
            height: 1.5rem;
            width: 1.5rem;
            flex-shrink: 0;
        }

        .github-link svg:hover {
            fill: rgb(170, 65, 170);
            scale: calc(1.1);
            height: 1.5rem;
            width: 1.5rem;
            flex-shrink: 0;
        }

        .github-link:hover { color: var(--text-primary); }
        
        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* ============================================================
           METADATA EDITOR MODAL
           ============================================================ */
        .metadata-editor-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }
        
        .metadata-editor-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .metadata-editor {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        
        .metadata-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .metadata-editor-title {
            font-size: 1rem;
            font-weight: 600;
        }
        
        .metadata-editor-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 4px;
        }
        
        .metadata-editor-close:hover { color: var(--text-primary); }
        
        .metadata-editor-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .metadata-section {
            margin-bottom: 16px;
        }
        
        .metadata-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .metadata-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
        }
        
        .metadata-input:focus {
            outline: none;
            border-color: var(--attack-color);
        }
        
        .metadata-input.invalid {
            border-color: #ef4444;
        }
        
        .metadata-input-error {
            font-size: 0.7rem;
            color: #ef4444;
            margin-top: 4px;
        }
        
        .metadata-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .metadata-select {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        /* Score selector */
        .score-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .score-option {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }
        
        .score-option:hover {
            border-color: var(--text-secondary);
        }
        
        .score-option.selected {
            border-color: var(--attack-color);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .score-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        /* Confidence slider */
        .confidence-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .confidence-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            outline: none;
        }
        
        .confidence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .confidence-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .confidence-value {
            min-width: 80px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-primary);
        }
        
        .confidence-label {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .confidence-label.unknown { background: rgba(107, 114, 128, 0.3); color: #9ca3af; }
        .confidence-label.low { background: rgba(239, 68, 68, 0.3); color: #fca5a5; }
        .confidence-label.medium { background: rgba(251, 191, 36, 0.3); color: #fcd34d; }
        .confidence-label.high { background: rgba(34, 197, 94, 0.3); color: #86efac; }
        
        /* Observable list */
        .observable-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .observable-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .observable-item select {
            width: 140px;
            flex-shrink: 0;
        }
        
        .observable-item input {
            flex: 1;
        }
        
        .observable-remove {
            background: none;
            border: none;
            color: #ef4444;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
        }

        .metadata-section > .add-btn {
            margin-top: 0.5rem;
            text-align: center;
        }
        
        .add-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: var(--bg-phase);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .add-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }
        
        /* Hyperlink list */
        .hyperlink-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .hyperlink-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .hyperlink-item input:first-child {
            width: 120px;
            flex-shrink: 0;
        }
        
        .hyperlink-item input:nth-child(2) {
            flex: 1;
        }

        /* CVE list */
        .cve-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cve-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .cve-item input.cve-id-input {
            width: 180px;
            flex-shrink: 0;
        }

        .cve-item input.cve-score-input {
            width: 110px;
            flex-shrink: 0;
        }

        .cve-item input.cve-vector-input {
            flex: 1;
            min-width: 220px;
        }
        
        .metadata-editor-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
        }
        
        .metadata-btn {
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .metadata-btn-cancel {
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .metadata-btn-cancel:hover {
            background: var(--bg-dark);
        }
        
        .metadata-btn-save {
            background: var(--attack-color);
            border: 1px solid var(--attack-color);
            color: white;
        }
        
        .metadata-btn-save:hover {
            background: #2563eb;
        }

        /* Relationship View */
        .relationship-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
            display: none;
        }

        .relationship-container.visible { display: block; }

        .relationship-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .relationship-header-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .relationship-header-item .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .relationship-header-item .dot.capec { background: var(--capec-color); }
        .relationship-header-item .dot.cwe { background: var(--cwe-color); }
        .relationship-header-item .dot.attack { background: var(--attack-color); }
        .relationship-header-item .dot.phase { background: var(--accent); }
        .relationship-header-item .dot.mitigation { background: #10b981; }

        .relationship-arrow {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .relationship-chain {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .relationship-wrapper {
            display: flex;
            gap: 12px;
        }

        .flow-arrow {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 16px 8px;
            min-height: 100px;
        }

        .flow-arrow-line {
            width: 2px;
            flex: 1;
            background: linear-gradient(to bottom, var(--phase-in), var(--phase-through), var(--phase-out));
            border-radius: 1px;
            position: relative;
        }

        .flow-arrow-head {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 12px solid var(--phase-out);
            margin-top: -1px;
        }

        .flow-arrow-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin-bottom: 8px;
        }

        .relationship-row {
            display: flex;
            align-items: stretch;
            gap: 4px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .relationship-cell {
            flex: 1;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border-right: 1px solid var(--border-color);
            min-width: 0;
        }

        .relationship-cell:last-child { border-right: none; }

        .relationship-cell-header {
            font-size: 0.6rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .relationship-cell.capec { background: rgba(139, 92, 246, 0.05); }
        .relationship-cell.cwe { background: rgba(245, 158, 11, 0.05); }
        .relationship-cell.attack { background: rgba(59, 130, 246, 0.05); }
        .relationship-cell.phase { background: rgba(113, 113, 122, 0.05); border-width: 0px; }
        .relationship-cell.mitigation { background: rgba(16, 185, 129, 0.05); }

        .relationship-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .relationship-item:hover { background: var(--bg-dark); }

        .relationship-item .id {
            font-family: monospace;
            font-weight: 600;
        }

        .relationship-item .id.capec { color: var(--capec-color); }
        .relationship-item .id.cwe { color: var(--cwe-color); }
        .relationship-item .id.attack { color: var(--attack-color); }
        .relationship-item .id.phase { color: var(--accent); }
        .relationship-item .id.mitigation { color: #10b981; }

        .relationship-item .name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .relationship-more {
            background: none;
            border: none;
            padding: 0;
            text-align: left;
            cursor: pointer;
        }

        .relationship-more:hover {
            color: var(--text-primary);
        }

        .phase-details-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .phase-details-stat {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 10px;
        }

        .phase-details-stat-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .phase-details-stat-value {
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .phase-details-section {
            margin-bottom: 14px;
        }

        .phase-details-section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 6px;
        }

        .phase-details-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .phase-details-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .phase-details-item.clickable {
            cursor: pointer;
        }

        .phase-details-item.clickable:hover {
            border-color: var(--accent);
        }

        .phase-details-item-header {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .phase-details-item-id {
            font-family: monospace;
        }

        .phase-details-meta {
            font-size: 0.65rem;
            color: var(--text-secondary);
            display: flex;
            flex-wrap: wrap;
            gap: 6px 10px;
        }

        .phase-details-relations {
            font-size: 0.65rem;
            color: var(--text-secondary);
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .phase-details-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            font-size: 0.6rem;
        }

        .mitigation-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: #10b981;
            background: rgba(16, 185, 129, 0.12);
            border: 1px solid rgba(16, 185, 129, 0.35);
            border-radius: 3px;
            padding: 1px 6px;
            cursor: pointer;
        }

        .mitigation-badge:hover {
            background: rgba(16, 185, 129, 0.2);
        }

        .phase-details-mitigation-desc summary {
            font-size: 0.65rem;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .phase-details-mitigation-desc p {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .relationship-empty {
            padding: 30px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Detail Panel */
        .detail-panel {
            width: 320px;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .detail-panel.visible { display: flex; }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
        }

        .detail-header-content {
            flex: 1;
            min-width: 0;
        }

        .detail-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .detail-close:hover { color: var(--text-primary); }

        .detail-id {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .detail-id.attack { color: var(--attack-color); }
        .detail-id.capec { color: var(--capec-color); }
        .detail-id.cwe { color: var(--cwe-color); }

        .detail-name {
            font-size: 0.95rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .detail-section {
            margin-bottom: 16px;
        }

        .detail-section h4 {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .detail-section p {
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .detail-section details {
            margin-top: 4px;
        }
        .detail-section details summary {
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-secondary);
            user-select: none;
            padding: 2px 0;
        }
        .detail-section details summary:hover {
            color: var(--text-primary);
        }
        .detail-section details[open] summary {
            margin-bottom: 6px;
        }
        .detail-section details p {
            margin: 0;
        }

        .detail-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .detail-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 8px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .detail-list-item:hover { background: var(--bg-dark); }

        .detail-list-item .id { font-family: monospace; font-weight: 600; }
        .detail-list-item .id.attack { color: var(--attack-color); }
        .detail-list-item .id.capec { color: var(--capec-color); }
        .detail-list-item .id.cwe { color: var(--cwe-color); }

        /* Technique cross-reference badges (KCE-SEC-010 compliant) */
        .technique-xref-badge {
            display: inline;
            font-family: var(--mono, monospace);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--attack-color);
            background: color-mix(in srgb, var(--attack-color) 12%, transparent);
            border: 1px solid color-mix(in srgb, var(--attack-color) 30%, transparent);
            border-radius: 3px;
            padding: 1px 5px;
            cursor: pointer;
            white-space: nowrap;
        }
        .technique-xref-badge:hover {
            background: color-mix(in srgb, var(--attack-color) 25%, transparent);
        }

        /* Legend */
        .legend {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-color.attack { background: var(--attack-color); }
        .legend-color.capec { background: var(--capec-color); }
        .legend-color.cwe { background: var(--cwe-color); }
        .legend-color.custom { background: var(--custom-color); }
        .legend-color.in { background: var(--phase-in); }
        .legend-color.through { background: var(--phase-through); }
        .legend-color.out { background: var(--phase-out); }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 18px;
            background: var(--bg-card);
            border: 1px solid var(--accent);
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
            display:none;
        }

        .toast.show { opacity: 1; transform: translateY(0); display: block; }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        #phase-details-modal {
            z-index: 2100;
        }

        #entity-modal {
            z-index: 2200;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text-primary); }

        .modal-body {
            padding: 16px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .csv-import-hint {
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .csv-import-textarea {
            width: 100%;
            min-height: 160px;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            box-sizing: border-box;
            resize: vertical;
        }

        .csv-import-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .csv-import-error {
            color: #ef4444;
            font-size: 0.8rem;
            margin-top: 8px;
        }

        .modal-wide {
            max-width: 700px;
            max-height: 80vh;
        }

        .changelog-body {
            white-space: pre-wrap;
            font-family: var(--font-mono, 'SF Mono', Consolas, monospace);
            font-size: 0.8rem;
            background: var(--bg-dark);
            border-radius: 4px;
            padding: 16px;
            max-height: 60vh;
        }

        .guide-section {
            margin-bottom: 16px;
        }

        .guide-section h4 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .guide-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .guide-section li {
            margin-bottom: 4px;
        }

        .guide-key {
            display: inline-block;
            background: var(--bg-phase);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            margin: 0 2px;
        }

        .guide-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
            gap: 16px;
        }

        .loading.hidden { display: none; }

        .loading-text {
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
            max-width: 500px;
            line-height: 1.5;
            background: var(--bg-dark);
            padding: 5px;
            border-radius: 5px;
            margin-bottom: 2rem;
        }

        .loading-dismiss {
            display: none;
            padding: 8px 24px;
            background: var(--accent, #3b82f6);
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .loading-dismiss:hover {
            background: #2563eb;
        }

        .loading-bypass {
            display: none;
            padding: 8px 16px;
            background: var(--bg-dark);
            color: var(--text-secondary, #a1a1aa);
            border: 1px solid var(--border-color, #3f3f46);
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: color 0.15s, border-color 0.15s, background 0.15s;
        }

        .loading-bypass:hover {
            color: var(--text-primary, #e4e4e7);
            border-color: var(--accent, #3b82f6);
            background: rgba(255, 255, 255, 0.06);
        }

        .loading-hint {
            display: none;
            color: var(--text-secondary, #a1a1aa);
            font-size: 0.75rem;
            text-align: center;
            max-width: 440px;
            line-height: 1.4;
            background: var(--bg-dark);
            border-radius: 5px;
            margin-top: 2rem;
        }

        .loading-context-info {
            display: none;
            color: var(--cwe-color);
            font-size: 0.75rem;
            text-align: center;
            max-width: 560px;
            line-height: 1.5;
            margin-top: 0.75rem;
            padding: 0.55rem 0.7rem;
            border: 1px solid var(--border-color, #3f3f46);
            border-radius: 6px;
            background: rgba(245, 158, 11, 0.08);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Loading data...</div>
        <button class="loading-dismiss" id="loading-dismiss" onclick="hideLoadingOverlay()">Continue Without Data</button>
        <button class="loading-bypass" id="loading-bypass" onclick="hideLoadingOverlay()">I know what Iâ€™m doing</button>
        <div class="loading-hint" id="loading-hint">You can still import ATT&CK Navigator layers, create STIX objects, and import saved kill chains.</div>
        <div class="loading-context-info" id="loading-context-info"></div>
    </div>

    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="header-brand">
                    <img src="favicon.ico" alt="Logo" class="header-logo">
                    <div class="header-title">AttackFlow</div><br>
                    <div class="header-meta">
                        <a href="#" class="version-link" id="app-version" title="View changelog" onclick="showChangelog(); return false;">v2.4.2</a>
                        <a href="#" class="help-link" onclick="showUsageGuide(); return false;" title="Usage guide">?</a>
                    </div>
                </div>
                <div class="header-theme">
                    <button class="theme-toggle" id="theme-mode-toggle" onclick="toggleThemeMode()" aria-label="Toggle theme" data-mode="light">
                        <span class="theme-icon theme-dark">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M420.9 448C428.2 425.7 442.8 405.5 459.3 388.1C492 353.7 512 307.2 512 256C512 150 426 64 320 64C214 64 128 150 128 256C128 307.2 148 353.7 180.7 388.1C197.2 405.5 211.9 425.7 219.1 448L420.8 448zM416 496L224 496L224 512C224 556.2 259.8 592 304 592L336 592C380.2 592 416 556.2 416 512L416 496zM312 176C272.2 176 240 208.2 240 248C240 261.3 229.3 272 216 272C202.7 272 192 261.3 192 248C192 181.7 245.7 128 312 128C325.3 128 336 138.7 336 152C336 165.3 325.3 176 312 176z"/></svg>
                        </span>
                        <span class="theme-icon theme-light">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M320 64C178.6 64 64 178.6 64 320C64 461.4 178.6 576 320 576C388.8 576 451.3 548.8 497.3 504.6C504.6 497.6 506.7 486.7 502.6 477.5C498.5 468.3 488.9 462.6 478.8 463.4C473.9 463.8 469 464 464 464C362.4 464 280 381.6 280 280C280 207.9 321.5 145.4 382.1 115.2C391.2 110.7 396.4 100.9 395.2 90.8C394 80.7 386.6 72.5 376.7 70.3C358.4 66.2 339.4 64 320 64z"/></svg>
                        </span>
                    </button>
                </div>
            </div>

            <div class="header-center">
                <div class="header-nav">
                    <div class="view-toggle">
                        <div class="view-tab-group active" id="view-editor-group">
                            <button class="view-btn active" id="view-killchain" onclick="setView('killchain')">
                                Kill Chain Editor 
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M451.5 160C434.9 160 418.8 164.5 404.7 172.7C388.9 156.7 370.5 143.3 350.2 133.2C378.4 109.2 414.3 96 451.5 96C537.9 96 608 166 608 252.5C608 294 591.5 333.8 562.2 363.1L491.1 434.2C461.8 463.5 422 480 380.5 480C294.1 480 224 410 224 323.5C224 322 224 320.5 224.1 319C224.6 301.3 239.3 287.4 257 287.9C274.7 288.4 288.6 303.1 288.1 320.8C288.1 321.7 288.1 322.6 288.1 323.4C288.1 374.5 329.5 415.9 380.6 415.9C405.1 415.9 428.6 406.2 446 388.8L517.1 317.7C534.4 300.4 544.2 276.8 544.2 252.3C544.2 201.2 502.8 159.8 451.7 159.8zM307.2 237.3C305.3 236.5 303.4 235.4 301.7 234.2C289.1 227.7 274.7 224 259.6 224C235.1 224 211.6 233.7 194.2 251.1L123.1 322.2C105.8 339.5 96 363.1 96 387.6C96 438.7 137.4 480.1 188.5 480.1C205 480.1 221.1 475.7 235.2 467.5C251 483.5 269.4 496.9 289.8 507C261.6 530.9 225.8 544.2 188.5 544.2C102.1 544.2 32 474.2 32 387.7C32 346.2 48.5 306.4 77.8 277.1L148.9 206C178.2 176.7 218 160.2 259.5 160.2C346.1 160.2 416 230.8 416 317.1C416 318.4 416 319.7 416 321C415.6 338.7 400.9 352.6 383.2 352.2C365.5 351.8 351.6 337.1 352 319.4C352 318.6 352 317.9 352 317.1C352 283.4 334 253.8 307.2 237.5z"/></svg>
                            </button>
                            <span class="view-breadcrumb">
                                <span class="breadcrumb-sep"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640" style="height: 0.8rem;width: 1rem;vertical-align: middle;transform: rotate(180deg);"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M169.4 297.4C156.9 309.9 156.9 330.2 169.4 342.7L361.4 534.7C373.9 547.2 394.2 547.2 406.7 534.7C419.2 522.2 419.2 501.9 406.7 489.4L237.3 320L406.6 150.6C419.1 138.1 419.1 117.8 406.6 105.3C394.1 92.8 373.8 92.8 361.3 105.3L169.3 297.3z"></path></svg></span>
                                <button class="view-btn view-btn-crumb" id="view-relationship" onclick="setView('relationship')">
                                    Relationships 
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M482.4 221.9C517.7 213.6 544 181.9 544 144C544 99.8 508.2 64 464 64C420.6 64 385.3 98.5 384 141.5L200.2 215.1C185.7 200.8 165.9 192 144 192C99.8 192 64 227.8 64 272C64 316.2 99.8 352 144 352C156.2 352 167.8 349.3 178.1 344.4L323.7 471.8C321.3 479.4 320 487.6 320 496C320 540.2 355.8 576 400 576C444.2 576 480 540.2 480 496C480 468.3 466 443.9 444.6 429.6L482.4 221.9zM220.3 296.2C222.5 289.3 223.8 282 224 274.5L407.8 201C411.4 204.5 415.2 207.7 419.4 210.5L381.6 418.1C376.1 419.4 370.8 421.2 365.8 423.6L220.3 296.2z"></path></svg>
                                </button>
                            </span>
                        </div>
                        <div class="view-tab-group" id="view-explorer-group">
                            <button class="view-btn" id="view-explorer" onclick="setView('explorer')">
                                Relationship Explorer 
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M256 128C256 110.3 270.3 96 288 96L352 96C369.7 96 384 110.3 384 128L384 192C384 209.7 369.7 224 352 224L344 224L344 288L464 288C503.8 288 536 320.2 536 360L536 416L544 416C561.7 416 576 430.3 576 448L576 512C576 529.7 561.7 544 544 544L480 544C462.3 544 448 529.7 448 512L448 448C448 430.3 462.3 416 480 416L488 416L488 360C488 346.7 477.3 336 464 336L344 336L344 416L352 416C369.7 416 384 430.3 384 448L384 512C384 529.7 369.7 544 352 544L288 544C270.3 544 256 529.7 256 512L256 448C256 430.3 270.3 416 288 416L296 416L296 336L176 336C162.7 336 152 346.7 152 360L152 416L160 416C177.7 416 192 430.3 192 448L192 512C192 529.7 177.7 544 160 544L96 544C78.3 544 64 529.7 64 512L64 448C64 430.3 78.3 416 96 416L104 416L104 360C104 320.2 136.2 288 176 288L296 288L296 224L288 224C270.3 224 256 209.7 256 192L256 128z"></path></svg>
                            </button>
                        </div>
                        <div class="view-tab-group" id="view-builder-group">
                            <button class="view-btn" id="view-builder" onclick="setView('stix-builder')">
                                STIX Composer 
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M468 64C487.2 64 505.6 71.6 519.1 85.2L554.8 120.9C568.4 134.4 576 152.8 576 172C576 191.2 568.4 209.6 554.8 223.1L509.9 268L372 130.1L416.9 85.2C430.4 71.6 448.8 64 468 64zM122.9 379.1L338.1 164L476 301.9L260.9 517.1C250.2 527.8 236.8 535.6 222.2 539.7L94.4 575.1C86.1 577.4 77.1 575.1 71 568.9C64.9 562.7 62.5 553.8 64.8 545.5L100.4 417.8C104.5 403.2 112.2 389.9 123 379.1zM289.4 144.8L144.8 289.4L75.7 220.3C60.1 204.7 60.1 179.4 75.7 163.7L163.7 75.7C179.3 60.1 204.6 60.1 220.3 75.7L226.2 81.6L169.9 137.9C162.1 145.7 162.1 158.4 169.9 166.2C177.7 174 190.4 174 198.2 166.2L254.5 109.9L289.4 144.8zM495.2 350.6L530.1 385.5L473.8 441.8C466 449.6 466 462.3 473.8 470.1C481.6 477.9 494.3 477.9 502.1 470.1L558.4 413.8L564.3 419.7C579.9 435.3 579.9 460.6 564.3 476.3L476.3 564.3C460.7 579.9 435.4 579.9 419.7 564.3L350.6 495.2L495.2 350.6z"/></svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="header-controls">
                <div class="control-group">
                    <button class="btn" onclick="expandAll()">Expand</button>
                    <button class="btn" onclick="collapseAll()">Collapse</button>
                    <span width="1px" style="border-left:1px solid var(--border-color); height: 16px; display: inline-block;"></span>
                    <button class="btn danger" onclick="clearAssignments()">Clear</button>
                    <span width="1px" style="border-left:1px solid var(--border-color); height: 16px; display: inline-block;"></span>
                    <div class="dropdown" id="export-dropdown">
                        <button class="btn" onclick="toggleDropdown('export-dropdown')">Export <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M297.4 438.6C309.9 451.1 330.2 451.1 342.7 438.6L502.7 278.6C515.2 266.1 515.2 245.8 502.7 233.3C490.2 220.8 469.9 220.8 457.4 233.3L320 370.7L182.6 233.4C170.1 220.9 149.8 220.9 137.3 233.4C124.8 245.9 124.8 266.2 137.3 278.7L297.3 438.7z"/></svg></button>
                        <div class="dropdown-content">
                            <button class="dropdown-item" onclick="exportJSON(); closeDropdowns()">JSON</button>
                            <button class="dropdown-item" onclick="exportCSV(); closeDropdowns()">CSV</button>
                            <button class="dropdown-item" onclick="exportSTIXBundle(); closeDropdowns()">STIX Bundle</button>
                        </div>
                    </div>
                    <button class="btn" onclick="triggerImportKillChain()">Import</button>
                    <input id="import-killchain-input" type="file" accept=".json" onchange="importKillChain(event)" style="display: none;" />
                </div>
            </div>
        </div>

        <!-- Main -->
        <div class="main">
            <!-- Sidebar -->
            <div class="sidebar">
                <div class="search-bar global-search" id="global-search-bar">
                    <div class="global-search-input">
                        <input type="text" class="search-input" id="search-global" placeholder="Global search (ATT&CK/CAPEC/CWE)..." oninput="setGlobalSearch(this.value)" onfocus="openGlobalSearch()">
                        <label class="global-search-sticky" title="Keep results open">
                            <input type="checkbox" id="global-search-sticky" onchange="setGlobalSearchSticky(this.checked)">
                            Sticky
                        </label>
                        <button class="global-search-expand" id="global-search-expand" onclick="toggleGlobalSearchExpanded(event)" aria-label="Toggle global search size" type="button">Expand</button>
                    </div>
                    <div class="global-search-results" id="global-search-results"></div>
                </div>
                <div class="sidebar-tabs">
                    <button class="sidebar-tab attack active" onclick="switchTab('attack')">ATT&CK</button>
                    <button class="sidebar-tab capec" onclick="switchTab('capec')">CAPEC</button>
                    <button class="sidebar-tab cwe" onclick="switchTab('cwe')">CWE</button>
                    <button class="sidebar-tab custom" onclick="switchTab('custom')">STIX</button>
                </div>

                <div class="sidebar-content">
                    <!-- ATT&CK Tab -->
                    <div class="tab-panel active" id="tab-attack">
                        <div class="import-section">
                            <div class="import-btns">
                                <label class="import-btn" style="cursor: pointer;">
                                    Import ATT&CK Navigator Layer
                                    <input type="file" accept=".json" onchange="importNavigator(event)" style="display: none;">
                                </label>
                                <button class="import-btn" onclick="openCsvImportModal()">Import CSV</button>
                                <button class="import-btn danger" onclick="resetAttackTechniques()">Reset</button>
                            </div>
                        </div>
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-attack" placeholder="Search techniques separated by comma..." oninput="filterEntities('attack')">
                        </div>
                        <div class="filter-row" id="filter-attack">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('attack', 'all')">All</button>
                            <button class="filter-btn" data-filter="enterprise" onclick="setFilter('attack', 'enterprise')">Enterprise</button>
                            <button class="filter-btn" data-filter="mobile" onclick="setFilter('attack', 'mobile')">Mobile</button>
                            <button class="filter-btn" data-filter="ics" onclick="setFilter('attack', 'ics')">ICS</button>
                        </div>
                        <div class="entity-list" id="list-attack"></div>
                    </div>

                    <!-- CAPEC Tab -->
                    <div class="tab-panel" id="tab-capec">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-capec" placeholder="Search patterns separated by comma..." oninput="filterEntities('capec')">
                        </div>
                        <div class="filter-row" id="filter-capec">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('capec', 'all')">All</button>
                            <button class="filter-btn" data-filter="meta" onclick="setFilter('capec', 'meta')">Meta</button>
                            <button class="filter-btn" data-filter="standard" onclick="setFilter('capec', 'standard')">Standard</button>
                            <button class="filter-btn" data-filter="detailed" onclick="setFilter('capec', 'detailed')">Detailed</button>
                        </div>
                        <div class="entity-list" id="list-capec"></div>
                    </div>

                    <!-- CWE Tab -->
                    <div class="tab-panel" id="tab-cwe">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-cwe" placeholder="Search weaknesses separated by comma..." oninput="filterEntities('cwe')">
                        </div>
                        <div class="filter-row" id="filter-cwe">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('cwe', 'all')">All</button>
                            <button class="filter-btn" data-filter="pillar" onclick="setFilter('cwe', 'pillar')">Pillar</button>
                            <button class="filter-btn" data-filter="class" onclick="setFilter('cwe', 'class')">Class</button>
                            <button class="filter-btn" data-filter="base" onclick="setFilter('cwe', 'base')">Base</button>
                        </div>
                        <div class="entity-list" id="list-cwe"></div>
                    </div>

                    <!-- STIX Tab -->
                    <div class="tab-panel" id="tab-custom">
                        <div class="import-section">
                            <div class="import-btns">
                                <button class="import-btn" onclick="openCreateCustomModal()">+ Create STIX Item</button>
                                <label class="import-btn" style="cursor: pointer;">
                                    Import STIX Bundle
                                    <input type="file" accept=".json" onchange="importStixBundle(event)" style="display: none;">
                                </label>
                                <button class="import-btn danger" onclick="clearStixLibrary()">Clear All Items</button>
                            </div>
                        </div>
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-custom" placeholder="Search STIX items..." oninput="filterEntities('custom')">
                        </div>
                        <div class="filter-row" id="filter-custom">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('custom', 'all')">All</button>
                            <select class="filter-select" id="filter-custom-type" onchange="setFilter('custom', this.value)">
                                <option value="all">All Types</option>
                            </select>
                        </div>
                        <div class="entity-list" id="list-custom"></div>
                    </div>
                </div>
            </div>

            <div class="explorer-container" id="explorer-container">
                <iframe class="explorer-frame" src="explorer.html" title="Relationship Explorer" sandbox="allow-scripts allow-same-origin allow-modals"></iframe>
            </div>

            <div class="stix-builder-container" id="stix-builder-container">
                <iframe class="stix-builder-frame" src="stix-builder.html" title="STIX Composer" sandbox="allow-scripts allow-same-origin allow-modals"></iframe>
            </div>

            <!-- Content -->
            <div class="content" id="content">
                <div class="content-header">
                    <div class="content-title-wrap">
                        <button class="sidebar-toggle" onclick="toggleSidebar()" aria-label="Toggle sidebar" title="Toggle sidebar">
                            <span class="sidebar-toggle-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M169.4 297.4C156.9 309.9 156.9 330.2 169.4 342.7L361.4 534.7C373.9 547.2 394.2 547.2 406.7 534.7C419.2 522.2 419.2 501.9 406.7 489.4L237.3 320L406.6 150.6C419.1 138.1 419.1 117.8 406.6 105.3C394.1 92.8 373.8 92.8 361.3 105.3L169.3 297.3z"/></svg>
                            </span>
                        </button>
                        <span style="font-size: 0.9rem; font-weight: 500;" id="content-title">Unified Kill Chain</span>
                    </div>
                    <div class="kill-chain-title-wrap">
                        <input type="text" class="kill-chain-title" id="kill-chain-title"
                               placeholder="Untitled Kill Chain"
                               maxlength="200"
                               spellcheck="false"
                               onblur="commitKillChainTitle(this)"
                               onkeydown="if(event.key==='Enter'){this.blur();}">
                    </div>
                    <div class="view-controls">
                        <button class="btn" id="btn-hide-empty" onclick="toggleHideEmpty()">Hide Empty</button>
                        <button class="btn" id="btn-compact" onclick="toggleCompactMode()">Compact</button>
                        <button class="btn" id="btn-comments" onclick="toggleAllComments()">Toggle Comments</button>
                    </div>
                </div>

                <div class="kc-desc-bar" id="kc-desc-bar">
                    <button class="kc-desc-toggle" onclick="toggleDescriptionPanel()" aria-label="Toggle description">
                        <span class="kc-desc-chevron"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M310 233L118 41c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L226.7 240 72.7 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3z"/></svg></span>
                        <span>Description</span>
                        <span class="kc-desc-hint" id="kc-desc-hint"></span>
                    </button>
                    <div class="kc-desc-body">
                        <textarea class="kc-desc-textarea" id="kc-desc-textarea"
                                  placeholder="Describe this kill chain analysis..."
                                  maxlength="2000"
                                  spellcheck="true"
                                  oninput="updateDescriptionCounter()"
                                  onblur="commitKillChainDescription(this)"></textarea>
                        <div class="kc-desc-counter" id="kc-desc-counter"></div>
                    </div>
                </div>

                <div class="stats-bar" id="stats-bar"></div>
                
                <!-- Score Legend -->
                <div class="legend-row" id="legend-row">
                    
                </div>

                <div class="kill-chain-container" id="kill-chain-container">
                    <div class="kill-chain" id="kill-chain"></div>
                </div>

                <div class="relationship-container" id="relationship-container">
                    <div class="relationship-header">
                        <div class="relationship-header-item"><div class="dot capec"></div>CAPEC</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot cwe"></div>CWE</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot attack"></div>ATT&CK</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot phase"></div>Phase</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot mitigation"></div>Mitigations</div>
                    </div>
                    <div class="relationship-wrapper">
                        <div class="relationship-chain" id="relationship-chain"></div>
                        <div class="flow-arrow">
                            <div class="flow-arrow-label">Attack Flow</div>
                            <div class="flow-arrow-line"></div>
                            <div class="flow-arrow-head"></div>
                        </div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-layers" id="legend-layers">
                        <span style="color: var(--text-secondary); margin-right: 6px;">Layers:</span>
                        <div class="layer-toggles">
                            <label class="layer-toggle attack">
                                <input type="checkbox" id="layer-attack" checked onchange="toggleLayer('attack')">
                                <span class="checkbox"></span>
                                <span>ATT&CK</span>
                            </label>
                            <label class="layer-toggle capec">
                                <input type="checkbox" id="layer-capec" checked onchange="toggleLayer('capec')">
                                <span class="checkbox"></span>
                                <span>CAPEC</span>
                            </label>
                            <label class="layer-toggle cwe">
                                <input type="checkbox" id="layer-cwe" checked onchange="toggleLayer('cwe')">
                                <span class="checkbox"></span>
                                <span>CWE</span>
                            </label>
                            <label class="layer-toggle custom">
                                <input type="checkbox" id="layer-custom" checked onchange="toggleLayer('custom')">
                                <span class="checkbox"></span>
                                <span>STIX</span>
                            </label>
                        </div>
                    </div>
                    <div class="score-legend" id="score-legend">
                        <span style="color: var(--text-secondary); margin-right: 8px;">Score:</span>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #22c55e;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #eab308;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #f97316;"></div>
                            <span>High</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #ef4444;"></div>
                            <span>Critical</span>
                        </div>
                    </div>
                    <div class="metadata-legend" id="metadata-legend">
                        <span style="color: var(--text-secondary); margin-right: 6px;">Metadata:</span>
                        <div class="legend-item">
                            <span class="legend-icon has-cve">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                            </span>
                            <span>CVE</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-observable">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg>
                            </span>
                            <span>Observable</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-link">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg>
                            </span>
                            <span>Link</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-comment">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg>
                            </span>
                            <span>Comment</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-confidence">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg>
                            </span>
                            <span>Confidence</span>
                        </div>
                    </div>
                    <div class="github-link">
                        <a title="Show on GitHub" onclick="return(confirm('Open GitHub repository in new tab?'))" href="https://github.com/pr0cella/AttackFlow" target="_blank" rel="noopener noreferrer" >
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M544 160C544 124.7 515.3 96 480 96L160 96C124.7 96 96 124.7 96 160L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 160zM361.8 471.7C361.8 469.9 361.8 465.7 361.9 460.1C362 448.7 362 431.3 362 416.4C362 400.8 356.8 390.9 350.7 385.7C387.7 381.6 426.7 376.5 426.7 312.6C426.7 294.4 420.2 285.3 409.6 273.6C411.3 269.3 417 251.6 407.9 228.6C394 224.3 362.2 246.5 362.2 246.5C335.6 239 305.6 239 279 246.5C279 246.5 247.2 224.3 233.3 228.6C224.2 251.5 229.8 269.2 231.6 273.6C221 285.3 216 294.4 216 312.6C216 376.2 253.3 381.6 290.3 385.7C285.5 390 281.2 397.4 279.7 408C270.2 412.3 245.9 419.7 231.4 394.1C222.3 378.3 205.9 377 205.9 377C189.7 376.8 204.8 387.2 204.8 387.2C215.6 392.2 223.2 411.4 223.2 411.4C232.9 441.1 279.3 431.1 279.3 431.1C279.3 440.1 279.4 452.8 279.4 461.7C279.4 466.5 279.5 470.3 279.5 471.7C279.5 476 276.5 481.2 268 479.7C202 457.6 155.8 394.8 155.8 321.4C155.8 229.6 226 159.9 317.8 159.9C409.6 159.9 484 229.6 484 321.4C484.1 394.8 439.3 457.7 373.3 479.7C364.9 481.2 361.8 476 361.8 471.7zM271.3 416.9C271.1 415.4 272.4 414.1 274.3 413.7C276.2 413.5 278 414.3 278.2 415.6C278.5 416.9 277.2 418.2 275.2 418.6C273.3 419 271.5 418.2 271.3 416.9zM262.2 420.1C260 420.3 258.5 419.2 258.5 417.7C258.5 416.4 260 415.3 262 415.3C263.9 415.1 265.7 416.2 265.7 417.7C265.7 419 264.2 420.1 262.2 420.1zM247.9 417.9C246 417.5 244.7 416 245.1 414.7C245.5 413.4 247.5 412.8 249.2 413.2C251.2 413.8 252.5 415.3 252 416.6C251.6 417.9 249.6 418.5 247.9 417.9zM235.4 410.6C233.9 409.3 233.5 407.4 234.5 406.5C235.4 405.4 237.3 405.6 238.8 407.1C240.1 408.4 240.6 410.4 239.7 411.2C238.8 412.3 236.9 412.1 235.4 410.6zM226.9 400.6C225.8 399.1 225.8 397.4 226.9 396.7C228 395.8 229.7 396.5 230.6 398C231.7 399.5 231.7 401.3 230.6 402.1C229.7 402.7 228 402.1 226.9 400.6zM220.6 391.8C219.5 390.5 219.3 389 220.2 388.3C221.1 387.4 222.6 387.9 223.7 388.9C224.8 390.2 225 391.7 224.1 392.4C223.2 393.3 221.7 392.8 220.6 391.8zM214.6 385.4C213.3 384.8 212.7 383.7 213.1 382.8C213.5 382.2 214.6 381.9 215.9 382.4C217.2 383.1 217.8 384.2 217.4 385C217 385.9 215.7 386.1 214.6 385.4z"/></svg> 
                        </a>
                    </div>
                </div>
            </div>

            <!-- Detail Panel -->
            <div class="detail-panel" id="detail-panel">
                <div class="detail-header">
                    <div class="detail-header-content">
                        <div class="detail-id" id="detail-id"></div>
                        <div class="detail-name" id="detail-name"></div>
                    </div>
                    <button class="detail-close" onclick="closeDetail()">Ã—</button>
                </div>
                <div class="detail-content" id="detail-content"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Entity Detail Modal -->
    <div class="modal-overlay" id="entity-modal" onclick="closeEntityModal(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">
                    <span id="entity-modal-id"></span>
                    <span id="entity-modal-name" style="margin-left: 8px; color: var(--text-secondary);"></span>
                </div>
                <button class="modal-close" onclick="closeEntityModal()">Ã—</button>
            </div>
            <div class="modal-body" id="entity-modal-content"></div>
        </div>
    </div>

    <!-- Phase Details Modal -->
    <div class="modal-overlay" id="phase-details-modal" onclick="closePhaseDetails(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title" id="phase-details-title"></div>
                <button class="modal-close" onclick="closePhaseDetails()">Ã—</button>
            </div>
            <div class="modal-body" id="phase-details-content"></div>
        </div>
    </div>

    <!-- CSV Import Modal -->
    <div class="modal-overlay" id="csv-import-modal" onclick="closeCsvImportModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Import CSV Technique IDs</div>
                <button class="modal-close" onclick="closeCsvImportModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="csv-import-hint">Paste technique IDs separated by commas or new lines (e.g. T1205, T1021.005).</div>
                <textarea class="csv-import-textarea" id="csv-import-textarea" placeholder="T1205&#10;T1021.005" data-allow-newlines="true"></textarea>
                <div class="csv-import-error" id="csv-import-error"></div>
                <div class="csv-import-actions">
                    <button class="btn" onclick="closeCsvImportModal()">Cancel</button>
                    <button class="btn" onclick="submitCsvImport()">Import</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create STIX Item Modal -->
    <div class="create-custom-modal" id="create-custom-modal" onclick="closeCreateCustomModal(event)">
        <div class="create-custom-form" onclick="event.stopPropagation()">
            <h3>Create STIX Item</h3>
            <label for="custom-stix-type">STIX Type</label>
            <select id="custom-stix-type" onchange="toggleCustomTypeName()"></select>
            <div id="custom-typename-group">
                <label for="custom-typename">Custom Type Name</label>
                <input type="text" id="custom-typename" placeholder="e.g. APT Group Profile" maxlength="80" spellcheck="false">
            </div>
            <label for="custom-name">Name <span style="color:#ef4444;">*</span></label>
            <input type="text" id="custom-name" placeholder="e.g. Emotet, APT29, Cobalt Strike" maxlength="200" spellcheck="false">
            <label for="custom-description">Description</label>
            <textarea id="custom-description" placeholder="Optional description..." maxlength="2000" rows="3"></textarea>
            <label for="custom-labels">Labels <span style="color:var(--text-secondary); font-weight:normal;">(comma-separated, max 20)</span></label>
            <input type="text" id="custom-labels" placeholder="e.g. trojan, botnet, ransomware" maxlength="1200" spellcheck="false">
            <div id="create-custom-error" style="color:#ef4444; font-size:0.8rem; margin-bottom:8px;"></div>
            <div class="form-actions">
                <button class="btn-cancel" onclick="closeCreateCustomModal()">Cancel</button>
                <button class="btn-create" onclick="createCustomItem()">Create</button>
            </div>
        </div>
    </div>

    <!-- Edit STIX Item Modal -->
    <div class="edit-stix-modal" id="edit-stix-modal" onclick="closeStixEditor(event)">
        <div class="edit-stix-form" onclick="event.stopPropagation()">
            <div class="edit-stix-header">
                <div style="display:flex;align-items:center;">
                    <h3>Edit STIX Object</h3>
                    <span class="stix-type-badge" id="edit-stix-type-badge"></span>
                </div>
                <button class="edit-stix-close" onclick="closeStixEditor()">&times;</button>
            </div>
            <div class="edit-stix-body" id="edit-stix-body">
                <!-- Dynamically populated by openStixEditor() -->
            </div>
            <div id="edit-stix-error"></div>
            <div class="edit-stix-footer">
                <button class="btn-stix-cancel" onclick="closeStixEditor()">Cancel</button>
                <button class="btn-stix-save" onclick="saveStixEditor()">Save</button>
            </div>
        </div>
    </div>

    <!-- Metadata Editor Modal -->
    <div class="metadata-editor-overlay" id="metadata-editor-modal" onclick="closeMetadataEditor(event)">
        <div class="metadata-editor" onclick="event.stopPropagation()">
            <div class="metadata-editor-header">
                <div class="metadata-editor-title">Edit Metadata: <span id="metadata-entity-id"></span></div>
                <button class="metadata-editor-close" onclick="closeMetadataEditor()">&times;</button>
            </div>
            <div class="metadata-editor-body">
                <!-- Score -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Score (Severity)</div>
                    <div class="score-selector" id="score-selector">
                        <label class="score-option" data-value="unclassified">
                            <span class="score-dot" style="background: #6b7280;"></span>
                            Unclassified
                        </label>
                        <label class="score-option" data-value="low">
                            <span class="score-dot" style="background: #22c55e;"></span>
                            Low
                        </label>
                        <label class="score-option" data-value="medium">
                            <span class="score-dot" style="background: #eab308;"></span>
                            Medium
                        </label>
                        <label class="score-option" data-value="high">
                            <span class="score-dot" style="background: #f97316;"></span>
                            High
                        </label>
                        <label class="score-option" data-value="critical">
                            <span class="score-dot" style="background: #ef4444;"></span>
                            Critical
                        </label>
                    </div>
                </div>
                
                <!-- Confidence -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Confidence Level</div>
                    <div class="confidence-slider-container">
                        <input type="range" class="confidence-slider" id="meta-confidence" min="0" max="100" value="0">
                        <div class="confidence-value">
                            <span class="confidence-label unknown" id="confidence-label">Unknown</span>
                        </div>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px;">
                        0 = Unknown, 1-33% = Low, 34-66% = Medium, 67-100% = High
                    </div>
                </div>
                
                <!-- CVE & CVSS -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Vulnerability References</div>
                    <div class="cve-list" id="cve-list"></div>
                    <button class="add-btn" onclick="addCveRow()">+ Add CVE</button>
                    <div class="metadata-input-error" id="meta-cve-list-error"></div>
                </div>
                
                <!-- Comments -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Comments</div>
                    <textarea class="metadata-input metadata-textarea" id="meta-comments" placeholder="Add notes about this assignment..."></textarea>
                </div>
                
                <!-- Hyperlinks -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Hyperlinks</div>
                    <div class="hyperlink-list" id="hyperlink-list"></div>
                    <button class="add-btn" onclick="addHyperlinkRow()">+ Add Link</button>
                </div>
                
                <!-- Observables -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Observables</div>
                    <div class="observable-list" id="observable-list"></div>
                    <button class="add-btn" onclick="addObservableRow()">+ Add Observable</button>
                </div>
            </div>
            <div class="metadata-editor-footer">
                <button class="metadata-btn metadata-btn-cancel" onclick="closeMetadataEditor()">Cancel</button>
                <button class="metadata-btn metadata-btn-save" onclick="saveMetadata()">Save</button>
            </div>
        </div>
    </div>

    <!-- Usage Guide Modal -->
    <div class="modal-overlay" id="usage-guide-modal" onclick="closeUsageGuide(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Usage Guide</div>
                <button class="modal-close" onclick="closeUsageGuide()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="guide-section">
                    <h4>Getting Started</h4>
                    <ul>
                        <li>Browse <span class="guide-key">ATT&CK</span>, <span class="guide-key">CAPEC</span>, <span class="guide-key">CWE</span>, and <span class="guide-key">STIX</span> tabs in the left sidebar</li>
                        <li>Use the search bar to find specific techniques, patterns, weaknesses, or STIX objects</li>
                        <li>Click any entity to view detailed information in the right panel</li>
                        <li>Switch to <span class="guide-key">Relationship Explorer</span> to investigate ATT&CK â†” CAPEC â†” CWE â†” Mitigations without assigning items</li>
                        <li>Use <span class="guide-key">Phase Details</span> on phase headers or relationship rows for a rollup summary</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>STIX 2.1 Objects</h4>
                    <ul>
                        <li>Use the STIX Composer to compose objects and bundles, then review them in the visualizer/validator</li>
                        <li>Open the <span class="guide-key">STIX</span> tab to create or import STIX Domain Objects</li>
                        <li>Click <strong>+ Create STIX Item</strong> to manually create any of the 18 SDO types (plus custom)</li>
                        <li>Click <strong>Import STIX Bundle</strong> to load a STIX 2.1 bundle JSON â€” all SDOs are extracted with full properties</li>
                        <li>Use the type filter dropdown to browse by STIX type (Threat Actor, Malware, Indicator, etc.)</li>
                        <li>Drag STIX items onto kill chain phases just like ATT&CK/CAPEC/CWE entities</li>
                        <li>Click the <span class="guide-key">âœŽ</span> button on assigned STIX items to edit all spec-defined properties</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Drag & Drop</h4>
                    <ul>
                        <li>Drag entities from the sidebar directly onto kill chain phases</li>
                        <li>Drop zones highlight when dragging over them</li>
                        <li>Entities can be reassigned by dragging to a different phase</li>
                        <li>Click the <span class="guide-key">Ã—</span> on an assigned entity to remove it</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Metadata & Enrichment</h4>
                    <ul>
                        <li>Click assigned ATT&CK/CAPEC/CWE entities in the diagram to open the metadata editor</li>
                        <li>Add <strong>Score</strong> (severity) and <strong>Confidence</strong> (assessment certainty)</li>
                        <li>Add multiple <strong>CVE-ID(s)</strong> with optional <strong>scores</strong> and <strong>CVSS vectors</strong></li>
                        <li>Add <strong>Observables</strong>: IPs, hashes, domains, URLs, file names</li>
                        <li>Attach <strong>Hyperlinks</strong> and <strong>Comments</strong> for context</li>
                        <li>CVE badges show full IDs or <strong>CVE (N)</strong> for multiples</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Kill Chain Phases</h4>
                    <ul>
                        <li><span class="guide-color" style="background: var(--phase-in)"></span><strong>IN</strong> â€” Initial Foothold (reconnaissance â†’ C2)</li>
                        <li><span class="guide-color" style="background: var(--phase-through)"></span><strong>THROUGH</strong> â€” Network Propagation (pivoting â†’ lateral movement)</li>
                        <li><span class="guide-color" style="background: var(--phase-out)"></span><strong>OUT</strong> â€” Action on Objectives (collection â†’ impact)</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>View Controls</h4>
                    <ul>
                        <li>Toggle <span class="guide-key">ATT&CK</span> <span class="guide-key">CAPEC</span> <span class="guide-key">CWE</span> <span class="guide-key">STIX</span> layers to show/hide entity types</li>
                        <li>Use domain filters (All / Enterprise / Mobile / ICS) for techniques</li>
                        <li>Use abstraction filters for CAPECs and CWEs</li>
                        <li>Enable <span class="guide-key">Hide Empty</span> to focus on phases with assignments</li>
                        <li>Switch to <span class="guide-key">Relationships</span> view for CAPECâ†’CWEâ†’ATT&CK chains</li>
                        <li>Mitigation relationships appear in the Relationships view, with expandable lists</li>
                        <li>Use <span class="guide-key">Relationship Explorer</span> for full entity and mitigation browsing</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Import & Export</h4>
                    <ul>
                        <li><strong>JSON Export</strong> â€” Lightweight kill chain state for sharing</li>
                        <li><strong>JSON Import</strong> â€” Restore exported kill chains</li>
                        <li><strong>CSV Export</strong> â€” Spreadsheet format with all metadata</li>
                        <li><strong>STIX Bundle Export</strong> â€” Generate a STIX 2.1 bundle with SDOs and relationship SROs</li>
                        <li><strong>STIX Bundle Import</strong> â€” Load external STIX bundles (e.g., CTI reports) into the STIX library</li>
                        <li><strong>Navigator Import</strong> â€” Load ATT&CK Navigator layer files</li>
                        <li>Use <span class="guide-key">Clear All</span> to reset the workspace</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Tips</h4>
                    <ul>
                        <li>Assigned entities appear dimmed in the sidebar</li>
                        <li>Click phase headers to expand/collapse</li>
                        <li>Score colors appear as left border ribbons on items</li>
                        <li>Related CAPECs and CWEs are shown in the detail panel</li>
                        <li>Click the version number to view the changelog</li>
                        <li>The app works offline from <code>file://</code> â€” click "Continue Without Data" on the loading screen</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div class="modal-overlay" id="changelog-modal" onclick="closeChangelog(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Changelog</div>
                <button class="modal-close" onclick="closeChangelog()">Ã—</button>
            </div>
            <div class="modal-body changelog-body" id="changelog-content">
                <div class="loading-text">Loading changelog...</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // VERSION - Loaded dynamically from changelog
        // ============================================================
        let APP_VERSION = '2.4.2';  // Fallback version
        
        async function loadVersion() {
            try {
                if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
                    APP_VERSION = (typeof CONFIG !== 'undefined' && CONFIG.version) ? CONFIG.version : APP_VERSION;
                    const versionEl = document.getElementById('app-version');
                    if (versionEl) versionEl.textContent = 'v' + APP_VERSION;
                    return;
                }
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                const match = text.match(/^## \[([\d.]+)\]/m);
                if (match) {
                    APP_VERSION = match[1];
                    const versionEl = document.getElementById('app-version');
                    if (versionEl) versionEl.textContent = 'v' + APP_VERSION;
                }
            } catch (e) {
                console.warn('Could not load version from changelog:', e);
            }
        }

        // ============================================================
        // INPUT SECURITY - Validation, Sanitization, Escaping
        // ============================================================
        const InputSecurity = {
            // HTML escape to prevent XSS
            escapeHtml(str) {
                if (str === null || str === undefined) return '';
                const div = document.createElement('div');
                div.textContent = String(str);
                return div.innerHTML;
            },

            // Encode HTML entities (including quotes and backticks)
            encodeHtmlEntities(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/`/g, '&#96;');
            },

            // Normalize input: remove control chars, strip script tags, trim, limit length
            normalize(str, maxLength = 1000) {
                if (str === null || str === undefined) return '';
                // NOTE: Do NOT add .trim() here â€” normalize() is called on every
                // keystroke by the live input sanitizer.  Trimming here strips
                // trailing spaces as the user types, making it impossible to
                // enter spaces between words.  Trim at commit/storage time only
                // (see sanitize() and sanitizeForStorage()).  KCE-SEC-010.
                return String(str)
                    .replace(/[\x00-\x1F\x7F]/g, '')  // Remove control chars
                    .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Remove script tags
                    .slice(0, maxLength);
            },
            
            // Sanitize: remove control chars, strip disallowed chars, trim, limit length, encode entities
            sanitize(str, maxLength = 1000) {
                let value = this.normalize(str, maxLength).trim();
                // Remove disallowed bracket/quote/semicolon characters and SQL comment markers
                value = value.replace(/[\[\]\{\};"'`]/g, '');
                value = value.replace(/--+/g, '');
                return this.encodeHtmlEntities(value);
            },
            
            // Sanitize for use in HTML attributes
            sanitizeAttr(str, maxLength = 200) {
                return this.encodeHtmlEntities(this.sanitize(str, maxLength));
            },
            
            // Validators - return { valid: boolean, message?: string }
            validators: {
                ipv4(v) {
                    const valid = /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv4 address' };
                },
                ipv6(v) {
                    const valid = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::$|^(?:[0-9a-fA-F]{1,4}:){1,7}:$|^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv6 address' };
                },
                md5(v) {
                    const valid = /^[a-fA-F0-9]{32}$/.test(v);
                    return { valid, message: valid ? null : 'MD5 must be 32 hex characters' };
                },
                sha1(v) {
                    const valid = /^[a-fA-F0-9]{40}$/.test(v);
                    return { valid, message: valid ? null : 'SHA1 must be 40 hex characters' };
                },
                sha256(v) {
                    const valid = /^[a-fA-F0-9]{64}$/.test(v);
                    return { valid, message: valid ? null : 'SHA256 must be 64 hex characters' };
                },
                domain(v) {
                    const valid = /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid domain name' };
                },
                url(v) {
                    const valid = /^https?:\/\/[^\s<>"{}|\\^`\[\]]+$/.test(v);
                    return { valid, message: valid ? null : 'Invalid URL (must start with http:// or https://)' };
                },
                cveId(v) {
                    const valid = /^CVE-\d{4}-\d{4,}$/.test(v);
                    return { valid, message: valid ? null : 'CVE format: CVE-YYYY-NNNNN' };
                },
                cvssVector(v) {
                    const valid = /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(v);
                    return { valid, message: valid ? null : 'Invalid CVSS 3.x vector string' };
                },
                filename(v) {
                    const valid = /^[^<>:"/\\|?*\x00-\x1F]+$/.test(v) && v.length <= 255;
                    return { valid, message: valid ? null : 'Invalid filename' };
                },
                text(v, maxLen = 1000) {
                    const valid = v.length <= maxLen;
                    return { valid, message: valid ? null : `Text exceeds ${maxLen} characters` };
                }
            },
            
            // Validate observable based on type
            validateObservable(type, value) {
                const v = this.normalize(value, 500);
                switch (type) {
                    case 'ipv4-addr': return this.validators.ipv4(v);
                    case 'ipv6-addr': return this.validators.ipv6(v);
                    case 'file-hash-md5': return this.validators.md5(v);
                    case 'file-hash-sha1': return this.validators.sha1(v);
                    case 'file-hash-sha256': return this.validators.sha256(v);
                    case 'domain-name': return this.validators.domain(v);
                    case 'url': return this.validators.url(v);
                    case 'file-name': return this.validators.filename(v);
                    case 'threat-actor':
                    case 'malware':
                        return this.validators.text(v, 100);
                    default:
                        return { valid: true };
                }
            }
        };

        // KCE-SEC-001: Shorthand for escaping HTML in template strings
        const esc = (str) => InputSecurity.escapeHtml(str);
        const escAttr = (str) => InputSecurity.sanitizeAttr(str);

        const BLOCKED_INPUT_CHARS = new Set(['<', '>', '[', ']', '{', '}', '"', "'", '`', ';']);

        function isTextInputElement(el) {
            return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA');
        }

        function normalizeUserInput(text, maxLength = 10000, allowNewlines = false) {
            if (text === null || text === undefined) return '';
            const controlPattern = allowNewlines
                ? /[\x00-\x09\x0B-\x0C\x0E-\x1F\x7F]/g
                : /[\x00-\x1F\x7F]/g;
            return String(text)
                .replace(controlPattern, '')
                .replace(/<script[^>]*>.*?<\/script>/gi, '')
                .slice(0, maxLength);
        }

        function sanitizeUserInputText(text, allowNewlines = false) {
            let value = normalizeUserInput(text, 10000, allowNewlines);
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function sanitizeForStorage(text, maxLength = 1000) {
            let value = InputSecurity.normalize(text, maxLength).trim();
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function truncateAtBoundary(text, maxLen = 500) {
            if (!text) return '';
            if (text.length <= maxLen) return text;
            const slice = text.slice(0, maxLen);
            const sentenceMatch = slice.match(/([\s\S]*?[.!?])\s[^.!?]*$/);
            let cut = sentenceMatch ? sentenceMatch[1].trimEnd() : '';
            if (!cut || cut.length < maxLen * 0.6) {
                const wsIndex = slice.lastIndexOf(' ');
                cut = wsIndex > 0 ? slice.slice(0, wsIndex).trimEnd() : slice.trimEnd();
            }
            return `${cut}â€¦`;
        }

        function applyInputGuards() {
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                const key = e.key;
                if (BLOCKED_INPUT_CHARS.has(key)) {
                    e.preventDefault();
                    return;
                }

                if (key === '-') {
                    const value = target.value || '';
                    const start = target.selectionStart ?? 0;
                    const end = target.selectionEnd ?? start;
                    const prev = start > 0 ? value[start - 1] : '';
                    const next = end < value.length ? value[end] : '';
                    if (prev === '-' || next === '-') {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('beforeinput', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.inputType === 'insertText' && e.data) {
                    if ([...e.data].some(ch => BLOCKED_INPUT_CHARS.has(ch))) {
                        e.preventDefault();
                    }
                    if (e.data.includes('--')) {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('paste', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = (e.clipboardData || window.clipboardData)?.getData('text');
                if (!data) return;
                const allowNewlines = target?.dataset?.allowNewlines === 'true';
                const sanitized = sanitizeUserInputText(data, allowNewlines);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('drop', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = e.dataTransfer?.getData('text');
                if (!data) return;
                const allowNewlines = target?.dataset?.allowNewlines === 'true';
                const sanitized = sanitizeUserInputText(data, allowNewlines);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('input', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const value = target.value || '';
                const allowNewlines = target?.dataset?.allowNewlines === 'true';
                const sanitized = sanitizeUserInputText(value, allowNewlines);
                if (sanitized !== value) {
                    const pos = target.selectionStart ?? sanitized.length;
                    target.value = sanitized;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(pos, pos);
                    }
                }
            });
        }

        // Encode < and > in any JSON-loaded strings
        const DANGEROUS_OBJECT_KEYS = new Set(['__proto__', 'prototype', 'constructor']);

        function isDangerousObjectKey(key) {
            return typeof key === 'string' && DANGEROUS_OBJECT_KEYS.has(key);
        }

        function createSafeObject() {
            return Object.create(null);
        }

        function hasOwn(obj, key) {
            return !!obj && Object.prototype.hasOwnProperty.call(obj, key);
        }

        function parseJsonSafe(text) {
            return JSON.parse(text, (key, value) => {
                if (isDangerousObjectKey(key)) return undefined;
                return value;
            });
        }

        function stripAngleBracketsFromJson(value) {
            if (typeof value === 'string') {
                return value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }
            if (Array.isArray(value)) {
                return value.map(stripAngleBracketsFromJson);
            }
            if (value && typeof value === 'object') {
                const cleaned = createSafeObject();
                for (const [key, val] of Object.entries(value)) {
                    if (isDangerousObjectKey(key)) continue;
                    cleaned[key] = stripAngleBracketsFromJson(val);
                }
                return cleaned;
            }
            return value;
        }

        // ============================================================
        // METADATA HELPERS
        // ============================================================
        // Default metadata structure
        function createDefaultMetadata() {
            return {
                score: 'unclassified',     // Color-coded severity: unclassified|low|medium|high|critical
                confidence: null,           // Percentage: null (Unknown) or 1-100
                comments: '',
                cveEntries: [],
                cveId: '',
                cveIds: [],
                hyperlinks: [],    // [{ label, url }]
                observables: []    // [{ type, value }]
            };
        }

        function getCveEntries(metadata) {
            const entries = [];
            const pushEntry = (entry) => {
                const id = (entry?.id || entry?.cveId || '').toString().trim().toUpperCase();
                const vector = (entry?.vector || entry?.cvssVector || '').toString().trim();
                const scoreRaw = entry?.score;
                const score = typeof scoreRaw === 'number' ? scoreRaw : (scoreRaw ? parseFloat(scoreRaw) : null);
                if (id) {
                    entries.push({ id, score: Number.isFinite(score) ? score : null, vector: vector || '' });
                }
            };

            if (Array.isArray(metadata?.cveEntries)) {
                metadata.cveEntries.forEach(pushEntry);
            }

            if (Array.isArray(metadata?.cves)) {
                metadata.cves.forEach(pushEntry);
            }

            if (!entries.length) {
                const rawIds = Array.isArray(metadata?.cveIds)
                    ? metadata.cveIds
                    : (metadata?.cveId ? [metadata.cveId] : []);
                const normalized = rawIds
                    .map(value => (value || '').trim().toUpperCase())
                    .filter(Boolean);
                normalized.forEach(id => {
                    entries.push({ id, score: null, vector: (metadata?.cvssVector || '').trim() });
                });
            }

            return entries;
        }

        function getCveList(metadata) {
            const entries = getCveEntries(metadata);
            const ids = entries.map(entry => entry.id).filter(Boolean);
            return [...new Set(ids)];
        }

        function normalizeCveMetadata(metadata) {
            if (!metadata || typeof metadata !== 'object') return createDefaultMetadata();
            const entries = getCveEntries(metadata);
            metadata.cveEntries = entries;
            metadata.cveIds = entries.map(entry => entry.id);
            metadata.cveId = metadata.cveIds[0] || '';
            return metadata;
        }

        // Get confidence label from percentage value
        function getConfidenceLabel(value) {
            if (value === null || value === undefined || value === 0) return 'Unknown';
            if (value <= 33) return 'Low';
            if (value <= 66) return 'Medium';
            return 'High';
        }

        // Get confidence CSS class
        function getConfidenceClass(value) {
            if (value === null || value === undefined || value === 0) return 'unknown';
            if (value <= 33) return 'low';
            if (value <= 66) return 'medium';
            return 'high';
        }

        let assignmentInstanceCounter = 0;

        function createAssignmentInstanceId() {
            assignmentInstanceCounter += 1;
            return `itm-${Date.now().toString(36)}-${assignmentInstanceCounter}`;
        }

        // Migrate old ID-only format to new object format
        function migrateAssignment(idOrObj) {
            if (typeof idOrObj === 'string') {
                return { id: idOrObj, metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
            }
            // Ensure metadata exists
            if (!idOrObj.metadata) {
                idOrObj.metadata = createDefaultMetadata();
            }
            idOrObj.metadata = normalizeCveMetadata(idOrObj.metadata);
            if (!idOrObj.instanceId) {
                idOrObj.instanceId = createAssignmentInstanceId();
            }
            return idOrObj;
        }

        // Get ID from assignment (handles both old and new format)
        function getAssignmentId(assignment) {
            return typeof assignment === 'string' ? assignment : assignment.id;
        }

        // Get metadata from assignment
        function getAssignmentMetadata(assignment) {
            if (typeof assignment === 'string') return createDefaultMetadata();
            return normalizeCveMetadata(assignment.metadata || createDefaultMetadata());
        }

        function getAssignmentInstanceId(assignment) {
            return typeof assignment === 'string' ? null : assignment.instanceId;
        }

        // ============================================================
        // TYPE MAPPING CONSTANTS
        // ============================================================
        // Canonical mapping from entity type string to assignment array key
        const TYPE_KEYS = {
            attack:  'techniques',
            capec:   'capecs',
            cwe:     'cwes',
            custom:  'customItems'
        };

        // CSS class mapping for entity tags
        const TAG_CLASSES = {
            attack:  'technique-tag',
            capec:   'capec-tag',
            cwe:     'cwe-tag',
            custom:  'custom-tag'
        };

        // Entity type labels for display
        const TYPE_LABELS = {
            attack: 'ATT&CK',
            capec: 'CAPEC',
            cwe: 'CWE',
            custom: 'STIX'
        };

        // All entity type keys for iteration
        const ALL_ENTITY_TYPES = Object.keys(TYPE_KEYS);

        // STIX 2.1 ID format: {type}--{uuid}
        const STIX_ID_PATTERN = /^[a-z][a-z0-9-]*--[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;

        // Valid STIX SDO type values
        const VALID_STIX_TYPES = new Set((typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).map(t => t.value));

        // STIX relationship type defaults by source SDO type
        const STIX_RELATIONSHIP_MAP = {
            'malware': 'uses',
            'tool': 'uses',
            'threat-actor': 'uses',
            'campaign': 'uses',
            'intrusion-set': 'uses',
            'indicator': 'indicates',
            'course-of-action': 'mitigates',
            'infrastructure': 'supports',
            'malware-analysis': 'analysis-of',
            'identity': 'related-to',
            'location': 'related-to',
            'note': 'related-to',
            'observed-data': 'related-to',
            'opinion': 'related-to',
            'report': 'related-to',
            'attack-pattern': 'related-to',
            'grouping': 'related-to',
            'vulnerability': 'related-to',
            'x-custom': 'related-to'
        };

        // Generate a UUIDv4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // Generate a STIX 2.1 compliant ID
        function generateStixId(stixType) {
            return `${stixType}--${generateUUID()}`;
        }

        // Deterministic UUIDv5 from namespace + name (RFC 4122 Â§4.3)
        // Uses SHA-1 truncated to 128 bits with version/variant bits set
        const MITIGATION_NS_UUID = 'af7e2c13-3b4d-4e5f-8a9b-0c1d2e3f4a5b';
        const TECHNIQUE_NS_UUID = 'bf8f3d24-4c5e-5f60-9bac-1d2e3f405b6c';

        function uuidv5(namespace, name) {
            const nsHex = namespace.replace(/-/g, '');
            const nsBytes = new Uint8Array(16);
            for (let i = 0; i < 16; i++) nsBytes[i] = parseInt(nsHex.substr(i * 2, 2), 16);
            const nameBytes = new TextEncoder().encode(name);
            const data = new Uint8Array(nsBytes.length + nameBytes.length);
            data.set(nsBytes); data.set(nameBytes, nsBytes.length);
            const hash = sha1Bytes(data);
            hash[6] = (hash[6] & 0x0f) | 0x50;
            hash[8] = (hash[8] & 0x3f) | 0x80;
            const hex = Array.from(hash.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20,32)}`;
        }

        // Minimal SHA-1 (FIPS 180-4) â€” pure JS, no dependencies
        function sha1Bytes(msgBytes) {
            const msg = Array.from(msgBytes);
            const bitLen = msg.length * 8;
            msg.push(0x80);
            while (msg.length % 64 !== 56) msg.push(0);
            msg.push(0, 0, 0, 0);
            msg.push((bitLen >>> 24) & 0xff, (bitLen >>> 16) & 0xff, (bitLen >>> 8) & 0xff, bitLen & 0xff);
            let h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE, h3 = 0x10325476, h4 = 0xC3D2E1F0;
            for (let off = 0; off < msg.length; off += 64) {
                const w = new Array(80);
                for (let i = 0; i < 16; i++) w[i] = (msg[off+i*4]<<24)|(msg[off+i*4+1]<<16)|(msg[off+i*4+2]<<8)|msg[off+i*4+3];
                for (let i = 16; i < 80; i++) { const t = w[i-3]^w[i-8]^w[i-14]^w[i-16]; w[i] = (t<<1)|(t>>>31); }
                let a=h0, b=h1, c=h2, d=h3, e=h4;
                for (let i = 0; i < 80; i++) {
                    let f, k;
                    if (i<20)      { f=(b&c)|((~b)&d); k=0x5A827999; }
                    else if (i<40) { f=b^c^d;           k=0x6ED9EBA1; }
                    else if (i<60) { f=(b&c)|(b&d)|(c&d); k=0x8F1BBCDC; }
                    else           { f=b^c^d;           k=0xCA62C1D6; }
                    const tmp = ((a<<5)|(a>>>27)) + f + e + k + w[i];
                    e=d; d=c; c=(b<<30)|(b>>>2); b=a; a=tmp|0;
                }
                h0=(h0+a)|0; h1=(h1+b)|0; h2=(h2+c)|0; h3=(h3+d)|0; h4=(h4+e)|0;
            }
            const result = new Uint8Array(20);
            [h0,h1,h2,h3,h4].forEach((h, i) => {
                result[i*4]=(h>>>24)&0xff; result[i*4+1]=(h>>>16)&0xff; result[i*4+2]=(h>>>8)&0xff; result[i*4+3]=h&0xff;
            });
            return result;
        }

        function mitigationStixId(mitreId) {
            return `course-of-action--${uuidv5(MITIGATION_NS_UUID, mitreId)}`;
        }

        function techniqueStixId(techId) {
            return `attack-pattern--${uuidv5(TECHNIQUE_NS_UUID, techId)}`;
        }

        function getPhaseUngroupedItems(phaseData, type) {
            const key = TYPE_KEYS[type];
            if (!key) return [];
            return phaseData?.[key] || [];
        }

        function getPhaseGroupedItems(phaseData, type) {
            const groups = Array.isArray(phaseData?.groups) ? phaseData.groups : [];
            return groups.flatMap(group => (group.items || []).filter(item => item.type === type));
        }

        function getAllPhaseItemsByType(phaseData, type) {
            return [...getPhaseUngroupedItems(phaseData, type), ...getPhaseGroupedItems(phaseData, type)];
        }

        function ensurePhaseLayout(phaseKey, phaseData) {
            if (!phaseData.layout || !Array.isArray(phaseData.layout)) {
                phaseData.layout = [];
            }

            const existingItemIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'item').map(entry => entry.instanceId)
            );
            const existingGroupIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'group').map(entry => entry.groupId)
            );

            for (const type of ALL_ENTITY_TYPES) {
                const items = getPhaseUngroupedItems(phaseData, type);
                items.forEach(item => {
                    const instanceId = getAssignmentInstanceId(item);
                    if (instanceId && !existingItemIds.has(instanceId)) {
                        phaseData.layout.push({ kind: 'item', type, instanceId });
                        existingItemIds.add(instanceId);
                    }
                });
            }

            (phaseData.groups || []).forEach(group => {
                if (group?.groupId && !existingGroupIds.has(group.groupId)) {
                    phaseData.layout.push({ kind: 'group', groupId: group.groupId });
                    existingGroupIds.add(group.groupId);
                }
            });

            phaseData.layout = phaseData.layout.filter(entry => {
                if (entry.kind === 'item') {
                    const type = entry.type;
                    return getPhaseUngroupedItems(phaseData, type)
                        .some(item => getAssignmentInstanceId(item) === entry.instanceId);
                }
                if (entry.kind === 'group') {
                    return (phaseData.groups || []).some(group => group.groupId === entry.groupId);
                }
                return false;
            });
        }

        function generateGroupId() {
            return `grp-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;
        }

        function createGroup(phaseKey) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = {
                groupId: generateGroupId(),
                label: 'New Group',
                collapsed: false,
                items: []
            };
            phaseData.groups = phaseData.groups || [];
            phaseData.groups.push(group);
            ensurePhaseLayout(phaseKey, phaseData);
            renderKillChain();
            startRenameGroup(phaseKey, group.groupId);
        }

        function toggleGroupCollapse(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.collapsed = !group.collapsed;
            const escapedId = window.CSS && CSS.escape ? CSS.escape(groupId) : groupId.replace(/"/g, '\\"');
            const groupEl = document.querySelector(`.phase-group[data-group-id="${escapedId}"]`);
            if (groupEl) {
                groupEl.classList.toggle('collapsed', group.collapsed);
            } else {
                renderKillChain();
            }
        }

        function startRenameGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = true;
            renderKillChain();
            setTimeout(() => {
                const input = document.getElementById(`group-rename-${groupId}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 0);
        }

        function commitRenameGroup(phaseKey, groupId, value, cancel = false) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = false;
            if (!cancel) {
                const sanitized = sanitizeForStorage(value || '', 80).trim();
                group.label = sanitized || 'New Group';
            }
            renderKillChain();
        }

        function removeGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const groupIdx = (phaseData.groups || []).findIndex(g => g.groupId === groupId);
            if (groupIdx === -1) return;

            const group = phaseData.groups[groupIdx];
            if (!window.confirm('Delete this group and move its items back to the phase?')) return;

            const items = group.items || [];
            items.forEach(item => {
                const key = item.type === 'attack' ? 'techniques' : item.type === 'capec' ? 'capecs' : 'cwes';
                phaseData[key].push(item);
                phaseData.layout.push({ kind: 'item', type: item.type, instanceId: getAssignmentInstanceId(item) });
            });

            phaseData.groups.splice(groupIdx, 1);
            phaseData.layout = (phaseData.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function extractAssignmentInstance(phaseKey, type, instanceId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return null;
            const key = TYPE_KEYS[type];
            if (!key) return null;

            const list = phaseData[key];
            const idx = list.findIndex(a => getAssignmentInstanceId(a) === instanceId);
            if (idx !== -1) {
                const [removed] = list.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                return removed;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => getAssignmentInstanceId(a) === instanceId);
                if (gIdx !== -1) {
                    const [removed] = group.items.splice(gIdx, 1);
                    return removed;
                }
            }

            return null;
        }

        function moveGroupBetweenPhases(fromPhase, toPhase, groupId) {
            if (!fromPhase || !toPhase || fromPhase === toPhase) return;
            const source = state.assignments[fromPhase];
            const target = state.assignments[toPhase];
            if (!source || !target) return;

            const idx = (source.groups || []).findIndex(g => g.groupId === groupId);
            if (idx === -1) return;
            const [group] = source.groups.splice(idx, 1);
            target.groups = target.groups || [];
            target.groups.push(group);

            source.layout = (source.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            ensurePhaseLayout(toPhase, target);
        }

        // Find assignment object by ID in a phase
        function findAssignment(phaseKey, entityType, id, instanceId = null) {
            const key = TYPE_KEYS[entityType];
            if (!key) return null;
            const phaseData = state.assignments[phaseKey];
            const assignments = phaseData?.[key] || [];
            if (instanceId) {
                const match = assignments.find(a => getAssignmentInstanceId(a) === instanceId);
                if (match) return match;
                for (const group of phaseData?.groups || []) {
                    const groupMatch = (group.items || []).find(a => getAssignmentInstanceId(a) === instanceId);
                    if (groupMatch) return groupMatch;
                }
                return null;
            }

            const match = assignments.find(a => getAssignmentId(a) === id);
            if (match) return match;
            for (const group of phaseData?.groups || []) {
                const groupMatch = (group.items || []).find(a => getAssignmentId(a) === id && a.type === entityType);
                if (groupMatch) return groupMatch;
            }
            return null;
        }

        // Update metadata for an assignment
        function updateAssignmentMetadata(phaseKey, entityType, id, newMetadata, instanceId = null) {
            const key = TYPE_KEYS[entityType];
            if (!key) return;
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const assignments = phaseData[key] || [];

            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                if (typeof assignments[idx] === 'string') {
                    assignments[idx] = { id: assignments[idx], metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
                }
                assignments[idx].metadata = { ...assignments[idx].metadata, ...newMetadata };
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => instanceId
                    ? getAssignmentInstanceId(a) === instanceId
                    : (getAssignmentId(a) === id && a.type === entityType)
                );
                if (gIdx !== -1) {
                    group.items[gIdx].metadata = { ...group.items[gIdx].metadata, ...newMetadata };
                    return;
                }
            }
        }

        // Score level config (color-coded severity)
        const SCORE_LEVELS = {
            unclassified: { label: 'Unclassified', color: null, bgColor: null },
            low: { label: 'Low', color: '#22c55e', bgColor: 'rgba(34, 197, 94, 0.1)' },
            medium: { label: 'Medium', color: '#eab308', bgColor: 'rgba(234, 179, 8, 0.1)' },
            high: { label: 'High', color: '#f97316', bgColor: 'rgba(249, 115, 22, 0.1)' },
            critical: { label: 'Critical', color: '#ef4444', bgColor: 'rgba(239, 68, 68, 0.15)' }
        };

        // Observable types
        const OBSERVABLE_TYPES = [
            { value: 'ipv4-addr', label: 'IPv4 Address' },
            { value: 'ipv6-addr', label: 'IPv6 Address' },
            { value: 'file-hash-md5', label: 'Hash (MD5)' },
            { value: 'file-hash-sha1', label: 'Hash (SHA1)' },
            { value: 'file-hash-sha256', label: 'Hash (SHA256)' },
            { value: 'domain-name', label: 'Domain Name' },
            { value: 'url', label: 'URL' },
            { value: 'file-name', label: 'File Name' },
            { value: 'malware', label: 'Malware Name' },
            { value: 'threat-actor', label: 'Threat Actor' }
        ];

        // ============================================================
        // STATE
        // ============================================================
        const state = {
            view: 'killchain',  // 'killchain' | 'relationship'
            layers: { attack: true, capec: true, cwe: true, custom: true },
            hideEmpty: false,
            compactMode: false,
            showComments: false,
            relationshipExpanded: new Set(),
            activeTab: 'attack',
            globalSearch: '',
            globalSearchOpen: false,
            globalSearchExpanded: false,
            globalSearchSticky: false,
            filters: { attack: 'all', capec: 'all', cwe: 'all', custom: 'all' },
            
            // Full data libraries (loaded from JSON)
            library: {
                techniques: {},  // T1566 -> { id, name, domain }
                capecs: {},      // CAPEC-98 -> { id, name, severity, ... }
                cwes: {},        // CWE-89 -> { id, name, ... }
                custom: {}       // malware--uuid -> { id, stixType, name, description, labels, created, modified }
            },
            
            // Mappings
            techniqueToCapec: {},
            cweToCapec: {},
            capecToTechnique: {},
            
            // Kill chain title & description
            title: '',
            description: '',

            // Assigned entities (by phase)
            assignments: {},
            
            // Current selection
            selection: { type: null, id: null }
        };

        // Kill chain structure
        const KILL_CHAIN = {
            'IN': {
                name: 'Initial Foothold',
                phases: ['reconnaissance', 'resource-development', 'delivery', 'social-engineering', 'exploitation', 'persistence', 'defense-evasion', 'command-control']
            },
            'THROUGH': {
                name: 'Network Propagation',
                phases: ['pivoting', 'discovery', 'privilege-escalation', 'execution', 'credential-access', 'lateral-movement']
            },
            'OUT': {
                name: 'Action on Objectives',
                phases: ['collection', 'exfiltration', 'impact', 'objectives']
            }
        };

        // All phases in order
        const ALL_PHASES = [];
        for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
            for (const phase of data.phases) {
                ALL_PHASES.push(`${superPhase}:${phase}`);
            }
        }

        // Phase name formatter
        function formatPhaseName(id) {
            return id.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // Initialize all phase assignments
        function initAssignments() {
            for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
                for (const phase of data.phases) {
                    const key = `${superPhase}:${phase}`;
                    state.assignments[key] = { techniques: [], capecs: [], cwes: [], customItems: [], groups: [], layout: [] };
                }
            }
            // Restore full technique library from base data
            if (state._baseTechniques) {
                state.library.techniques = { ...state._baseTechniques };
            }
            state.title = '';
            state.description = '';
            syncTitleToDOM();
            syncDescriptionToDOM();
        }

        // Kill-chain title helpers
        function commitKillChainTitle(el) {
            const maxLen = CONFIG.display?.maxTitleLength || 200;
            const raw = el.value;
            const clean = sanitizeForStorage(raw, maxLen);
            state.title = clean;
            el.value = clean;
        }

        function syncTitleToDOM() {
            const el = document.getElementById('kill-chain-title');
            if (el) el.value = state.title || '';
        }

        // Kill-chain description helpers
        function commitKillChainDescription(el) {
            const maxLen = CONFIG.display?.maxKillChainDescLength || 2000;
            const raw = el.value;
            const clean = sanitizeForStorage(raw, maxLen);
            state.description = clean;
            el.value = clean;
            updateDescriptionHint();
            updateDescriptionCounter();
        }

        function syncDescriptionToDOM() {
            const el = document.getElementById('kc-desc-textarea');
            if (el) el.value = state.description || '';
            updateDescriptionHint();
            updateDescriptionCounter();
            // Collapse panel on sync
            const bar = document.getElementById('kc-desc-bar');
            if (bar) bar.classList.remove('open');
        }

        function toggleDescriptionPanel() {
            const bar = document.getElementById('kc-desc-bar');
            if (bar) bar.classList.toggle('open');
        }

        function updateDescriptionHint() {
            const hint = document.getElementById('kc-desc-hint');
            if (!hint) return;
            const desc = state.description || '';
            if (desc) {
                const preview = desc.length > 80 ? desc.substring(0, 80) + '\u2026' : desc;
                hint.textContent = '\u2014 ' + preview;
            } else {
                hint.textContent = '\u2014 none';
            }
        }

        function updateDescriptionCounter() {
            const el = document.getElementById('kc-desc-counter');
            const ta = document.getElementById('kc-desc-textarea');
            if (!el || !ta) return;
            const maxLen = CONFIG.display?.maxKillChainDescLength || 2000;
            el.textContent = ta.value.length + ' / ' + maxLen;
        }

        // ============================================================
        // DATA LOADING
        // ============================================================
        const SHARED_DATA_ENDPOINTS = {
            attack: 'resources/attack-techniques.json',
            capec: 'resources/capec-full.json',
            cwe: 'resources/cwe-full.json',
            techniqueToCapec: 'resources/technique-to-capec.json',
            capecToTechnique: 'resources/capec-to-technique.json',
            cweToCapec: 'resources/cwe-to-capec.json'
        };

        const REQUIRED_OFFLINE_RESOURCE_FILES = Object.values(SHARED_DATA_ENDPOINTS).map(path => path.split('/').pop());

        const OFFLINE_RESOURCE_STORE = {
            jsonByFileName: new Map(),
            promptPromise: null
        };

        function isFileProtocolRuntime() {
            return typeof window !== 'undefined' && window.location && window.location.protocol === 'file:';
        }

        function getFileNameFromPath(path) {
            const normalized = String(path || '');
            const parts = normalized.split('/');
            return parts[parts.length - 1] || normalized;
        }

        function cloneJsonData(data) {
            if (typeof structuredClone === 'function') {
                return structuredClone(data);
            }
            return JSON.parse(JSON.stringify(data));
        }

        function readLocalFileText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error('Failed reading local file'));
                reader.readAsText(file);
            });
        }

        async function promptOfflineResourceFiles(requiredFileNames = []) {
            if (OFFLINE_RESOURCE_STORE.promptPromise) {
                await OFFLINE_RESOURCE_STORE.promptPromise;
                return;
            }

            OFFLINE_RESOURCE_STORE.promptPromise = new Promise((resolve, reject) => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,application/json';
                input.multiple = true;
                input.setAttribute('webkitdirectory', '');
                input.setAttribute('directory', '');
                input.style.display = 'none';

                const cleanup = () => {
                    if (input.parentNode) input.parentNode.removeChild(input);
                };

                input.addEventListener('change', async () => {
                    try {
                        const files = Array.from(input.files || []);
                        if (!files.length) {
                            throw new Error('No resource files selected');
                        }

                        const nextMap = new Map(OFFLINE_RESOURCE_STORE.jsonByFileName);
                        for (const file of files) {
                            const name = file.name;
                            if (!name || !name.toLowerCase().endsWith('.json')) continue;
                            const text = await readLocalFileText(file);
                            const parsed = parseJsonSafe(text);
                            nextMap.set(name, parsed);
                        }

                        const missing = requiredFileNames.filter(name => !nextMap.has(name));
                        if (missing.length) {
                            throw new Error(`Missing selected resources: ${missing.join(', ')}`);
                        }

                        OFFLINE_RESOURCE_STORE.jsonByFileName = nextMap;
                        resolve();
                    } catch (err) {
                        reject(err);
                    } finally {
                        cleanup();
                    }
                }, { once: true });

                document.body.appendChild(input);
                showToast('Select your local resources folder (or JSON files) to continue');
                input.click();
            });

            try {
                await OFFLINE_RESOURCE_STORE.promptPromise;
            } finally {
                OFFLINE_RESOURCE_STORE.promptPromise = null;
            }
        }

        async function fetchJsonResource(resourcePath) {
            if (!isFileProtocolRuntime()) {
                const response = await fetch(resourcePath);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${resourcePath}: HTTP ${response.status}`);
                }
                return response.json();
            }

            const fileName = getFileNameFromPath(resourcePath);
            if (!OFFLINE_RESOURCE_STORE.jsonByFileName.has(fileName)) {
                throw new Error(`OFFLINE_RESOURCE_SELECTION_REQUIRED:${fileName}`);
            }

            const localJson = OFFLINE_RESOURCE_STORE.jsonByFileName.get(fileName);
            if (typeof localJson === 'undefined') {
                throw new Error(`Local resource not available: ${fileName}`);
            }

            return cloneJsonData(localJson);
        }

        function enableOfflineResourceSelectionUI(message) {
            const loadingEl = document.getElementById('loading');
            const loadingText = loadingEl ? loadingEl.querySelector('.loading-text') : null;
            const loadingHint = document.getElementById('loading-hint');
            const loadingDismiss = document.getElementById('loading-dismiss');
            const loadingBypass = document.getElementById('loading-bypass');

            if (loadingText) {
                loadingText.textContent = message || 'Offline mode requires local resource files.';
            }
            if (loadingHint) {
                loadingHint.style.display = 'block';
                loadingHint.textContent = 'Click "Select Local Resources" and choose the resources folder (or required JSON files).';
            }
            if (loadingDismiss) {
                loadingDismiss.style.display = 'inline-block';
                loadingDismiss.textContent = 'Select Local Resources';
                loadingDismiss.onclick = async () => {
                    try {
                        loadingDismiss.disabled = true;
                        await promptOfflineResourceFiles(REQUIRED_OFFLINE_RESOURCE_FILES);
                        await loadData();
                    } catch (err) {
                        if (loadingText) {
                            loadingText.textContent = 'Offline resource selection failed: ' + (err && err.message ? err.message : String(err));
                        }
                    } finally {
                        loadingDismiss.disabled = false;
                    }
                };
            }
            if (loadingBypass) {
                loadingBypass.style.display = 'inline-block';
                loadingBypass.textContent = 'I know what I\'m doing';
                loadingBypass.onclick = hideLoadingOverlay;
            }
        }

        function hideLoadingOverlay() {
            const loadingEl = document.getElementById('loading');
            if (loadingEl) loadingEl.classList.add('hidden');
            renderAll();
        }

        function getSharedDataCache() {
            if (!window.AttackFlowSharedData) {
                window.AttackFlowSharedData = {
                    promise: null,
                    data: null,
                    loadedAt: 0
                };
            }
            return window.AttackFlowSharedData;
        }

        function isLocalIframeIPCEnabled() {
            if (!isFileProtocolRuntime()) return false;
            return typeof CONFIG === 'undefined' || CONFIG.ConfigIframeIPC?.enableLocalIframeIPC !== false;
        }

        function updateLoadingContextInfo() {
            const infoEl = document.getElementById('loading-context-info');
            if (!infoEl) return;

            const shouldWarn = isFileProtocolRuntime() && !isLocalIframeIPCEnabled();
            if (!shouldWarn) {
                infoEl.style.display = 'none';
                infoEl.textContent = '';
                return;
            }

            infoEl.style.display = 'block';
            infoEl.textContent = 'Running from file:// with local iframe IPC bridge disabled. Theme sync, Embedded Relationship Explorer and STIX Composer sync features will not work as expected unless ConfigIframeIPC.enableLocalIframeIPC is enabled.';
        }

        function isLocalIframeIPCTraceEnabled() {
            return typeof CONFIG !== 'undefined' && CONFIG.debugging?.traceLocalIframeIPCLogs === true;
        }

        const IPC_PORT_INBOUND_MESSAGE_TYPES = new Set(['AF_REQUEST_THEME', 'AF_REQUEST_SHARED_DATA']);
        const IPC_PORT_INBOUND_MESSAGE_KEYS = {
            AF_REQUEST_THEME: new Set(['type', 'nonce']),
            AF_REQUEST_SHARED_DATA: new Set(['type', 'nonce'])
        };
        const IPC_BOOTSTRAP_MESSAGE_KEYS = new Set(['type', 'channel', 'nonce']);
        const IPC_CHANNEL_BOOTSTRAP_TYPE = 'AF_IPC_PORT_INIT';
        const IPC_SHARED_DATA_KEYS = new Set(['attack', 'capecPatterns', 'cweWeaknesses', 'techniqueToCapec', 'capecToTechnique', 'cweToCapec']);
        const IPC_RATE_LIMIT_DEFAULTS = {
            enabled: true,
            refillPerSecond: 1,
            burst: 2
        };
        const IPC_BOOTSTRAP_DEFAULTS = {
            timeoutMs: 1200,
            maxRetries: 3,
            retryBaseDelayMs: 250,
            retryBackoffMultiplier: 2,
            maxRetryDelayMs: 2000
        };
        const SHARED_DATA_LIMITS = {
            maxTechniqueEntries: 10000,
            maxCapecEntries: 10000,
            maxCweEntries: 10000,
            maxTechniqueToCapecEntries: 20000,
            maxCapecToTechniqueEntries: 20000,
            maxCweToCapecEntries: 20000,
            maxSerializedBytes: 40 * 1024 * 1024
        };

        const IPC_FRAME_CHANNELS = {
            explorer: {
                port: null,
                nonce: '',
                frameSelector: '.explorer-frame',
                rateBuckets: Object.create(null),
                bootstrapTimerId: null,
                bootstrapAttempt: 0,
                bootstrapComplete: false,
                bootstrapExhausted: false
            },
            'stix-builder': {
                port: null,
                nonce: '',
                frameSelector: '.stix-builder-frame',
                rateBuckets: Object.create(null),
                bootstrapTimerId: null,
                bootstrapAttempt: 0,
                bootstrapComplete: false,
                bootstrapExhausted: false
            }
        };

        function logLocalIframeIPCSplash(context) {
            const protocol = (typeof window !== 'undefined' && window.location && window.location.protocol) ? window.location.protocol : 'unknown';
            const configured = typeof CONFIG === 'undefined' ? 'unset' : (CONFIG.ConfigIframeIPC?.enableLocalIframeIPC !== false);
            const active = isLocalIframeIPCEnabled();
            console.info(`[AF IPC][${context}] local iframe IPC status`, {
                protocol,
                configured,
                active,
                trace: isLocalIframeIPCTraceEnabled(),
                messageChannel: typeof MessageChannel === 'function'
            });
        }

        function logLocalIframeIPCTrace(context, message, details) {
            if (!isLocalIframeIPCTraceEnabled()) return;
            if (typeof details === 'undefined') {
                console.log(`[AF IPC][${context}] ${message}`);
                return;
            }
            console.log(`[AF IPC][${context}] ${message}`, details);
        }

        function getLocalIframeIPCRateLimitConfig() {
            const cfg = (typeof CONFIG !== 'undefined' && CONFIG.debugging?.localIframeIPCRateLimit)
                ? CONFIG.debugging.localIframeIPCRateLimit
                : {};
            const enabled = cfg.enabled !== false;
            const refillPerSecond = Number.isFinite(cfg.refillPerSecond) && cfg.refillPerSecond > 0
                ? cfg.refillPerSecond
                : IPC_RATE_LIMIT_DEFAULTS.refillPerSecond;
            const burst = Number.isFinite(cfg.burst) && cfg.burst > 0
                ? cfg.burst
                : IPC_RATE_LIMIT_DEFAULTS.burst;
            return {
                enabled,
                refillPerSecond,
                burst
            };
        }

        function getLocalIframeIPCBootstrapConfig() {
            const cfg = (typeof CONFIG !== 'undefined' && CONFIG.debugging?.localIframeIPCBootstrap)
                ? CONFIG.debugging.localIframeIPCBootstrap
                : {};
            const timeoutMs = Number.isFinite(cfg.timeoutMs) && cfg.timeoutMs >= 200
                ? Math.floor(cfg.timeoutMs)
                : IPC_BOOTSTRAP_DEFAULTS.timeoutMs;
            const maxRetries = Number.isFinite(cfg.maxRetries) && cfg.maxRetries >= 1
                ? Math.floor(cfg.maxRetries)
                : IPC_BOOTSTRAP_DEFAULTS.maxRetries;
            const retryBaseDelayMs = Number.isFinite(cfg.retryBaseDelayMs) && cfg.retryBaseDelayMs >= 0
                ? Math.floor(cfg.retryBaseDelayMs)
                : IPC_BOOTSTRAP_DEFAULTS.retryBaseDelayMs;
            const retryBackoffMultiplier = Number.isFinite(cfg.retryBackoffMultiplier) && cfg.retryBackoffMultiplier >= 1
                ? cfg.retryBackoffMultiplier
                : IPC_BOOTSTRAP_DEFAULTS.retryBackoffMultiplier;
            const maxRetryDelayMs = Number.isFinite(cfg.maxRetryDelayMs) && cfg.maxRetryDelayMs >= retryBaseDelayMs
                ? Math.floor(cfg.maxRetryDelayMs)
                : IPC_BOOTSTRAP_DEFAULTS.maxRetryDelayMs;
            return {
                timeoutMs,
                maxRetries,
                retryBaseDelayMs,
                retryBackoffMultiplier,
                maxRetryDelayMs
            };
        }

        function isIPCRequestRateAllowed(frameKey, messageType, transport) {
            const rateLimit = getLocalIframeIPCRateLimitConfig();
            if (!rateLimit.enabled) return true;

            const frameState = getIPCFrameState(frameKey);
            if (!frameState) {
                logLocalIframeIPCTrace('index', 'rate-limit fallback: unknown frame, allow request', { frameKey, messageType, transport });
                return true;
            }

            if (!frameState.rateBuckets || typeof frameState.rateBuckets !== 'object') {
                frameState.rateBuckets = Object.create(null);
            }

            const now = Date.now();
            const bucketKey = String(messageType || 'unknown');
            let bucket = frameState.rateBuckets[bucketKey];
            if (!bucket) {
                bucket = {
                    tokens: rateLimit.burst,
                    lastRefillMs: now
                };
                frameState.rateBuckets[bucketKey] = bucket;
            }

            const elapsedMs = Math.max(0, now - bucket.lastRefillMs);
            if (elapsedMs > 0) {
                const refillTokens = (elapsedMs / 1000) * rateLimit.refillPerSecond;
                bucket.tokens = Math.min(rateLimit.burst, bucket.tokens + refillTokens);
                bucket.lastRefillMs = now;
            }

            if (bucket.tokens < 1) {
                logLocalIframeIPCTrace('index', 'rate-limit throttle: request blocked', {
                    frameKey,
                    messageType,
                    transport,
                    tokens: bucket.tokens
                });
                return false;
            }

            bucket.tokens -= 1;
            return true;
        }

        function isPlainObject(value) {
            return !!value && typeof value === 'object' && !Array.isArray(value);
        }

        function hasOnlyAllowedKeys(value, allowedKeys, contextLabel) {
            if (!isPlainObject(value)) {
                logLocalIframeIPCTrace('index', `${contextLabel} rejected: payload is not object`);
                return false;
            }
            const keys = Object.keys(value);
            for (const key of keys) {
                if (!allowedKeys.has(key)) {
                    logLocalIframeIPCTrace('index', `${contextLabel} rejected: unknown key`, { key });
                    return false;
                }
            }
            return true;
        }

        function deepFreeze(value) {
            if (!value || typeof value !== 'object' || Object.isFrozen(value)) return value;
            Object.getOwnPropertyNames(value).forEach((name) => {
                const child = value[name];
                if (child && typeof child === 'object') deepFreeze(child);
            });
            return Object.freeze(value);
        }

        function createLocalIPCNonce() {
            const timestampPart = Date.now().toString(36);
            const perfPart = (typeof performance !== 'undefined' && typeof performance.now === 'function')
                ? Math.floor(performance.now() * 1000).toString(36)
                : 'nop';
            const randomPart = (() => {
                try {
                    if (typeof crypto !== 'undefined' && crypto && typeof crypto.getRandomValues === 'function') {
                        const bytes = new Uint8Array(16);
                        crypto.getRandomValues(bytes);
                        return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
                    }
                } catch (e) {
                    // fall through to Math.random fallback
                }
                const samples = [];
                for (let i = 0; i < 6; i++) {
                    samples.push(Math.floor(Math.random() * 0x100000000).toString(36));
                }
                return samples.join('');
            })();
            return `afipc-${timestampPart}-${perfPart}-${randomPart}`;
        }

        function isKnownIPCSourceWindow(sourceWindow) {
            if (!sourceWindow) return false;
            const explorerWin = getExplorerFrameEl()?.contentWindow || null;
            const builderWin = getStixBuilderFrameEl()?.contentWindow || null;
            return sourceWindow === explorerWin || sourceWindow === builderWin;
        }

        function getIPCFrameState(frameKey) {
            return IPC_FRAME_CHANNELS[frameKey] || null;
        }

        function clearIPCFrameBootstrapTimer(frameState) {
            if (!frameState || !frameState.bootstrapTimerId) return;
            clearTimeout(frameState.bootstrapTimerId);
            frameState.bootstrapTimerId = null;
        }

        function clearIPCFrameChannel(frameKey, options = {}) {
            const frameState = getIPCFrameState(frameKey);
            if (!frameState) return;
            clearIPCFrameBootstrapTimer(frameState);
            if (frameState.port) {
                try {
                    frameState.port.onmessage = null;
                    frameState.port.close();
                } catch (e) {
                    // ignore close errors
                }
            }
            frameState.port = null;
            frameState.nonce = '';
            frameState.rateBuckets = Object.create(null);
            frameState.bootstrapComplete = false;
            if (options.resetBootstrapAttempt === true) {
                frameState.bootstrapAttempt = 0;
                frameState.bootstrapExhausted = false;
            }
        }

        function scheduleIPCChannelBootstrapRetry(frameKey, reason) {
            const frameState = getIPCFrameState(frameKey);
            if (!frameState) return false;
            const cfg = getLocalIframeIPCBootstrapConfig();
            const currentAttempt = Number(frameState.bootstrapAttempt || 0);
            if (currentAttempt >= cfg.maxRetries) {
                frameState.bootstrapExhausted = true;
                logLocalIframeIPCTrace('index', 'channel bootstrap retries exhausted', {
                    frameKey,
                    attempts: currentAttempt,
                    reason
                });
                return false;
            }

            const nextAttempt = currentAttempt + 1;
            const exponent = Math.max(0, nextAttempt - 2);
            const computedDelay = cfg.retryBaseDelayMs * Math.pow(cfg.retryBackoffMultiplier, exponent);
            const retryDelayMs = Math.min(cfg.maxRetryDelayMs, computedDelay);

            logLocalIframeIPCTrace('index', 'channel bootstrap retry scheduled', {
                frameKey,
                nextAttempt,
                retryDelayMs,
                reason
            });

            window.setTimeout(() => {
                const latestFrameState = getIPCFrameState(frameKey);
                if (!latestFrameState || latestFrameState.bootstrapExhausted || latestFrameState.bootstrapComplete) return;
                setupIPCChannelForFrame(frameKey, { attempt: nextAttempt, reason: 'retry' });
            }, retryDelayMs);
            return true;
        }

        function sendIPCMessageViaChannel(frameKey, message) {
            const frameState = getIPCFrameState(frameKey);
            if (!frameState || !frameState.port || !frameState.nonce) return false;
            try {
                frameState.port.postMessage({ ...message, nonce: frameState.nonce });
                logLocalIframeIPCTrace('index', 'channel message sent', { frameKey, type: message?.type || null });
                return true;
            } catch (e) {
                logLocalIframeIPCTrace('index', 'channel message send failed', { frameKey, type: message?.type || null, error: String(e && e.message ? e.message : e) });
                return false;
            }
        }

        function setupIPCChannelForFrame(frameKey, options = {}) {
            if (!isLocalIframeIPCEnabled() || typeof MessageChannel !== 'function') return false;
            const frameState = getIPCFrameState(frameKey);
            if (!frameState) return false;
            const cfg = getLocalIframeIPCBootstrapConfig();
            const requestedAttempt = Number.isFinite(options.attempt) && options.attempt > 0
                ? Math.floor(options.attempt)
                : 1;

            if (requestedAttempt === 1) {
                frameState.bootstrapExhausted = false;
            }
            if (frameState.bootstrapExhausted) {
                logLocalIframeIPCTrace('index', 'channel setup skipped: retries already exhausted', { frameKey });
                return false;
            }

            const frameEl = document.querySelector(frameState.frameSelector);
            const frameWindow = frameEl?.contentWindow;
            if (!frameWindow) {
                logLocalIframeIPCTrace('index', 'channel setup skipped: frame unavailable', { frameKey });
                frameState.bootstrapAttempt = requestedAttempt;
                scheduleIPCChannelBootstrapRetry(frameKey, 'frame-unavailable');
                return false;
            }

            clearIPCFrameChannel(frameKey);
            const channel = new MessageChannel();
            const nonce = createLocalIPCNonce();

            frameState.bootstrapAttempt = requestedAttempt;
            frameState.bootstrapComplete = false;
            frameState.port = channel.port1;
            frameState.nonce = nonce;
            frameState.port.onmessage = (event) => {
                const message = event.data;
                if (!message || typeof message !== 'object') return;

                if (!frameState.bootstrapComplete) {
                    frameState.bootstrapComplete = true;
                    frameState.bootstrapExhausted = false;
                    clearIPCFrameBootstrapTimer(frameState);
                    logLocalIframeIPCTrace('index', 'channel bootstrap established', {
                        frameKey,
                        attempt: frameState.bootstrapAttempt
                    });
                }

                if (!IPC_PORT_INBOUND_MESSAGE_TYPES.has(message.type)) {
                    logLocalIframeIPCTrace('index', 'channel message rejected: unknown type', { frameKey, type: message.type || null });
                    return;
                }

                const allowedKeys = IPC_PORT_INBOUND_MESSAGE_KEYS[message.type];
                if (!hasOnlyAllowedKeys(message, allowedKeys, `Channel ${message.type}`)) {
                    return;
                }

                if (message.nonce !== frameState.nonce) {
                    logLocalIframeIPCTrace('index', 'channel message rejected: nonce mismatch', { frameKey, type: message.type || null });
                    return;
                }

                if (!isIPCRequestRateAllowed(frameKey, message.type, 'channel')) {
                    return;
                }

                if (message.type === 'AF_REQUEST_THEME') {
                    sendIPCMessageViaChannel(frameKey, {
                        type: 'AF_THEME_SYNC',
                        mode: currentTheme?.mode || 'light',
                        scheme: currentTheme?.scheme || 'default'
                    });
                    return;
                }

                if (message.type === 'AF_REQUEST_SHARED_DATA') {
                    if (frameKey !== 'explorer') {
                        logLocalIframeIPCTrace('index', 'channel shared-data request rejected: frame not allowed', { frameKey });
                        return;
                    }
                    const cache = getSharedDataCache();
                    const immutablePayload = cache.data ? buildImmutableSharedDataPayload(cache.data) : null;
                    if (!immutablePayload) {
                        logLocalIframeIPCTrace('index', 'channel shared-data response skipped: payload unavailable');
                        return;
                    }
                    sendIPCMessageViaChannel(frameKey, {
                        type: 'AF_SHARED_DATA',
                        data: immutablePayload
                    });
                }
            };
            frameState.port.start();

            try {
                frameWindow.postMessage({
                    type: IPC_CHANNEL_BOOTSTRAP_TYPE,
                    channel: frameKey,
                    nonce
                }, '*', [channel.port2]);
                logLocalIframeIPCTrace('index', 'channel bootstrap sent', { frameKey, attempt: requestedAttempt });

                clearIPCFrameBootstrapTimer(frameState);
                frameState.bootstrapTimerId = window.setTimeout(() => {
                    const latestFrameState = getIPCFrameState(frameKey);
                    if (!latestFrameState) return;
                    if (latestFrameState.nonce !== nonce || latestFrameState.bootstrapComplete) return;

                    logLocalIframeIPCTrace('index', 'channel bootstrap timeout', {
                        frameKey,
                        attempt: requestedAttempt,
                        timeoutMs: cfg.timeoutMs
                    });
                    clearIPCFrameChannel(frameKey);
                    scheduleIPCChannelBootstrapRetry(frameKey, 'timeout');
                }, cfg.timeoutMs);
                return true;
            } catch (e) {
                logLocalIframeIPCTrace('index', 'channel bootstrap failed', { frameKey, error: String(e && e.message ? e.message : e) });
                clearIPCFrameChannel(frameKey);
                scheduleIPCChannelBootstrapRetry(frameKey, 'postMessage-error');
                return false;
            }
        }

        function buildImmutableSharedDataPayload(rawData) {
            if (!isPlainObject(rawData)) {
                logLocalIframeIPCTrace('index', 'AF_SHARED_DATA rejected: shared cache is not object');
                return null;
            }
            if (!hasOnlyAllowedKeys(rawData, IPC_SHARED_DATA_KEYS, 'AF_SHARED_DATA')) {
                return null;
            }
            for (const key of IPC_SHARED_DATA_KEYS) {
                const value = rawData[key];
                if (!isPlainObject(value)) {
                    logLocalIframeIPCTrace('index', 'AF_SHARED_DATA rejected: invalid data bucket', { key });
                    return null;
                }
            }
            if (!enforceSharedDatasetLimits(rawData)) {
                logLocalIframeIPCTrace('index', 'AF_SHARED_DATA rejected: shared cache exceeds configured limits');
                return null;
            }
            const cloned = cloneJsonData(rawData);
            return deepFreeze(cloned);
        }

        function validateSharedDatasetShape(rawData) {
            if (!isPlainObject(rawData)) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: payload is not object');
                return false;
            }
            if (!hasOnlyAllowedKeys(rawData, IPC_SHARED_DATA_KEYS, 'Shared loader dataset')) {
                return false;
            }
            for (const key of IPC_SHARED_DATA_KEYS) {
                if (!isPlainObject(rawData[key])) {
                    logLocalIframeIPCTrace('index', 'shared loader dataset rejected: invalid top-level bucket', { key });
                    return false;
                }
            }
            return true;
        }

        function estimateJsonByteSize(value) {
            let jsonText = '';
            try {
                jsonText = JSON.stringify(value);
            } catch (e) {
                return Number.POSITIVE_INFINITY;
            }
            if (typeof jsonText !== 'string') return Number.POSITIVE_INFINITY;
            if (typeof TextEncoder === 'function') {
                return new TextEncoder().encode(jsonText).length;
            }
            return jsonText.length * 2;
        }

        function enforceSharedDatasetLimits(rawData) {
            const counts = {
                attack: Object.keys(rawData.attack || {}).length,
                capecPatterns: Object.keys(rawData.capecPatterns || {}).length,
                cweWeaknesses: Object.keys(rawData.cweWeaknesses || {}).length,
                techniqueToCapec: Object.keys(rawData.techniqueToCapec || {}).length,
                capecToTechnique: Object.keys(rawData.capecToTechnique || {}).length,
                cweToCapec: Object.keys(rawData.cweToCapec || {}).length
            };

            if (counts.attack > SHARED_DATA_LIMITS.maxTechniqueEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: attack entry limit exceeded', { count: counts.attack, limit: SHARED_DATA_LIMITS.maxTechniqueEntries });
                return false;
            }
            if (counts.capecPatterns > SHARED_DATA_LIMITS.maxCapecEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: CAPEC entry limit exceeded', { count: counts.capecPatterns, limit: SHARED_DATA_LIMITS.maxCapecEntries });
                return false;
            }
            if (counts.cweWeaknesses > SHARED_DATA_LIMITS.maxCweEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: CWE entry limit exceeded', { count: counts.cweWeaknesses, limit: SHARED_DATA_LIMITS.maxCweEntries });
                return false;
            }
            if (counts.techniqueToCapec > SHARED_DATA_LIMITS.maxTechniqueToCapecEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: techniqueToCapec entry limit exceeded', { count: counts.techniqueToCapec, limit: SHARED_DATA_LIMITS.maxTechniqueToCapecEntries });
                return false;
            }
            if (counts.capecToTechnique > SHARED_DATA_LIMITS.maxCapecToTechniqueEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: capecToTechnique entry limit exceeded', { count: counts.capecToTechnique, limit: SHARED_DATA_LIMITS.maxCapecToTechniqueEntries });
                return false;
            }
            if (counts.cweToCapec > SHARED_DATA_LIMITS.maxCweToCapecEntries) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: cweToCapec entry limit exceeded', { count: counts.cweToCapec, limit: SHARED_DATA_LIMITS.maxCweToCapecEntries });
                return false;
            }

            const estimatedBytes = estimateJsonByteSize(rawData);
            if (!Number.isFinite(estimatedBytes) || estimatedBytes > SHARED_DATA_LIMITS.maxSerializedBytes) {
                logLocalIframeIPCTrace('index', 'shared loader dataset rejected: serialized size limit exceeded', { estimatedBytes, limit: SHARED_DATA_LIMITS.maxSerializedBytes });
                return false;
            }

            return true;
        }

        function getExplorerFrameEl() {
            return document.querySelector('.explorer-frame');
        }

        function getStixBuilderFrameEl() {
            return document.querySelector('.stix-builder-frame');
        }

        function broadcastSharedDataToExplorer() {
            if (!isLocalIframeIPCEnabled()) {
                logLocalIframeIPCTrace('index', 'shared-data broadcast blocked: IPC disabled');
                return;
            }
            const cache = getSharedDataCache();
            if (!cache.data) {
                logLocalIframeIPCTrace('index', 'shared-data broadcast skipped: cache empty');
                return;
            }
            const immutablePayload = buildImmutableSharedDataPayload(cache.data);
            if (!immutablePayload) {
                logLocalIframeIPCTrace('index', 'shared-data broadcast skipped: payload validation failed');
                return;
            }
            if (sendIPCMessageViaChannel('explorer', {
                type: 'AF_SHARED_DATA',
                data: immutablePayload
            })) {
                logLocalIframeIPCTrace('index', 'shared-data broadcast sent via channel');
                return;
            }
            logLocalIframeIPCTrace('index', 'shared-data broadcast skipped: channel unavailable');
        }

        function broadcastThemeToEmbeddedViews() {
            if (!isLocalIframeIPCEnabled()) {
                logLocalIframeIPCTrace('index', 'theme broadcast blocked: IPC disabled');
                return;
            }
            const payload = {
                type: 'AF_THEME_SYNC',
                mode: currentTheme?.mode || 'light',
                scheme: currentTheme?.scheme || 'default'
            };
            const explorerSent = sendIPCMessageViaChannel('explorer', payload);
            const builderSent = sendIPCMessageViaChannel('stix-builder', payload);
            logLocalIframeIPCTrace('index', 'theme broadcast attempted via channel', {
                mode: payload.mode,
                scheme: payload.scheme,
                explorerSent,
                builderSent
            });
        }

        function initEmbeddedMessageBridge() {
            if (!isLocalIframeIPCEnabled()) {
                logLocalIframeIPCTrace('index', 'bridge init skipped: IPC disabled');
                return;
            }
            logLocalIframeIPCTrace('index', 'bridge initialized');

            window.addEventListener('message', (event) => {
                const message = event.data;
                if (!message || typeof message !== 'object') return;
                if (!isKnownIPCSourceWindow(event.source)) {
                    logLocalIframeIPCTrace('index', 'message rejected: unknown source window');
                    return;
                }
                if (message.type !== IPC_CHANNEL_BOOTSTRAP_TYPE) {
                    logLocalIframeIPCTrace('index', 'window message rejected: channel-only mode', { type: message.type || null });
                }
            });

            const explorerFrame = getExplorerFrameEl();
            if (explorerFrame) {
                explorerFrame.addEventListener('load', () => {
                    logLocalIframeIPCTrace('index', 'explorer iframe load detected');
                    setupIPCChannelForFrame('explorer');
                    broadcastThemeToEmbeddedViews();
                    broadcastSharedDataToExplorer();
                });
            }

            const builderFrame = getStixBuilderFrameEl();
            if (builderFrame) {
                builderFrame.addEventListener('load', () => {
                    logLocalIframeIPCTrace('index', 'stix-builder iframe load detected');
                    setupIPCChannelForFrame('stix-builder');
                    broadcastThemeToEmbeddedViews();
                });
            }
        }

        async function loadSharedLibraryData(forceReload = false) {
            const cache = getSharedDataCache();

            if (!forceReload && cache.data) {
                return cache.data;
            }

            if (!forceReload && cache.promise) {
                return cache.promise;
            }

            cache.promise = (async () => {
                const [attackJson, capecJson, cweJson, t2cJson, c2tJson, c2cJson] = await Promise.all([
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.attack),
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.capec),
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.cwe),
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.techniqueToCapec),
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.capecToTechnique),
                    fetchJsonResource(SHARED_DATA_ENDPOINTS.cweToCapec)
                ]);

                const attack = stripAngleBracketsFromJson(attackJson);
                const capec = stripAngleBracketsFromJson(capecJson);
                const cwe = stripAngleBracketsFromJson(cweJson);
                const techniqueToCapec = stripAngleBracketsFromJson(t2cJson);
                const capecToTechnique = stripAngleBracketsFromJson(c2tJson);
                const cweToCapec = stripAngleBracketsFromJson(c2cJson);

                const data = {
                    attack,
                    capecPatterns: capec.patterns || {},
                    cweWeaknesses: cwe.weaknesses || {},
                    techniqueToCapec,
                    capecToTechnique,
                    cweToCapec
                };

                if (!validateSharedDatasetShape(data)) {
                    throw new Error('Shared dataset validation failed');
                }
                if (!enforceSharedDatasetLimits(data)) {
                    throw new Error('Shared dataset limit enforcement failed');
                }

                cache.data = data;
                cache.loadedAt = Date.now();
                broadcastSharedDataToExplorer();
                return data;
            })().catch(err => {
                cache.promise = null;
                throw err;
            });

            const result = await cache.promise;
            cache.promise = null;
            return result;
        }

        window.getAttackFlowSharedData = function (options) {
            const forceReload = !!(options && options.forceReload);
            return loadSharedLibraryData(forceReload).then((data) => {
                const immutableSnapshot = buildImmutableSharedDataPayload(data);
                if (!immutableSnapshot) {
                    throw new Error('Shared dataset snapshot build failed');
                }
                return immutableSnapshot;
            });
        };

        async function loadData() {
            try {
                const shared = await loadSharedLibraryData();

                state.library.techniques = { ...shared.attack };
                state.library.capecs = { ...shared.capecPatterns };
                state.library.cwes = { ...shared.cweWeaknesses };
                state.techniqueToCapec = shared.techniqueToCapec;
                state.capecToTechnique = shared.capecToTechnique;
                state.cweToCapec = shared.cweToCapec;
                
                console.log(`Loaded: ${Object.keys(state.library.techniques).length} techniques, ${Object.keys(state.library.capecs).length} CAPECs, ${Object.keys(state.library.cwes).length} CWEs`);
                
                // Preserve full technique library for Navigator import enrichment
                state._baseTechniques = { ...state.library.techniques };

                broadcastSharedDataToExplorer();
                
                document.getElementById('loading').classList.add('hidden');
                renderAll();
            } catch (err) {
                console.error('Failed to load data:', err);
                if (isFileProtocolRuntime() && String(err && err.message || '').startsWith('OFFLINE_RESOURCE_SELECTION_REQUIRED:')) {
                    enableOfflineResourceSelectionUI('Offline mode requires local resource selection.');
                    return;
                }
                // KCE-SEC-009: Use textContent instead of innerHTML for error messages
                const loadingEl = document.getElementById('loading');
                const loadingText = loadingEl.querySelector('.loading-text');
                loadingText.textContent = 'Error loading data: ' + err.message;
                // Show dismiss button and hint so user can still use the app
                const loadingDismiss = document.getElementById('loading-dismiss');
                const loadingBypass = document.getElementById('loading-bypass');
                const loadingHint = document.getElementById('loading-hint');
                if (loadingDismiss) {
                    loadingDismiss.style.display = 'inline-block';
                    loadingDismiss.textContent = 'Continue Without Data';
                    loadingDismiss.onclick = hideLoadingOverlay;
                }
                if (loadingBypass) {
                    loadingBypass.style.display = 'none';
                }
                if (loadingHint) {
                    loadingHint.style.display = 'block';
                }
            }
        }

        // Load Navigator layer (replaces technique library; preserves mappings & CAPEC/CWE)
        async function loadNavigator(domain) {
            try {
                const layerJson = await fetchJsonResource(`resources/Nav_Layer_${domain.toUpperCase()}.json`);
                const layer = stripAngleBracketsFromJson(layerJson);
                
                // Replace technique library (mappings & CAPEC/CWE stay intact)
                // Enrich from base library when available for full metadata
                const base = state._baseTechniques || {};
                const newTechniques = {};
                let count = 0;
                for (const tech of layer.techniques || []) {
                    if (tech.enabled === false) continue;
                    const id = tech.techniqueID;
                    if (!id) continue;
                    newTechniques[id] = base[id] || {
                        id,
                        name: `Technique ${id}`,
                        domain: detectDomain(id)
                    };
                    count++;
                }
                state.library.techniques = newTechniques;
                
                showToast(`Loaded ${count} techniques (library replaced)`);
                filterEntities('attack');
            } catch (err) {
                showToast('Error: ' + err.message);
            }
        }

        // KCE-SEC-003: Navigator import validation constants
        const IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024 * 5,  // 25MB
            maxTechniques: 5000,
            maxStringLength: 500,
            techniqueIdPattern: /^T\d{4}(\.\d{3})?$/  // T1234 or T1234.001
        };

        async function ensureBaseTechniquesLoaded() {
            if (state._baseTechniques && Object.keys(state._baseTechniques).length > 0) {
                return state._baseTechniques;
            }
            const shared = await loadSharedLibraryData();
            state._baseTechniques = { ...shared.attack };
            return state._baseTechniques;
        }

        function parseTechniqueIdInput(raw) {
            const normalized = normalizeUserInput(raw || '', 20000, true).toUpperCase();
            const tokens = normalized.split(/[\s,]+/).map(t => t.trim()).filter(Boolean);
            const unique = [...new Set(tokens)];
            const valid = [];
            const invalid = [];
            unique.forEach(id => {
                if (IMPORT_LIMITS.techniqueIdPattern.test(id)) {
                    valid.push(id);
                } else {
                    invalid.push(id);
                }
            });
            return { valid, invalid };
        }

        async function applyTechniqueList(ids) {
            const base = await ensureBaseTechniquesLoaded();
            const newTechniques = {};
            let missing = 0;
            ids.forEach(id => {
                const entry = base[id];
                if (entry) {
                    newTechniques[id] = entry;
                } else {
                    newTechniques[id] = { id, name: `Technique ${id}`, domain: detectDomain(id) };
                    missing += 1;
                }
            });
            state.library.techniques = newTechniques;
            return { missing };
        }

        function openCsvImportModal() {
            const textArea = document.getElementById('csv-import-textarea');
            const errorEl = document.getElementById('csv-import-error');
            if (textArea) textArea.value = '';
            if (errorEl) errorEl.textContent = '';
            document.getElementById('csv-import-modal').classList.add('visible');
        }

        function closeCsvImportModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('csv-import-modal').classList.remove('visible');
        }

        async function submitCsvImport() {
            const textArea = document.getElementById('csv-import-textarea');
            const errorEl = document.getElementById('csv-import-error');
            if (errorEl) errorEl.textContent = '';
            const raw = textArea ? textArea.value : '';
            const { valid, invalid } = parseTechniqueIdInput(raw);
            if (valid.length === 0) {
                if (errorEl) errorEl.textContent = 'No valid technique IDs found.';
                return;
            }
            try {
                const { missing } = await applyTechniqueList(valid);
                let msg = `Loaded ${valid.length} techniques (library replaced)`;
                if (invalid.length > 0) msg += `, ${invalid.length} invalid skipped`;
                if (missing > 0) msg += `, ${missing} missing in base library`;
                showToast(msg);
                filterEntities('attack');
                closeCsvImportModal();
            } catch (err) {
                if (errorEl) errorEl.textContent = `Import failed: ${err.message}`;
            }
        }

        async function resetAttackTechniques() {
            try {
                const shared = await loadSharedLibraryData(true);
                state._baseTechniques = { ...shared.attack };
                state.library.techniques = { ...shared.attack };
                showToast('ATT&CK techniques reset');
                filterEntities('attack');
            } catch (err) {
                showToast('Reset failed: ' + err.message);
            }
        }

        function importNavigator(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // KCE-SEC-003: Validate file size
            if (file.size > IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max 25MB)`);
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layer = stripAngleBracketsFromJson(parseJsonSafe(e.target.result));
                    
                    // KCE-SEC-003: Validate it's an object (basic schema check)
                    if (typeof layer !== 'object' || layer === null || Array.isArray(layer)) {
                        throw new Error('Invalid layer format: expected object');
                    }
                    
                    // KCE-SEC-003: Validate techniques array exists and has reasonable size
                    const techniques = layer.techniques;
                    if (!Array.isArray(techniques)) {
                        throw new Error('Invalid layer format: techniques array required');
                    }
                    
                    if (techniques.length > IMPORT_LIMITS.maxTechniques) {
                        throw new Error(`Too many techniques: ${techniques.length} (max ${IMPORT_LIMITS.maxTechniques})`);
                    }
                    
                    let count = 0, skipped = 0;
                    
                    // Replace technique library (mappings & CAPEC/CWE stay intact)
                    // Enrich from base library when available for full metadata
                    const base = state._baseTechniques || {};
                    const newTechniques = {};
                    
                    for (const tech of techniques) {
                        if (tech.enabled === false) continue;
                        
                        // KCE-SEC-003: Validate technique ID format
                        const id = tech.techniqueID;
                        if (!id || typeof id !== 'string') {
                            skipped++;
                            continue;
                        }
                        
                        // Validate ID matches expected pattern (T1234 or T1234.001)
                        if (!IMPORT_LIMITS.techniqueIdPattern.test(id)) {
                            skipped++;
                            continue;
                        }
                        
                        newTechniques[id] = base[id] || {
                            id,
                            name: `Technique ${id}`,
                            domain: detectDomain(id)
                        };
                        count++;
                    }
                    
                    state.library.techniques = newTechniques;
                    
                    let msg = `Loaded ${count} techniques (library replaced)`;
                    if (skipped > 0) msg += `, ${skipped} skipped (invalid ID)`;
                    showToast(msg);
                    filterEntities('attack');
                } catch (err) {
                    showToast('Invalid JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';  // Reset input
        }

        // Domain detection
        function detectDomain(techId) {
            if (techId.startsWith('T0')) return 'ics';
            const num = parseInt(techId.replace(/^T/, '').split('.')[0], 10);
            if (num >= 1398 && num <= 1665) return 'mobile';
            return 'enterprise';
        }

        // Technique name lookup
        function getTechniqueName(techId) {
            // Check active library, then base library
            if (state.library.techniques[techId]) {
                return state.library.techniques[techId].name;
            }
            if (state._baseTechniques?.[techId]) {
                return state._baseTechniques[techId].name;
            }
            return `Technique ${techId}`;
        }

        // ============================================================
        // VIEW & LAYER CONTROLS
        // ============================================================
        const THEME_STORAGE_KEYS = {
            mode: 'af-theme-mode'
        };
        const COMPACT_STORAGE_KEY = 'af-compact-mode';
        let currentTheme = {
            mode: CONFIG?.themeDefaults?.mode || 'light',
            scheme: 'default'
        };

        function getPreferredThemeMode() {
            const configured = CONFIG?.themeMode || CONFIG?.themeDefaults?.mode || 'light';
            if (configured !== 'auto') return configured;
            if (typeof window === 'undefined') return CONFIG?.themeDefaults?.mode || 'light';
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        function normalizeThemeMode(mode) {
            return mode === 'light' || mode === 'dark' ? mode : (CONFIG?.themeDefaults?.mode || 'light');
        }

        function normalizeThemeScheme(mode, scheme) {
            const schemes = CONFIG?.themes?.[mode] || {};
            if (scheme && schemes[scheme]) return scheme;
            if (schemes.default) return 'default';
            const first = Object.keys(schemes)[0];
            return first || 'default';
        }

        function applyTheme(mode, scheme, persist = true) {
            const resolvedMode = normalizeThemeMode(mode);
            const resolvedScheme = normalizeThemeScheme(resolvedMode, scheme);
            const theme = typeof resolveTheme === 'function'
                ? resolveTheme(resolvedMode, resolvedScheme)
                : null;
            if (typeof applyConfigColors === 'function') {
                applyConfigColors(theme || undefined);
            }
            document.documentElement.dataset.theme = resolvedMode;
            currentTheme = { mode: resolvedMode, scheme: resolvedScheme };
            updateThemeControls();
            broadcastThemeToEmbeddedViews();
            if (persist) {
                try {
                    localStorage.setItem(THEME_STORAGE_KEYS.mode, resolvedMode);
                } catch (e) {
                    console.warn('Theme preference could not be saved:', e);
                }
            }
        }

        function updateThemeControls() {
            const modeBtn = document.getElementById('theme-mode-toggle');
            if (modeBtn) {
                modeBtn.setAttribute('data-mode', currentTheme.mode);
                modeBtn.setAttribute('aria-label', currentTheme.mode === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
                modeBtn.setAttribute('title', currentTheme.mode === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
            }
        }

        function toggleThemeMode() {
            const nextMode = currentTheme.mode === 'dark' ? 'light' : 'dark';
            const nextScheme = normalizeThemeScheme(nextMode, currentTheme.scheme);
            applyTheme(nextMode, nextScheme);
        }

        function initThemeControls() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                console.warn('Theme preference could not be read:', e);
            }

            const mode = normalizeThemeMode(storedMode || getPreferredThemeMode());
            applyTheme(mode, 'default', false);
        }

        function syncThemeFromStorage() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                return;
            }

            const mode = normalizeThemeMode(storedMode || currentTheme.mode);
            if (mode !== currentTheme.mode) {
                applyTheme(mode, 'default', false);
            }
        }

        function isStixBuilderEnabled() {
            return typeof CONFIG === 'undefined' || CONFIG.navigation?.showStixBuilder !== false;
        }

        function setView(view) {
            if (view === 'stix-builder' && !isStixBuilderEnabled()) {
                view = 'killchain';
            }
            state.view = view;
            const isExplorer = view === 'explorer';
            const isRelationship = view === 'relationship';
            const isStixBuilder = view === 'stix-builder';
            document.getElementById('view-killchain').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-relationship').classList.toggle('active', isRelationship);
            document.getElementById('view-explorer').classList.toggle('active', isExplorer);
            document.getElementById('view-builder').classList.toggle('active', isStixBuilder);
            document.getElementById('view-editor-group').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-explorer-group').classList.toggle('active', isExplorer);
            document.getElementById('view-builder-group').classList.toggle('active', isStixBuilder);
            document.getElementById('kill-chain-container').classList.toggle('hidden', isExplorer || isRelationship || isStixBuilder);
            document.getElementById('relationship-container').classList.toggle('visible', isRelationship);
            document.getElementById('content-title').textContent = isRelationship
                ? 'Kill Chain Relationships'
                : (isStixBuilder ? 'STIX Composer' : 'Unified Kill Chain');
            const showViewControls = (!isExplorer && !isRelationship && !isStixBuilder);
            const viewControlVisibility = showViewControls ? 'visible' : 'hidden';
            const viewControlPointer = showViewControls ? '' : 'none';
            const hideEmptyBtn = document.getElementById('btn-hide-empty');
            const compactBtn = document.getElementById('btn-compact');
            const commentsBtn = document.getElementById('btn-comments');
            if (hideEmptyBtn) {
                hideEmptyBtn.style.visibility = viewControlVisibility;
                hideEmptyBtn.style.pointerEvents = viewControlPointer;
            }
            if (compactBtn) {
                compactBtn.style.visibility = viewControlVisibility;
                compactBtn.style.pointerEvents = viewControlPointer;
            }
            if (commentsBtn) {
                const showComments = showViewControls && !state.compactMode;
                commentsBtn.style.visibility = showComments ? 'visible' : 'hidden';
                commentsBtn.style.pointerEvents = showComments ? '' : 'none';
            }
            document.getElementById('stats-bar').style.display = (isExplorer || isStixBuilder) ? 'none' : 'flex';
            document.getElementById('legend-row').style.display = (isExplorer || isStixBuilder) ? 'none' : 'flex';
            const app = document.querySelector('.app');
            if (app) {
                app.classList.toggle('explorer-view', isExplorer);
                app.classList.toggle('stix-builder-view', isStixBuilder);
            }
            if (isRelationship) {
                renderRelationshipView();
            }
            updateHideEmptyControl();
            updateCompactControls();
            applyCompactLayout();
        }

        function applyNavigationConfig() {
            const showStixBuilder = isStixBuilderEnabled();
            const builderGroup = document.getElementById('view-builder-group');
            const builderContainer = document.getElementById('stix-builder-container');
            const builderFrame = document.querySelector('.stix-builder-frame');

            if (builderGroup) {
                builderGroup.style.display = showStixBuilder ? '' : 'none';
            }
            if (builderContainer) {
                builderContainer.style.display = showStixBuilder ? '' : 'none';
            }
            if (builderFrame) {
                if (showStixBuilder && !builderFrame.getAttribute('src')) {
                    builderFrame.setAttribute('src', 'stix-builder.html');
                }
                if (!showStixBuilder) {
                    builderFrame.setAttribute('src', '');
                }
            }
            if (!showStixBuilder && state.view === 'stix-builder') {
                setView('killchain');
            }
        }

        function toggleSidebar() {
            const app = document.querySelector('.app');
            if (!app) return;
            app.classList.toggle('sidebar-collapsed');
            applyCompactLayout();
        }

        function toggleLayer(layer) {
            state.layers[layer] = document.getElementById(`layer-${layer}`).checked;
            renderKillChain();
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function updateHideEmptyControl() {
            const btn = document.getElementById('btn-hide-empty');
            if (!btn) return;
            btn.classList.toggle('active', state.hideEmpty);
            btn.disabled = state.compactMode;
        }

        function updateCompactControls() {
            const btn = document.getElementById('btn-compact');
            if (!btn) return;
            btn.classList.toggle('active', state.compactMode);
            btn.textContent = state.compactMode ? 'Compact On' : 'Compact';
        }

        function setCompactMode(enabled, persist = true) {
            state.compactMode = !!enabled;
            const app = document.querySelector('.app');
            if (app) {
                app.classList.toggle('compact-mode', state.compactMode);
                app.classList.remove('compact-scroll');
            }

            if (state.compactMode) {
                state.hideEmpty = true;
            } else {
                state.hideEmpty = false;
            }

            updateHideEmptyControl();
            updateCompactControls();
            updateCommentsControls();

            if (persist) {
                try {
                    localStorage.setItem(COMPACT_STORAGE_KEY, state.compactMode ? 'true' : 'false');
                } catch (e) {
                    console.warn('Compact mode preference could not be saved:', e);
                }
            }

            renderKillChain();
        }

        function toggleCompactMode() {
            setCompactMode(!state.compactMode);
        }

        function updateCommentsControls() {
            const btn = document.getElementById('btn-comments');
            if (!btn) return;
            btn.classList.toggle('active', state.showComments);
            btn.style.display = (!state.compactMode && state.view === 'killchain') ? 'inline-block' : 'none';
        }

        function toggleItemComment(el) {
            el.classList.toggle('expanded');
            const area = el.nextElementSibling;
            if (area) area.classList.toggle('open');
        }

        function toggleAllComments() {
            state.showComments = !state.showComments;
            const btn = document.getElementById('btn-comments');
            if (btn) btn.classList.toggle('active', state.showComments);

            document.querySelectorAll('.tag-comment-toggle').forEach(el => {
                el.classList.toggle('expanded', state.showComments);
            });
            document.querySelectorAll('.tag-comment-area').forEach(el => {
                el.classList.toggle('open', state.showComments);
            });
        }

        function initCompactMode() {
            let stored = null;
            try {
                stored = localStorage.getItem(COMPACT_STORAGE_KEY);
            } catch (e) {
                console.warn('Compact mode preference could not be read:', e);
            }
            const enabled = stored === 'true';
            state.compactMode = enabled;
            const app = document.querySelector('.app');
            if (app) {
                app.classList.toggle('compact-mode', state.compactMode);
            }
            state.hideEmpty = state.compactMode ? true : false;
            updateHideEmptyControl();
            updateCompactControls();
        }

        function applyCompactLayout() {
            const container = document.getElementById('kill-chain-container');
            if (!container) return;
            const app = document.querySelector('.app');
            if (!state.compactMode || state.view !== 'killchain') {
                if (app) app.classList.remove('compact-scroll');
                container.style.removeProperty('overflow');
                return;
            }
            const killChain = document.getElementById('kill-chain');
            if (!killChain) return;
            const allowScroll = killChain.scrollHeight > container.clientHeight + 4;
            if (app) app.classList.toggle('compact-scroll', allowScroll);
        }

        function toggleHideEmpty() {
            if (state.compactMode) {
                showToast('Disable compact mode to change Hide Empty');
                return;
            }
            state.hideEmpty = !state.hideEmpty;
            updateHideEmptyControl();
            renderKillChain();
        }

        function openMitigationExplorer(mitigationId) {
            if (!mitigationId) return;

            // Validate mitigationId to ensure it matches the expected ID format
            const mitigationIdPattern = /^[A-Za-z0-9_-]+$/;
            if (!mitigationIdPattern.test(mitigationId)) {
                console.error('Invalid mitigationId provided to openMitigationExplorer:', mitigationId);
                return;
            }
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?mitigation=${encodeURIComponent(mitigationId)}`;
            }
            setView('explorer');
        }

        function openEntityExplorer(type, id) {
            if (!type || !id) return;
            const allowed = new Set(['attack', 'capec', 'cwe']);
            if (!allowed.has(type)) return;
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?entity=${encodeURIComponent(`${type}:${id}`)}`;
            }
            setView('explorer');
        }

        // ============================================================
        // TAB & FILTER CONTROLS
        // ============================================================
        function switchTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.sidebar-tab.${tab}`).classList.add('active');
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function setFilter(type, filter) {
            state.filters[type] = filter;
            document.querySelectorAll(`#filter-${type} .filter-btn`).forEach(b => {
                b.classList.toggle('active', b.dataset.filter === filter);
            });
            filterEntities(type);
        }

        function setGlobalSearch(value) {
            state.globalSearch = value || '';
            filterEntities('attack');
            filterEntities('capec');
            filterEntities('cwe');
            renderGlobalSearchResults();
            if (state.globalSearch.trim()) {
                openGlobalSearch();
            }
        }

        function openGlobalSearch() {
            state.globalSearchOpen = true;
            updateGlobalSearchUI();
            renderGlobalSearchResults();
        }

        function closeGlobalSearch(force = false) {
            if (state.globalSearchSticky && !force) {
                return;
            }
            state.globalSearchOpen = false;
            state.globalSearchExpanded = false;
            updateGlobalSearchUI();
        }

        function toggleGlobalSearchExpanded(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (state.globalSearchExpanded) {
                state.globalSearchExpanded = false;
            } else {
                state.globalSearchExpanded = true;
            }
            state.globalSearchOpen = true;
            updateGlobalSearchUI();
            renderGlobalSearchResults();
        }

        function setGlobalSearchSticky(enabled) {
            state.globalSearchSticky = !!enabled;
            updateGlobalSearchUI();
        }

        function updateGlobalSearchUI() {
            const bar = document.getElementById('global-search-bar');
            const expandBtn = document.getElementById('global-search-expand');
            const stickyInput = document.getElementById('global-search-sticky');
            if (!bar) return;
            bar.classList.toggle('open', state.globalSearchOpen);
            bar.classList.toggle('expanded', state.globalSearchOpen && state.globalSearchExpanded);
            if (expandBtn) {
                expandBtn.textContent = state.globalSearchExpanded ? 'Collapse' : 'Expand';
                expandBtn.setAttribute('aria-expanded', state.globalSearchExpanded ? 'true' : 'false');
            }
            if (stickyInput) {
                stickyInput.checked = state.globalSearchSticky;
            }
        }

        function initGlobalSearch() {
            document.addEventListener('click', (e) => {
                const bar = document.getElementById('global-search-bar');
                if (!bar) return;
                if (bar.contains(e.target)) return;
                closeGlobalSearch();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key !== 'Escape') return;
                if (state.globalSearchOpen && !state.globalSearchSticky) {
                    if (state.globalSearchExpanded) {
                        state.globalSearchExpanded = false;
                        updateGlobalSearchUI();
                        renderGlobalSearchResults();
                    } else {
                        closeGlobalSearch(true);
                    }
                }
            });
        }

        function rankGlobalEntity(entity, type, term, tokens) {
            if (!term) return 0;
            const id = (entity?.id || '').toString().toLowerCase();
            const name = (entity?.name || '').toString().toLowerCase();
            const desc = (entity?.description || '').toString().toLowerCase();
            const summary = (entity?.summary || '').toString().toLowerCase();
            let score = 0;

            if (id === term) score += 100;
            if (name === term) score += 95;
            if (id.startsWith(term)) score += 80;
            if (name.startsWith(term)) score += 70;
            if (id.includes(term)) score += 60;
            if (name.includes(term)) score += 55;
            if (desc.includes(term) || summary.includes(term)) score += 30;

            tokens.forEach(token => {
                if (!token) return;
                if (id.includes(token)) score += 12;
                if (name.includes(token)) score += 10;
                if (desc.includes(token) || summary.includes(token)) score += 4;
            });

            if (type === 'attack' && Array.isArray(entity?.tactics)) {
                const tacticText = entity.tactics.join(' ').toLowerCase();
                if (tacticText.includes(term)) score += 8;
                tokens.forEach(token => {
                    if (tacticText.includes(token)) score += 2;
                });
            }

            return score;
        }

        function buildGlobalSearchResults(term) {
            const results = [];
            const tokens = term.split(/\s+/).filter(Boolean);

            for (const entity of Object.values(state.library.techniques)) {
                const score = rankGlobalEntity(entity, 'attack', term, tokens);
                if (score > 0) results.push({ type: 'attack', id: entity.id, name: entity.name || '', score });
            }

            for (const entity of Object.values(state.library.capecs)) {
                const score = rankGlobalEntity(entity, 'capec', term, tokens);
                if (score > 0) results.push({ type: 'capec', id: entity.id, name: entity.name || '', score });
            }

            for (const entity of Object.values(state.library.cwes)) {
                const score = rankGlobalEntity(entity, 'cwe', term, tokens);
                if (score > 0) results.push({ type: 'cwe', id: entity.id, name: entity.name || '', score });
            }

            return results.sort((a, b) => b.score - a.score);
        }

        function renderGlobalSearchResults() {
            const resultsEl = document.getElementById('global-search-results');
            if (!resultsEl) return;
            const term = (state.globalSearch || '').trim().toLowerCase();
            if (!term) {
                resultsEl.innerHTML = '<div class="global-search-empty">Type to search across ATT&CK, CAPEC, and CWE.</div>';
                return;
            }

            const results = buildGlobalSearchResults(term);
            const maxResults = state.globalSearchExpanded ? 50 : 10;
            const visible = results.slice(0, maxResults);
            if (visible.length === 0) {
                resultsEl.innerHTML = '<div class="global-search-empty">No matches found.</div>';
                return;
            }

            resultsEl.innerHTML = visible.map(result => {
                const typeLabel = TYPE_LABELS[result.type] || result.type;
                const safeId = esc(result.id);
                const safeName = esc(result.name || '');
                return `
                    <button class="global-search-item entity-item ${escAttr(result.type)}" draggable="true"
                        ondragstart="handleDragStart(event, '${escAttr(result.type)}', '${escAttr(result.id)}')"
                        ondragend="handleDragEnd(event)"
                        onclick="openGlobalSearchResult('${escAttr(result.type)}', '${escAttr(result.id)}')">
                        <div class="global-search-meta">
                            <span class="global-search-type ${escAttr(result.type)}">${esc(typeLabel)}</span>
                            <span>${safeId}</span>
                        </div>
                        <div>${safeName}</div>
                    </button>
                `;
            }).join('');
        }

        function openGlobalSearchResult(type, id) {
            if (!type || !id) return;
            switchTab(type);
            selectEntity(type, id);
            if (!state.globalSearchSticky) {
                closeGlobalSearch();
            }
        }

        function matchesGlobalSearch(entity, type, term) {
            if (!term) return true;
            const fields = [];
            if (entity?.id) fields.push(entity.id);
            if (entity?.name) fields.push(entity.name);
            if (entity?.description) fields.push(entity.description);
            if (entity?.summary) fields.push(entity.summary);
            if (type === 'attack' && Array.isArray(entity?.tactics)) fields.push(entity.tactics.join(' '));
            return fields.some(field => field.toLowerCase().includes(term));
        }

        function parseCommaIdList(raw, pattern, prefix = '') {
            if (!raw || !raw.includes(',')) return null;
            const normalized = normalizeUserInput(raw, 1000, true);
            const ids = normalized
                .split(',')
                .map(part => part.trim())
                .filter(Boolean)
                .map(part => {
                    const upper = part.toUpperCase();
                    if (prefix && /^\d+$/.test(upper)) {
                        return `${prefix}-${upper}`;
                    }
                    return upper;
                });
            if (ids.length === 0) return null;
            const valid = ids.filter(id => pattern.test(id));
            if (valid.length === 0) return null;
            return new Set(valid);
        }

        // ============================================================
        // ENTITY LIST RENDERING
        // ============================================================
        function filterEntities(type) {
            const searchInput = document.getElementById(`search-${type}`);
            const rawSearch = searchInput ? searchInput.value : '';
            const searchTerm = rawSearch.toLowerCase();
            const globalTerm = (state.globalSearch || '').trim().toLowerCase();
            const filter = state.filters[type];
            const listEl = document.getElementById(`list-${type}`);
            
            let entities = [];
            
            if (type === 'attack') {
                const idSet = parseCommaIdList(rawSearch, IMPORT_LIMITS.techniqueIdPattern);
                entities = Object.values(state.library.techniques).filter(t => {
                    if (!matchesGlobalSearch(t, type, globalTerm)) return false;
                    if (idSet) {
                        if (!idSet.has(String(t.id || '').toUpperCase())) return false;
                    } else if (searchTerm && !t.id.toLowerCase().includes(searchTerm) && !t.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    if (filter !== 'all' && t.domain !== filter) return false;
                    return true;
                });
            } else if (type === 'capec') {
                const idSet = parseCommaIdList(rawSearch, /^CAPEC-\d+$/i, 'CAPEC');
                entities = Object.values(state.library.capecs).filter(c => {
                    if (!matchesGlobalSearch(c, type, globalTerm)) return false;
                    if (idSet) {
                        if (!idSet.has(String(c.id || '').toUpperCase())) return false;
                    } else if (searchTerm && !c.id.toLowerCase().includes(searchTerm) && !c.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    if (filter !== 'all' && c.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            } else if (type === 'cwe') {
                const idSet = parseCommaIdList(rawSearch, /^CWE-\d+$/i, 'CWE');
                entities = Object.values(state.library.cwes).filter(w => {
                    if (!matchesGlobalSearch(w, type, globalTerm)) return false;
                    if (idSet) {
                        if (!idSet.has(String(w.id || '').toUpperCase())) return false;
                    } else if (searchTerm && !w.id.toLowerCase().includes(searchTerm) && !w.name.toLowerCase().includes(searchTerm)) {
                        return false;
                    }
                    if (filter !== 'all' && w.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            } else if (type === 'custom') {
                entities = Object.values(state.library.custom).filter(c => {
                    if (searchTerm && !c.name.toLowerCase().includes(searchTerm) && !c.id.toLowerCase().includes(searchTerm)
                        && !(c.description || '').toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && c.stixType !== filter) return false;
                    return true;
                });
            }
            
            // Limit display for performance
            const maxDisplay = 100;
            const total = entities.length;
            entities = entities.slice(0, maxDisplay);
            
            let html = '';
            
            for (const entity of entities) {
                const isSelected = state.selection.type === type && state.selection.id === entity.id;
                
                if (type === 'attack') {
                    const subIndicator = entity.isSubtechnique ? 'â†³ ' : '';
                    const tacticBadge = entity.tactics?.length ? `<span class="entity-badge">${esc(entity.tactics[0])}</span>` : '';
                    html += `
                        <div class="entity-item attack ${isSelected ? 'selected' : ''}" 
                             onclick="selectEntity('attack', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'attack', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)"
                             title="${escAttr(entity.description ? entity.description.substring(0, 200) + '...' : '')}">
                            <div class="entity-header">
                                <span class="entity-id">${subIndicator}${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.domain?.toUpperCase() || 'ENT')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                ${tacticBadge}
                                ${entity.platforms?.length ? `<span class="entity-badge">${esc(entity.platforms.slice(0,2).join(', '))}</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'capec') {
                    const severityClass = entity.severity?.toLowerCase().includes('high') ? 'severity-high' : 
                                         entity.severity?.toLowerCase().includes('medium') ? 'severity-medium' : 'severity-low';
                    html += `
                        <div class="entity-item capec ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('capec', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'capec', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge ${severityClass}">${esc(entity.severity || 'Unknown')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                <span class="entity-badge">${esc(entity.abstraction || 'Standard')}</span>
                                ${entity.techniques?.length ? `<span class="entity-badge">${entity.techniques.length} techniques</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'cwe') {
                    html += `
                        <div class="entity-item cwe ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('cwe', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'cwe', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.abstraction || 'Base')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                        </div>
                    `;
                } else if (type === 'custom') {
                    const stixLabel = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).find(t => t.value === entity.stixType)?.label || entity.stixType;
                    const customTypeName = entity.stixType === 'x-custom' && entity.customTypeName ? ` (${esc(entity.customTypeName)})` : '';
                    const shortId = entity.id.length > 20 ? entity.id.substring(0, 18) + '...' : entity.id;
                    html += `
                        <div class="entity-item custom ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('custom', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'custom', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)"
                             title="${escAttr(entity.description ? entity.description.substring(0, 200) : '')}">
                            <div class="entity-header">
                                <span class="entity-id">${esc(shortId)}</span>
                                <span class="entity-badge stix-badge">${esc(stixLabel)}${customTypeName}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            ${entity.labels?.length ? `<div class="entity-meta">${entity.labels.slice(0,3).map(l => `<span class="entity-badge">${esc(l)}</span>`).join('')}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            if (total > maxDisplay) {
                html += `<div class="list-info">Showing ${maxDisplay} of ${total}. Refine your search.</div>`;
            } else if (entities.length === 0) {
                const typeLabels = { attack: 'techniques', capec: 'patterns', cwe: 'weaknesses', custom: 'STIX items' };
                html += `<div class="list-info">No ${typeLabels[type] || 'items'} found</div>`;
            }
            
            listEl.innerHTML = html;
        }

        function isEntityAssigned(type, id) {
            for (const phase of Object.values(state.assignments)) {
                const items = getAllPhaseItemsByType(phase, type);
                if (items.some(a => getAssignmentId(a) === id)) return true;
            }
            return false;
        }

        // ============================================================
        // CUSTOM ITEM MANAGEMENT (STIX 2.1)
        // ============================================================

        // --- STIX Bundle Import ---
        const STIX_BUNDLE_IMPORT_LIMITS = {
            maxFileSize: 25 * 1024 * 1024,  // 25 MB
            maxObjects: 5000,
            maxStringLength: 5000,
            maxListItems: 100,
            maxNameLength: 200,
            maxDescLength: 10000
        };

        function importStixBundle(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > STIX_BUNDLE_IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max ${STIX_BUNDLE_IMPORT_LIMITS.maxFileSize / 1024 / 1024}MB)`);
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = parseJsonSafe(e.target.result);
                    const data = stripAngleBracketsFromJson(rawData);

                    // Validate top-level bundle structure
                    if (typeof data !== 'object' || data === null || Array.isArray(data)) {
                        throw new Error('Invalid STIX bundle: expected JSON object');
                    }
                    if (data.type !== 'bundle') {
                        throw new Error('Invalid STIX bundle: top-level type must be "bundle"');
                    }
                    if (!Array.isArray(data.objects)) {
                        throw new Error('Invalid STIX bundle: missing objects array');
                    }
                    if (data.objects.length > STIX_BUNDLE_IMPORT_LIMITS.maxObjects) {
                        throw new Error(`Too many objects: ${data.objects.length} (max ${STIX_BUNDLE_IMPORT_LIMITS.maxObjects})`);
                    }

                    let imported = 0, skipped = 0, duplicates = 0;

                    // Auto-clear existing STIX data if configured
                    if (CONFIG.imports?.clearStixOnBundleImport) {
                        for (const [phaseKey, pd] of Object.entries(state.assignments)) {
                            if (!pd) continue;
                            if (pd.customItems) pd.customItems = [];
                            for (const group of pd.groups || []) {
                                group.items = (group.items || []).filter(item => item.type !== 'custom');
                            }
                            ensurePhaseLayout(phaseKey, pd);
                        }
                        state.library.custom = {};
                    }

                    for (const obj of data.objects) {
                        // Basic object validation
                        if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
                            skipped++;
                            continue;
                        }

                        const objType = obj.type;
                        if (typeof objType !== 'string') { skipped++; continue; }

                        // Skip relationships to catch and SROs â€” only import SDOs
                        if (objType === 'relationship' || objType === 'sighting' || objType === 'marking-definition') {
                            continue;
                        }

                        // Validate type is in our supported SDO list
                        if (!VALID_STIX_TYPES.has(objType)) {
                            skipped++;
                            continue;
                        }

                        // Validate STIX ID format
                        const objId = obj.id;
                        if (typeof objId !== 'string' || !STIX_ID_PATTERN.test(objId)) {
                            skipped++;
                            continue;
                        }

                        // Verify ID prefix matches declared type
                        if (objId.split('--')[0] !== objType) {
                            skipped++;
                            continue;
                        }

                        // Skip if already exists in library
                        if (state.library.custom[objId]) {
                            duplicates++;
                            continue;
                        }

                        // Validate name exists (most SDOs require it)
                        const rawName = obj.name;
                        if (typeof rawName !== 'string' || rawName.trim().length === 0) {
                            // Some SDOs (observed-data, opinion, note) may lack name â€” synthesize one
                            if (!['observed-data', 'opinion', 'note', 'report'].includes(objType)) {
                                skipped++;
                                continue;
                            }
                        }

                        // Build sanitized library entry
                        const entry = sanitizeStixBundleObject(obj, objType, objId);
                        if (!entry) { skipped++; continue; }

                        state.library.custom[objId] = entry;
                        imported++;
                    }

                    // Build result message
                    let msg = `Imported ${imported} STIX object${imported !== 1 ? 's' : ''}`;
                    if (duplicates > 0) msg += `, ${duplicates} duplicate${duplicates !== 1 ? 's' : ''} skipped`;
                    if (skipped > 0) msg += `, ${skipped} invalid skipped`;

                    switchTab('custom');
                    filterEntities('custom');
                    if (CONFIG.imports?.clearStixOnBundleImport) renderAll();
                    showToast(msg);
                } catch (err) {
                    showToast('STIX import failed: ' + InputSecurity.escapeHtml(err.message));
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearStixLibrary() {
            const count = Object.keys(state.library.custom).length;
            if (count === 0) {
                showToast('No STIX items to clear');
                return;
            }
            if (!confirm(`Clear all ${count} STIX item${count !== 1 ? 's' : ''} from the library and remove them from all kill chain phases?`)) return;

            // Remove custom items from all phase assignments (ungrouped + grouped)
            for (const [phaseKey, pd] of Object.entries(state.assignments)) {
                if (!pd) continue;
                if (pd.customItems) pd.customItems = [];
                for (const group of pd.groups || []) {
                    group.items = (group.items || []).filter(item => item.type !== 'custom');
                }
                ensurePhaseLayout(phaseKey, pd);
            }

            // Clear the library
            state.library.custom = {};

            filterEntities('custom');
            renderAll();
            showToast(`Cleared ${count} STIX item${count !== 1 ? 's' : ''}`);
        }

        function sanitizeStixBundleObject(obj, stixType, stixId) {
            const L = STIX_BUNDLE_IMPORT_LIMITS;

            // Core fields â€” sanitized as untrusted input
            const name = sanitizeImportedString(
                typeof obj.name === 'string' ? obj.name : (stixType + ' ' + stixId.split('--')[1].slice(0, 8)),
                L.maxNameLength
            );

            const description = sanitizeImportedString(
                typeof obj.description === 'string' ? obj.description : '',
                L.maxDescLength
            );

            const labels = Array.isArray(obj.labels)
                ? obj.labels
                    .slice(0, L.maxListItems)
                    .filter(l => typeof l === 'string')
                    .map(l => sanitizeImportedString(l, 100))
                : [];

            const created = typeof obj.created === 'string'
                ? obj.created.slice(0, 30)
                : new Date().toISOString();
            const modified = typeof obj.modified === 'string'
                ? obj.modified.slice(0, 30)
                : new Date().toISOString();

            const entry = {
                id: stixId,
                stixType: stixType,
                name: name,
                description: description,
                labels: labels,
                customTypeName: '',
                created: created,
                modified: modified
            };

            // Import spec-defined fields from stix-config.js
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (typeDef) {
                const coreKeys = new Set(['name', 'description', 'labels']);
                const specFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !coreKeys.has(f.key));
                for (const field of specFields) {
                    if (!field || isDangerousObjectKey(field.key)) continue;
                    if (!hasOwn(obj, field.key)) continue;
                    const raw = obj[field.key];
                    if (field.type === 'boolean') {
                        entry[field.key] = !!raw;
                    } else if (field.type === 'integer') {
                        const num = parseInt(raw, 10);
                        if (!isNaN(num)) entry[field.key] = num;
                    } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                        if (Array.isArray(raw)) {
                            entry[field.key] = raw
                                .slice(0, L.maxListItems)
                                .filter(v => typeof v === 'string')
                                .map(v => sanitizeImportedString(v, 200));
                        }
                    } else {
                        // string, text, enum, open-vocab, timestamp, identifier
                        if (typeof raw === 'string') {
                            entry[field.key] = sanitizeImportedString(raw, L.maxStringLength);
                        }
                    }
                }
            }

            return entry;
        }
        function populateStixTypeDropdown() {
            const select = document.getElementById('custom-stix-type');
            const filterSelect = document.getElementById('filter-custom-type');
            if (!select) return;
            select.innerHTML = '';
            if (filterSelect) filterSelect.innerHTML = '<option value="all">All Types</option>';
            const types = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes) || [];
            for (const t of types) {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.label;
                select.appendChild(opt);
                if (filterSelect) {
                    const fopt = document.createElement('option');
                    fopt.value = t.value;
                    fopt.textContent = t.label;
                    filterSelect.appendChild(fopt);
                }
            }
        }

        function toggleCustomTypeName() {
            const typeVal = document.getElementById('custom-stix-type').value;
            const group = document.getElementById('custom-typename-group');
            if (group) group.style.display = typeVal === 'x-custom' ? 'block' : 'none';
        }

        function openCreateCustomModal() {
            populateStixTypeDropdown();
            document.getElementById('custom-name').value = '';
            document.getElementById('custom-description').value = '';
            document.getElementById('custom-labels').value = '';
            document.getElementById('custom-typename').value = '';
            document.getElementById('create-custom-error').textContent = '';
            toggleCustomTypeName();
            document.getElementById('create-custom-modal').classList.add('visible');
        }

        function closeCreateCustomModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('create-custom-modal').classList.remove('visible');
        }

        function createCustomItem() {
            const errorEl = document.getElementById('create-custom-error');
            errorEl.textContent = '';

            const stixType = document.getElementById('custom-stix-type').value;
            const rawName = document.getElementById('custom-name').value;
            const rawDesc = document.getElementById('custom-description').value;
            const rawLabels = document.getElementById('custom-labels').value;
            const rawTypeName = document.getElementById('custom-typename').value;

            // Validate STIX type
            if (!VALID_STIX_TYPES.has(stixType)) {
                errorEl.textContent = 'Invalid STIX type selected.';
                return;
            }

            // Sanitize name
            const name = sanitizeForStorage(rawName, CONFIG.display?.maxNameLength || 200);
            if (!name || name.trim().length === 0) {
                errorEl.textContent = 'Name is required.';
                return;
            }

            // Sanitize description
            const description = sanitizeForStorage(rawDesc, CONFIG.display?.maxCustomDescLength || 2000);

            // Sanitize labels
            const maxLabels = CONFIG.display?.maxCustomLabels || 20;
            const maxLabelLen = CONFIG.display?.maxLabelLength || 50;
            const labels = rawLabels
                .split(',')
                .map(l => sanitizeForStorage(l.trim(), maxLabelLen))
                .filter(l => l.length > 0)
                .slice(0, maxLabels);

            // Sanitize custom type name (for x-custom only)
            let customTypeName = '';
            if (stixType === 'x-custom') {
                customTypeName = sanitizeForStorage(rawTypeName, 80);
            }

            // Generate STIX ID
            const id = generateStixId(stixType);
            const now = new Date().toISOString();

            // Store in library
            state.library.custom[id] = {
                id,
                stixType,
                name,
                description,
                labels,
                customTypeName,
                created: now,
                modified: now
            };

            closeCreateCustomModal();
            switchTab('custom');
            filterEntities('custom');
            showToast(`Created: ${name}`);
        }

        function deleteCustomItem(id) {
            if (!id || !state.library.custom[id]) return;
            if (!window.confirm('Delete this STIX item? It will also be removed from all phase assignments.')) return;

            // Remove from library
            delete state.library.custom[id];

            // Remove from all phase assignments
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                phaseData.customItems = (phaseData.customItems || []).filter(a => getAssignmentId(a) !== id);
                for (const group of phaseData.groups || []) {
                    group.items = (group.items || []).filter(item => !(item.type === 'custom' && getAssignmentId(item) === id));
                }
                ensurePhaseLayout(phaseKey, phaseData);
            }

            filterEntities('custom');
            renderKillChain();
            showToast('STIX item deleted');
        }

        // ============================================================
        // STIX EDITOR MODAL
        // ============================================================
        let currentStixEdit = { id: null, phaseKey: null, instanceId: null };

        function openStixEditor(id, phaseKey, instanceId) {
            const item = state.library.custom[id];
            if (!item) { showToast('Item not found', 'error'); return; }

            currentStixEdit = { id, phaseKey: phaseKey || null, instanceId: instanceId || null };
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;

            // Header
            const badgeEl = document.getElementById('edit-stix-type-badge');
            badgeEl.textContent = typeDef ? typeDef.label : stixType;

            // Build form fields
            const body = document.getElementById('edit-stix-body');
            body.innerHTML = '';
            const errorEl = document.getElementById('edit-stix-error');
            errorEl.textContent = '';

            // -- Common read-only fields --
            body.innerHTML += '<div class="edit-stix-section-title">Identity</div>';
            body.innerHTML += buildStixReadonlyField('ID', item.id);
            body.innerHTML += buildStixReadonlyField('Type', stixType);
            body.innerHTML += buildStixReadonlyField('Created', item.created || 'â€”');
            body.innerHTML += buildStixReadonlyField('Modified', item.modified || 'â€”');

            // -- Core editable fields (always present) --
            body.innerHTML += '<div class="edit-stix-section-title">Core Properties</div>';
            body.innerHTML += buildStixTextField('stix-edit-name', 'Name', item.name || '', true, 200, 'Display name');
            body.innerHTML += buildStixTextareaField('stix-edit-description', 'Description', item.description || '', false, 2000, 'Optional description...');
            body.innerHTML += buildStixTextField('stix-edit-labels', 'Labels (comma-separated)', (item.labels || []).join(', '), false, 1200, 'e.g. trojan, botnet');

            if (stixType === 'x-custom') {
                body.innerHTML += buildStixTextField('stix-edit-typename', 'Custom Type Name', item.customTypeName || '', false, 80, 'e.g. APT Group Profile');
            }

            // -- Spec-defined fields from stix-config.js --
            if (typeDef) {
                const existingKeys = new Set(['name', 'description', 'labels']);

                // Required fields
                const reqFields = (typeDef.required || []).filter(f => !existingKeys.has(f.key));
                if (reqFields.length > 0) {
                    body.innerHTML += '<div class="edit-stix-section-title">Required Fields</div>';
                    for (const field of reqFields) {
                        body.innerHTML += buildStixFieldFromSpec(field, item, true);
                    }
                }

                // Optional fields
                const optFields = (typeDef.optional || []).filter(f => !existingKeys.has(f.key));
                if (optFields.length > 0) {
                    body.innerHTML += '<div class="edit-stix-section-title">Optional Fields</div>';
                    for (const field of optFields) {
                        body.innerHTML += buildStixFieldFromSpec(field, item, false);
                    }
                }
            }

            document.getElementById('edit-stix-modal').classList.add('visible');
        }

        function closeStixEditor(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('edit-stix-modal').classList.remove('visible');
            currentStixEdit = { id: null, phaseKey: null, instanceId: null };
        }

        function saveStixEditor() {
            const { id } = currentStixEdit;
            const item = state.library.custom[id];
            if (!item) { closeStixEditor(); return; }

            const errorEl = document.getElementById('edit-stix-error');
            errorEl.textContent = '';

            // Read core fields
            const nameEl = document.getElementById('stix-edit-name');
            const descEl = document.getElementById('stix-edit-description');
            const labelsEl = document.getElementById('stix-edit-labels');
            const typeNameEl = document.getElementById('stix-edit-typename');

            const rawName = nameEl ? nameEl.value : '';
            const name = sanitizeForStorage(rawName, CONFIG.display?.maxNameLength || 200);
            if (!name || name.trim().length === 0) {
                errorEl.textContent = 'Name is required.';
                return;
            }

            item.name = name;
            item.description = sanitizeForStorage(descEl ? descEl.value : '', CONFIG.display?.maxCustomDescLength || 2000);

            const maxLabels = CONFIG.display?.maxCustomLabels || 20;
            const maxLabelLen = CONFIG.display?.maxLabelLength || 50;
            item.labels = (labelsEl ? labelsEl.value : '')
                .split(',')
                .map(l => sanitizeForStorage(l.trim(), maxLabelLen))
                .filter(l => l.length > 0)
                .slice(0, maxLabels);

            if (typeNameEl) {
                item.customTypeName = sanitizeForStorage(typeNameEl.value, 80);
            }

            // Read spec-defined fields
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (typeDef) {
                const existingKeys = new Set(['name', 'description', 'labels']);
                const allFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !existingKeys.has(f.key));
                for (const field of allFields) {
                    const fieldEl = document.getElementById('stix-edit-' + field.key);
                    if (!fieldEl) continue;
                    const rawVal = fieldEl.value || '';
                    if (field.type === 'boolean') {
                        item[field.key] = fieldEl.checked;
                    } else if (field.type === 'integer') {
                        const num = parseInt(rawVal, 10);
                        item[field.key] = isNaN(num) ? undefined : num;
                    } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                        item[field.key] = rawVal.split(',').map(s => sanitizeForStorage(s.trim(), 200)).filter(s => s.length > 0);
                    } else {
                        item[field.key] = sanitizeForStorage(rawVal, 2000);
                    }
                }
            }

            item.modified = new Date().toISOString();
            closeStixEditor();
            filterEntities('custom');
            renderKillChain();
            showToast('STIX item updated');
        }

        // -- STIX Editor field builders --
        function buildStixReadonlyField(label, value) {
            return `<div class="stix-field-group">
                <label>${esc(label)}</label>
                <input type="text" value="${esc(value)}" readonly>
            </div>`;
        }

        function buildStixTextField(id, label, value, required, maxLen, placeholder) {
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            return `<div class="stix-field-group">
                <label>${esc(label)}${reqMark}</label>
                <input type="text" id="${esc(id)}" value="${esc(value)}" maxlength="${maxLen || 200}" placeholder="${esc(placeholder || '')}" spellcheck="false">
            </div>`;
        }

        function buildStixTextareaField(id, label, value, required, maxLen, placeholder) {
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            return `<div class="stix-field-group">
                <label>${esc(label)}${reqMark}</label>
                <textarea id="${esc(id)}" maxlength="${maxLen || 2000}" rows="3" placeholder="${esc(placeholder || '')}">${esc(value)}</textarea>
            </div>`;
        }

        function buildStixFieldFromSpec(field, item, required) {
            const fieldId = 'stix-edit-' + field.key;
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            const currentVal = item[field.key];
            const hint = field.description ? `<div class="field-hint">${esc(field.description)}</div>` : '';

            switch (field.type) {
                case 'string':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" maxlength="2000" placeholder="${esc(field.placeholder || '')}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'text':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <textarea id="${esc(fieldId)}" maxlength="5000" rows="3" placeholder="${esc(field.placeholder || '')}">${esc(currentVal || '')}</textarea>
                        ${hint}
                    </div>`;

                case 'enum':
                case 'open-vocab': {
                    const vocabValues = field.vocabulary ? getStixVocabulary(field.vocabulary) : [];
                    let opts = '<option value="">â€” Select â€”</option>';
                    for (const v of vocabValues) {
                        const sel = (currentVal === v) ? ' selected' : '';
                        opts += `<option value="${esc(v)}"${sel}>${esc(v)}</option>`;
                    }
                    if (field.type === 'open-vocab') {
                        // If current value is not in vocab, add it as option
                        if (currentVal && !vocabValues.includes(currentVal)) {
                            opts += `<option value="${esc(currentVal)}" selected>${esc(currentVal)} (custom)</option>`;
                        }
                    }
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <select id="${esc(fieldId)}">${opts}</select>
                        ${hint}
                    </div>`;
                }

                case 'list':
                case 'list:open-vocab': {
                    const arrVal = Array.isArray(currentVal) ? currentVal.join(', ') : (currentVal || '');
                    const vocabHint = (field.type === 'list:open-vocab' && field.vocabulary)
                        ? `<div class="field-hint">Values: ${getStixVocabulary(field.vocabulary).join(', ')}</div>`
                        : '';
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)} <span style="color:var(--text-secondary);font-weight:normal;">(comma-separated)</span>${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(arrVal)}" maxlength="2000" spellcheck="false">
                        ${hint}${vocabHint}
                    </div>`;
                }

                case 'integer':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="number" id="${esc(fieldId)}" value="${currentVal != null ? currentVal : ''}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'boolean':
                    return `<div class="stix-field-group">
                        <label style="display:inline-flex;align-items:center;gap:6px;">
                            <input type="checkbox" id="${esc(fieldId)}" ${currentVal ? 'checked' : ''} style="width:auto;">
                            ${esc(field.label)}${reqMark}
                        </label>
                        ${hint}
                    </div>`;

                case 'timestamp':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" placeholder="YYYY-MM-DDThh:mm:ss.sssZ" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'identifier':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" placeholder="${esc(field.placeholder || 'type--uuid')}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'kill-chain-phases':
                case 'external-references':
                case 'dictionary':
                    // Complex types: render as JSON textarea for now
                    const jsonVal = currentVal ? JSON.stringify(currentVal, null, 2) : '';
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)} <span style="color:var(--text-secondary);font-weight:normal;">(JSON)</span>${reqMark}</label>
                        <textarea id="${esc(fieldId)}" rows="3" placeholder="${esc(field.description || '')}">${esc(jsonVal)}</textarea>
                        ${hint}
                    </div>`;

                default:
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" spellcheck="false">
                        ${hint}
                    </div>`;
            }
        }

        // Get display name for an entity by type
        function getEntityName(type, id) {
            if (type === 'attack') return state.library.techniques[id]?.name || '';
            if (type === 'capec') return state.library.capecs[id]?.name || '';
            if (type === 'cwe') return state.library.cwes[id]?.name || '';
            if (type === 'custom') return state.library.custom[id]?.name || '';
            return '';
        }

        // ============================================================
        // SELECTION & DETAIL
        // ============================================================

        // Replace ATT&CK markdown links in descriptions with clickable
        // technique-ID badges that open the integrated Explorer view.
        // Runs on already-escaped text (after esc()).  All regex captures
        // are treated as UNTRUSTED â€” the label is escaped with escAttr()
        // before any attribute insertion to prevent attribute-breakout XSS.
        // See FINDINGS.md KCE-SEC-010, TASKS.md Task 23.
        function renderDescriptionWithBadges(escapedText) {
            return escapedText.replace(
                /\[([^\]]{1,80})\]\(https?:\/\/attack\.mitre\.org\/techniques\/(T\d{4}(?:\/\d{3})?)\)/g,
                (match, label, rawId) => {
                    const id = rawId.replace('/', '.');
                    const safeTitle = escAttr(label);
                    return `<span class="technique-xref-badge" `
                         + `onclick="openEntityExplorer('attack', '${id}')" `
                         + `title="${safeTitle}">${id}</span>`;
                }
            );
        }

        function selectEntity(type, id) {
            state.selection = { type, id };
            
            // Update list selection
            filterEntities(type);
            
            // Show detail panel
            showDetail(type, id);
        }

        function isSafeHttpUrl(url) {
            if (typeof url !== 'string') return false;
            const trimmed = url.trim();
            if (!trimmed) return false;
            try {
                const parsed = new URL(trimmed);
                return parsed.protocol === 'http:' || parsed.protocol === 'https:';
            } catch (e) {
                return false;
            }
        }

        // KCE-SEC-011: Validate entity IDs before use in URLs to prevent injection
        function isValidEntityId(type, id) {
            if (!id || typeof id !== 'string') return false;
            // ATT&CK: T####.### format
            if (type === 'attack') return /^T\d{4}(?:\.\d{3})?$/.test(id);
            // CAPEC: CAPEC-### format
            if (type === 'capec') return /^CAPEC-\d+$/.test(id);
            // CWE: CWE-### format
            if (type === 'cwe') return /^CWE-\d+$/.test(id);
            // Custom: Allow alphanumeric with hyphens and underscores
            if (type === 'custom') return /^[a-zA-Z0-9_-]+$/.test(id);
            return false;
        }

        function buildEntityDetail(type, id) {
            let entity, html = '', name = 'Unknown';

            if (type === 'attack') {
                entity = state.library.techniques[id] || state._baseTechniques?.[id];
                name = entity?.name || 'Unknown';

                const relatedCapecs = state.techniqueToCapec[id] || [];
                const platforms = entity?.platforms?.join(', ') || 'N/A';
                const tactics = entity?.tactics?.map(t => t.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(', ') || 'N/A';

                const mitigations = entity?.mitigations || [];
                const mitigationsHtml = mitigations.length > 0 
                    ? mitigations.slice(0, 8).map(m => `
                        <div class="detail-list-item" style="cursor: pointer;" onclick="openMitigationExplorer('${escAttr(m.id)}')" title="${escAttr(m.description || '')}">
                            <span class="id" style="color: #10b981;">${esc(m.id)}</span>
                            <span>${esc(m.name)}</span>
                        </div>
                    `).join('') + (mitigations.length > 8 ? `<div class="list-info">+${mitigations.length - 8} more</div>` : '')
                    : '<div class="list-info">No mitigations available</div>';

                const refs = entity?.references || [];
                const refsHtml = refs.slice(0, 3).map(r => {
                    const url = r?.url || '';
                    const isSafeUrl = isSafeHttpUrl(url);
                    return isSafeUrl ? `
                    <div class="detail-list-item">
                        <a href="${escAttr(url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(r.name)} â†’
                        </a>
                    </div>
                ` : '';
                }).join('');

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${renderDescriptionWithBadges(esc(entity?.description || 'No description available.'))}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Domain:</span><span>${esc((entity?.domain || 'enterprise').toUpperCase())}</span></div>
                            <div class="detail-list-item"><span>Platforms:</span><span>${esc(platforms)}</span></div>
                            <div class="detail-list-item"><span>Tactics:</span><span>${esc(tactics)}</span></div>
                            ${entity?.isSubtechnique ? `<div class="detail-list-item"><span>Parent:</span><span onclick="selectEntity('attack', '${escAttr(entity.parentTechnique)}')" style="cursor:pointer; color: var(--attack-color);">${esc(entity.parentTechnique)}</span></div>` : ''}
                            <div class="detail-list-item"><span>Version:</span><span>${esc(entity?.version || '1.0')}</span></div>
                        </div>
                    </div>
                    ${entity?.detection ? `
                    <div class="detail-section">
                        <h4>Detection</h4>
                        <details>
                            <summary>Show / hide detection guidance</summary>
                            <p style="font-size: 0.75rem;">${renderDescriptionWithBadges(esc(entity.detection))}</p>
                        </details>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <h4>Mitigations (${mitigations.length})</h4>
                        <div class="detail-list">
                            ${mitigationsHtml}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length === 0 ? '<div class="list-info">No CAPEC mappings</div>' : ''}
                        </div>
                    </div>
                    ${refs.length > 0 ? `
                    <div class="detail-section">
                        <h4>References</h4>
                        <div class="detail-list">
                            ${refsHtml}
                        </div>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        ${isValidEntityId('attack', id) 
                            ? `<a href="https://attack.mitre.org/techniques/${id.replace('.', '/')}" target="_blank" rel="noopener noreferrer" style="color: var(--attack-color);">View on MITRE ATT&CK â†’</a>`
                            : '<span style="color: var(--text-secondary);">Invalid technique ID</span>'}
                    </div>
                `;
            } else if (type === 'capec') {
                entity = state.library.capecs[id];
                name = entity?.name || 'Unknown';

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${esc(entity?.description || 'No description available.')}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Severity:</span><span>${esc(entity?.severity || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Likelihood:</span><span>${esc(entity?.likelihood || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Abstraction:</span><span>${esc(entity?.abstraction || 'Standard')}</span></div>
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related Techniques (${entity?.techniques?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.techniques || []).map(t => `
                                <div class="detail-list-item" onclick="selectEntity('attack', '${escAttr(t)}')">
                                    <span class="id attack">${esc(t)}</span>
                                    <span>${esc(state.library.techniques[t]?.name || getTechniqueName(t))}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CWEs (${entity?.cwes?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.cwes || []).slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('cwe', '${escAttr(c)}')">
                                    <span class="id cwe">${esc(c)}</span>
                                    <span>${esc(state.library.cwes[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${(entity?.cwes?.length || 0) > 10 ? `<div class="list-info">+${entity.cwes.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        ${isValidEntityId('capec', id) 
                            ? `<a href="https://capec.mitre.org/data/definitions/${esc(id.replace('CAPEC-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--capec-color);">View on MITRE CAPEC â†’</a>`
                            : '<span style="color: var(--text-secondary);">Invalid CAPEC ID</span>'}
                    </div>
                `;
            } else if (type === 'cwe') {
                entity = state.library.cwes[id];
                name = entity?.name || 'Unknown';
                const relatedCapecs = state.cweToCapec[id] || entity?.capecs || [];

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${esc(entity?.description || 'No description available.')}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Abstraction</h4>
                        <p>${esc(entity?.abstraction || 'Base')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length > 10 ? `<div class="list-info">+${relatedCapecs.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        ${isValidEntityId('cwe', id) 
                            ? `<a href="https://cwe.mitre.org/data/definitions/${esc(id.replace('CWE-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--cwe-color);">View on MITRE CWE â†’</a>`
                            : '<span style="color: var(--text-secondary);">Invalid CWE ID</span>'}
                    </div>
                `;
            } else if (type === 'custom') {
                entity = state.library.custom[id];
                name = entity?.name || 'Unknown';
                const stixLabel = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).find(t => t.value === entity?.stixType)?.label || entity?.stixType || 'Unknown';
                const customTypeName = entity?.stixType === 'x-custom' && entity?.customTypeName ? esc(entity.customTypeName) : '';
                const labelsHtml = (entity?.labels || []).map(l => `<span class="entity-badge">${esc(l)}</span>`).join(' ');

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <p>${esc(entity?.description || 'No description available.')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>STIX Type:</span><span>${esc(stixLabel)}</span></div>
                            ${customTypeName ? `<div class="detail-list-item"><span>Custom Type:</span><span>${customTypeName}</span></div>` : ''}
                            <div class="detail-list-item"><span>STIX ID:</span><span style="font-family:monospace; font-size:0.7rem; word-break:break-all;">${esc(entity?.id || id)}</span></div>
                            <div class="detail-list-item"><span>Created:</span><span>${esc(entity?.created ? new Date(entity.created).toLocaleDateString() : 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Modified:</span><span>${esc(entity?.modified ? new Date(entity.modified).toLocaleDateString() : 'Unknown')}</span></div>
                        </div>
                    </div>
                    ${labelsHtml ? `
                    <div class="detail-section">
                        <h4>Labels</h4>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">${labelsHtml}</div>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <button class="btn" style="margin-right:8px;" onclick="openStixEditor('${esc(id)}')">Edit Item</button>
                        <button class="btn" style="color: #ef4444; border-color: #ef4444;" onclick="deleteCustomItem('${esc(id)}')">Delete Item</button>
                    </div>
                `;
            }

            return { id, name, html };
        }

        function buildStixPropertySummary(id) {
            const item = state.library.custom[id];
            if (!item) return '';
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (!typeDef) return '';

            const skipKeys = new Set(['name', 'description', 'labels', 'id', 'stixType', 'customTypeName', 'created', 'modified']);
            const allFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !skipKeys.has(f.key));

            // Collect fields that have values
            const rows = [];
            for (const field of allFields) {
                const val = item[field.key];
                if (val === undefined || val === null || val === '') continue;
                let display;
                if (field.type === 'boolean') {
                    display = val ? 'Yes' : 'No';
                } else if (Array.isArray(val)) {
                    if (val.length === 0) continue;
                    display = val.map(v => typeof v === 'object' ? JSON.stringify(v) : String(v)).join(', ');
                } else if (typeof val === 'object') {
                    display = JSON.stringify(val, null, 2);
                } else {
                    display = String(val);
                }
                rows.push({ label: field.label, value: display });
            }

            if (rows.length === 0) return '';

            return `
                <div class="detail-section">
                    <h4>STIX Properties</h4>
                    <div class="detail-list">
                        ${rows.map(r => `<div class="detail-list-item"><span>${esc(r.label)}:</span><span style="word-break:break-word;">${esc(r.value)}</span></div>`).join('')}
                    </div>
                </div>
            `;
        }

        function buildMetadataSummary(type, id, phaseKey, instanceId) {
            const assignment = phaseKey ? findAssignment(phaseKey, type, id, instanceId) : null;
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            const score = metadata.score || 'unclassified';
            const scoreLabel = SCORE_LEVELS[score]?.label || 'Unclassified';
            const confidence = metadata.confidence ? `${metadata.confidence}% (${getConfidenceLabel(metadata.confidence)})` : 'Unknown';
            const safePhase = phaseKey ? `${phaseKey.split(':')[0]} â€” ${formatPhaseName(phaseKey.split(':')[1])}` : '';
            const cveEntries = getCveEntries(metadata);
            const cveDisplay = cveEntries.length
                ? cveEntries.map(entry => {
                    const parts = [];
                    if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                    if (entry.vector) parts.push(entry.vector);
                    return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                })
                : [];

            const links = (metadata.hyperlinks || []).filter(l => l?.url && /^https?:\/\//i.test(l.url));
            const linksHtml = links.length
                ? links.map(l => `
                    <div class="detail-list-item">
                        <a href="${escAttr(l.url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(l.label || l.url)} â†’
                        </a>
                    </div>
                `).join('')
                : '<div class="list-info">No hyperlinks</div>';

            const observables = metadata.observables || [];
            const observablesHtml = observables.length
                ? observables.map(o => `
                    <div class="detail-list-item">
                        <span>${esc(o.type)}</span>
                        <span>${esc(o.value)}</span>
                    </div>
                `).join('')
                : '<div class="list-info">No observables</div>';

            return `
                <div class="detail-section">
                    <h4>Metadata</h4>
                    <div class="detail-list">
                        <div class="detail-list-item"><span>Score:</span><span>${esc(scoreLabel)}</span></div>
                        <div class="detail-list-item"><span>Confidence:</span><span>${esc(confidence)}</span></div>
                        ${safePhase ? `<div class="detail-list-item"><span>Phase:</span><span>${esc(safePhase)}</span></div>` : ''}
                        ${cveDisplay.length ? cveDisplay.map(entry => `<div class="detail-list-item"><span>CVE:</span><span>${esc(entry)}</span></div>`).join('') : ''}
                    </div>
                </div>
                ${metadata.comments ? `
                <div class="detail-section">
                    <h4>Comments</h4>
                    <p>${esc(metadata.comments).replace(/\n/g, '<br>')}</p>
                </div>
                ` : ''}
                <div class="detail-section">
                    <h4>Hyperlinks</h4>
                    <div class="detail-list">
                        ${linksHtml}
                    </div>
                </div>
                <div class="detail-section">
                    <h4>Observables</h4>
                    <div class="detail-list">
                        ${observablesHtml}
                    </div>
                </div>
            `;
        }

        function openEntityModal(type, id, phaseKey, instanceId) {
            if (!type || !id) return;
            const detail = buildEntityDetail(type, id);
            document.getElementById('entity-modal-id').textContent = detail.id;
            document.getElementById('entity-modal-name').textContent = detail.name;
            const content = document.getElementById('entity-modal-content');
            // STIX custom objects show their own properties; ATT&CK/CAPEC/CWE show metadata summary
            const supplementary = type === 'custom'
                ? buildStixPropertySummary(id)
                : buildMetadataSummary(type, id, phaseKey, instanceId);
            content.innerHTML = type === 'custom'
                ? detail.html + supplementary
                : supplementary + detail.html;
            document.getElementById('entity-modal').classList.add('visible');
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type, id };
        }

        function closeEntityModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('entity-modal').classList.remove('visible');
        }

        function showDetail(type, id) {
            const panel = document.getElementById('detail-panel');
            const idEl = document.getElementById('detail-id');
            const nameEl = document.getElementById('detail-name');
            const contentEl = document.getElementById('detail-content');
            
            panel.classList.add('visible');
            idEl.className = `detail-id ${type}`;
            
            const detail = buildEntityDetail(type, id);
            idEl.textContent = detail.id;
            nameEl.textContent = detail.name;
            contentEl.innerHTML = detail.html;
            
            // Set current assignment in dropdown
        }

        function closeDetail() {
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type: null, id: null };
            filterEntities(state.activeTab);
        }

        function findEntityPhase(type, id) {
            for (const [phase, data] of Object.entries(state.assignments)) {
                const items = getAllPhaseItemsByType(data, type);
                if (items.some(a => getAssignmentId(a) === id)) return phase;
            }
            return null;
        }

        // ============================================================
        // DRAG & DROP
        // ============================================================
        let dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };

        function handleDragStart(event, type, id) {
            dragData = { kind: 'item', type, id, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);
            
            // Highlight all phases as potential drop targets
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            
            // Remove drop target highlighting
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.remove('drop-target');
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            event.currentTarget.style.background = 'rgba(113, 113, 122, 0.25)';
        }

        function handleDragLeave(event) {
            event.currentTarget.style.background = '';
        }

        function handleDrop(event, phaseKey) {
            event.preventDefault();
            event.currentTarget.style.background = '';
            
            const { kind, type, id, fromPhase, instanceId, groupId, sourceGroupId } = dragData;
            if (!kind) return;

            if (kind === 'group') {
                if (!fromPhase || !groupId) return;
                moveGroupBetweenPhases(fromPhase, phaseKey, groupId);
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                return;
            }
            
            if (!type || !id) return;
            
            const key = TYPE_KEYS[type];
            if (!key) return;
            if (fromPhase && fromPhase === phaseKey && !sourceGroupId) {
                return;
            }

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }
            
            // Add to target phase with metadata (new format)
            if (state.assignments[phaseKey]) {
                const newAssignment = {
                    id: id,
                    metadata: existingMetadata || createDefaultMetadata(),
                    instanceId: instanceId || createAssignmentInstanceId()
                };
                state.assignments[phaseKey][key].push(newAssignment);
                ensurePhaseLayout(phaseKey, state.assignments[phaseKey]);
                showToast(`${id} â†’ ${formatPhaseName(phaseKey.split(':')[1])}`);
            }
            
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function handleAssignmentDragStart(event, type, id, phaseKey, instanceId, sourceGroupId) {
            dragData = { kind: 'item', type, id, fromPhase: phaseKey, instanceId, groupId: null, sourceGroupId };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDragStart(event, phaseKey, groupId) {
            dragData = { kind: 'group', type: null, id: null, fromPhase: phaseKey, instanceId: null, groupId, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `group:${groupId}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDrop(event, phaseKey, groupId) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-target');
            
            const { kind, type, id, fromPhase, instanceId, sourceGroupId } = dragData;
            if (kind !== 'item' || !type || !id) return;
            if (sourceGroupId && sourceGroupId === groupId) return;

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }

            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;

            const assignment = {
                id,
                metadata: existingMetadata || createDefaultMetadata(),
                instanceId: instanceId || createAssignmentInstanceId(),
                type
            };
            group.items = group.items || [];
            group.items.push(assignment);
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        // ============================================================
        // KILL CHAIN RENDERING
        // ============================================================
        function renderKillChain() {
            const container = document.getElementById('kill-chain');
            let html = '';
            
            for (const [superPhaseId, superPhase] of Object.entries(KILL_CHAIN)) {
                html += `
                    <div class="super-phase ${superPhaseId.toLowerCase()}">
                        <div class="super-phase-header">${superPhaseId} - ${superPhase.name}</div>
                        <div class="super-phase-content">
                `;
                
                for (const phaseId of superPhase.phases) {
                    const phaseKey = `${superPhaseId}:${phaseId}`;
                    const phaseData = state.assignments[phaseKey] || { techniques: [], capecs: [], cwes: [], customItems: [], groups: [], layout: [] };
                    
                    const techCount = state.layers.attack ? getAllPhaseItemsByType(phaseData, 'attack').length : 0;
                    const capecCount = state.layers.capec ? getAllPhaseItemsByType(phaseData, 'capec').length : 0;
                    const cweCount = state.layers.cwe ? getAllPhaseItemsByType(phaseData, 'cwe').length : 0;
                    const customCount = state.layers.custom ? getAllPhaseItemsByType(phaseData, 'custom').length : 0;
                    const totalCount = techCount + capecCount + cweCount + customCount;
                    const isHidden = (state.hideEmpty || state.compactMode) && totalCount === 0;
                    
                    ensurePhaseLayout(phaseKey, phaseData);

                    html += `
                        <div class="phase ${totalCount === 0 ? 'empty' : ''} ${isHidden ? 'hidden' : ''}" data-phase="${phaseKey}"
                             ondragover="handleDragOver(event)"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${phaseKey}')">
                            <div class="phase-header" onclick="togglePhase(this)">
                                <div class="phase-title">
                                    <button class="phase-details-btn" onclick="event.stopPropagation(); openPhaseDetails('${phaseKey}')"
                                            title="View phase details and relations"
                                        >
                                        <span class="phase-name">${formatPhaseName(phaseId)}
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M384 64C366.3 64 352 78.3 352 96C352 113.7 366.3 128 384 128L466.7 128L265.3 329.4C252.8 341.9 252.8 362.2 265.3 374.7C277.8 387.2 298.1 387.2 310.6 374.7L512 173.3L512 256C512 273.7 526.3 288 544 288C561.7 288 576 273.7 576 256L576 96C576 78.3 561.7 64 544 64L384 64zM144 160C99.8 160 64 195.8 64 240L64 496C64 540.2 99.8 576 144 576L400 576C444.2 576 480 540.2 480 496L480 416C480 398.3 465.7 384 448 384C430.3 384 416 398.3 416 416L416 496C416 504.8 408.8 512 400 512L144 512C135.2 512 128 504.8 128 496L128 240C128 231.2 135.2 224 144 224L224 224C241.7 224 256 209.7 256 192C256 174.3 241.7 160 224 160L144 160z"/></svg>
                                        </span>
                                    </button>
                                    <span class="phase-count ${totalCount === 0 ? 'zero' : ''}">${totalCount}</span>
                                </div>
                                <div class="phase-header-actions">
                                    <button class="phase-group-btn" onclick="event. stopPropagation(); createGroup('${phaseKey}')"
                                    title="Create phase group"
                                    >
                                        + <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M32 183.4C12.9 172.4 0 151.7 0 128C0 92.7 28.7 64 64 64C87.7 64 108.4 76.9 119.4 96L328.5 96C339.6 76.9 360.2 64 383.9 64C419.2 64 447.9 92.7 447.9 128C447.9 151.7 435 172.4 415.9 183.4L415.9 296.5C435 307.6 447.9 328.2 447.9 351.9C447.9 387.2 419.2 415.9 383.9 415.9C360.2 415.9 339.5 403 328.5 383.9L119.4 383.9C108.3 403 87.7 415.9 64 415.9C28.7 415.9 0 387.2 0 351.9C0 328.2 12.9 307.5 32 296.5L32 183.4zM119.4 160C113.8 169.7 105.7 177.8 96 183.4L96 296.5C105.7 302.1 113.8 310.2 119.4 319.9L328.5 319.9C334.1 310.2 342.2 302.1 351.9 296.5L351.9 183.4C342.2 177.8 334.1 169.7 328.5 160L119.4 160zM544 343.4C534.3 337.8 526.2 329.7 520.6 320L491.4 320C486.1 302.3 476.6 286.5 464 273.6L464 256L520.6 256C531.7 236.9 552.3 224 576 224C611.3 224 640 252.7 640 288C640 311.7 627.1 332.4 608 343.4L608 456.5C627.1 467.6 640 488.2 640 511.9C640 547.2 611.3 575.9 576 575.9C552.3 575.9 531.6 563 520.6 543.9L311.5 543.9C300.4 563 279.8 575.9 256.1 575.9C220.8 575.9 192.1 547.2 192.1 511.9C192.1 488.2 205 467.5 224.1 456.5L224.1 431.9L288.1 431.9L288.1 456.5C297.8 462.1 305.9 470.2 311.5 479.9L520.6 479.9C526.2 470.2 534.3 462.1 544 456.5L544 343.4z"/></svg>
                                    </button>
                                    <span class="phase-toggle">â–¼</span>
                                </div>
                            </div>
                            <div class="phase-content">
                    `;

                    for (const entry of phaseData.layout) {
                        if (entry.kind === 'item') {
                            const list = getPhaseUngroupedItems(phaseData, entry.type);
                            const assignment = list.find(a => getAssignmentInstanceId(a) === entry.instanceId);
                            if (!assignment) continue;
                            const id = getAssignmentId(assignment);
                            const meta = getAssignmentMetadata(assignment);
                            if (state.layers[entry.type]) {
                                html += renderEntityTag(entry.type, id, getEntityName(entry.type, id), meta, phaseKey, getAssignmentInstanceId(assignment), null);
                            }
                        }

                        if (entry.kind === 'group') {
                            const group = (phaseData.groups || []).find(g => g.groupId === entry.groupId);
                            if (!group) continue;
                            const collapsedClass = group.collapsed ? 'collapsed' : '';
                            const groupItems = group.items || [];
                            const safeGroupLabel = esc(group.label || 'Group');
                            const groupHeaderClick = group.editing
                                ? 'event.stopPropagation();'
                                : `toggleGroupCollapse('${phaseKey}', '${group.groupId}')`;
                            const groupDragStart = group.editing
                                ? 'event.preventDefault();'
                                : `handleGroupDragStart(event, '${phaseKey}', '${group.groupId}')`;
                            html += `
                                <div class="phase-group ${collapsedClass}" data-group-id="${escAttr(group.groupId)}" ondragover="event.stopPropagation(); handleDragOver(event)" ondragleave="event.stopPropagation(); handleDragLeave(event)" ondrop="handleGroupDrop(event, '${phaseKey}', '${group.groupId}')">
                                    <div class="phase-group-header" draggable="${group.editing ? 'false' : 'true'}" ondragstart="${groupDragStart}" ondragend="handleDragEnd(event)" onclick="${groupHeaderClick}">
                                        ${group.editing ? `
                                            <input class="metadata-input" id="group-rename-${escAttr(group.groupId)}" value="${safeGroupLabel}"
                                                onclick="event.stopPropagation()" onmousedown="event.stopPropagation()"
                                                onblur="commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value)"
                                                onkeydown="if (event.key === 'Enter') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value); } if (event.key === 'Escape') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value, true); }" />
                                        ` : `<span class="phase-group-title">${safeGroupLabel}</span>`}
                                        <span class="phase-group-count">${groupItems.length}</span>
                                        <span class="group-header-actions">
                                            <span class="group-actions">
                                                <button class="group-action-btn rename" title="Rename" onclick="event.stopPropagation(); startRenameGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                                                </button>
                                                <button class="group-action-btn delete" title="Delete Group" onclick="event.stopPropagation(); removeGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"></path></svg>
                                                </button>
                                            </span>
                                            <span class="phase-group-toggle">â–¼</span>
                                        </span>
                                    </div>
                                    <div class="phase-group-content">
                                        ${groupItems.map(item => {
                                            const type = item.type;
                                            const id = getAssignmentId(item);
                                            const meta = getAssignmentMetadata(item);
                                            const instanceId = getAssignmentInstanceId(item);
                                            if (state.layers[type]) {
                                                return renderEntityTag(type, id, getEntityName(type, id), meta, phaseKey, instanceId, group.groupId);
                                            }
                                            return '';
                                        }).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    if (totalCount === 0 && !state.compactMode) {
                        html += `<div class="list-info">Empty</div>`;
                    }
                    
                    html += `</div></div>`;
                }
                
                html += `</div></div>`;
            }
            
            container.innerHTML = html;
            renderStats();
            applyCompactLayout();
        }

        // Render a single entity tag with metadata indicators
        function renderEntityTag(type, id, name, metadata, phaseKey, instanceId, sourceGroupId = null) {
            const tagClass = TAG_CLASSES[type] || 'custom-tag';
            const score = metadata.score || 'unclassified';
            const safeId = InputSecurity.escapeHtml(id);
            const displayName = truncateAtBoundary(name || '', 500);
            const safeName = InputSecurity.escapeHtml(displayName || '');
            const safeType = InputSecurity.sanitizeAttr(type, 20);
            const safeIdAttr = InputSecurity.encodeHtmlEntities(id);
            const safePhaseKey = InputSecurity.sanitizeAttr(phaseKey);
            const safeInstanceId = InputSecurity.sanitizeAttr(instanceId || '');
            const safeGroupId = InputSecurity.sanitizeAttr(sourceGroupId || '');
            const isCompact = state.compactMode && state.view === 'killchain';
            const compactTitle = isCompact ? `title="${InputSecurity.encodeHtmlEntities(`${id} â€” ${displayName}`)}"` : '';
            let domainBadge = '';
            if (type === 'attack') {
                const domain = state.library.techniques[id]?.domain || detectDomain(id);
                const label = domain === 'enterprise' ? 'ENT' : domain === 'mobile' ? 'MOB' : domain === 'ics' ? 'ICS' : '';
                if (label) {
                    domainBadge = `<span class="domain-badge">${label}</span>`;
                }
            }
            if (type === 'custom') {
                const stixType = state.library.custom[id]?.stixType || 'x-custom';
                const stixLabel = InputSecurity.escapeHtml(stixType.replace(/-/g, ' '));
                domainBadge = `<span class="stix-type-badge">${stixLabel}</span>`;
            }
            
            // Build metadata icons
            let metaIcons = '';
            const cveEntries = getCveEntries(metadata);
            const cveList = cveEntries.map(entry => entry.id);
            const hasComment = metadata.comments && metadata.comments.trim().length > 0;
            const hasLinks = metadata.hyperlinks && metadata.hyperlinks.length > 0;
            const hasObservables = metadata.observables && metadata.observables.length > 0;
            const hasCve = cveList.length > 0;
            const hasConfidence = metadata.confidence !== null && metadata.confidence !== undefined && metadata.confidence > 0;
            
            if (hasCve || hasObservables || hasLinks || hasComment || hasConfidence) {
                metaIcons = '<div class="metadata-icons">';
                if (hasCve) {
                    const cveLabel = cveList.length === 1 ? cveList[0] : `CVE (${cveList.length})`;
                    const cveTitle = cveEntries.map(entry => {
                        const parts = [];
                        if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                        if (entry.vector) parts.push(entry.vector);
                        return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                    }).join(', ');
                    metaIcons += `<span class="meta-icon has-cve" title="${esc(cveTitle)}">
                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                    <span>${esc(cveLabel)}</span>
                </span>`;
                }
                if (hasObservables) metaIcons += '<span class="meta-icon has-observable" title="Has Observables"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg></span>';
                if (hasLinks) metaIcons += '<span class="meta-icon has-link" title="Has Links"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg></span>';
                if (hasComment) metaIcons += '<span class="meta-icon has-comment" title="Has Comments"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg></span>';
                if (hasConfidence) metaIcons += `<span class="meta-icon has-confidence" title="Confidence: ${metadata.confidence}%"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg><span>${metadata.confidence}%</span></span>`;
                metaIcons += '</div>';
            }
            
            const tagBody = isCompact ? '' : `
                    <div class="tag-body">
                        <span class="name">${safeName}</span>
                    </div>`;

            const headerMetaIcons = isCompact ? metaIcons : '';
            const footerMetaIcons = isCompact ? '' : metaIcons;

            // Collapsible inline text (non-compact only)
            // ATT&CK/CAPEC/CWE: show metadata.comments (label: "Comment")
            // STIX/custom:      show library description (label: "Description")
            let commentBlock = '';
            if (!isCompact) {
                let displayText = '';
                let toggleLabel = '';

                if (type === 'custom') {
                    const desc = (state.library.custom[id] && state.library.custom[id].description) || '';
                    displayText = desc.trim();
                    toggleLabel = 'Description';
                } else {
                    displayText = (metadata.comments || '').trim();
                    toggleLabel = 'Comment';
                }

                if (displayText.length > 0) {
                    const safeText = InputSecurity.escapeHtml(truncateAtBoundary(displayText, 500));
                    const openClass = state.showComments ? ' expanded' : '';
                    const areaOpen = state.showComments ? ' open' : '';
                    commentBlock = `
                        <div class="tag-comment-toggle${openClass}" onclick="event.stopPropagation(); toggleItemComment(this)">
                            <span class="tag-comment-chevron"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M310 233L118 41c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L226.7 240 72.7 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3z"/></svg></span>
                            ${toggleLabel}
                        </div>
                        <div class="tag-comment-area${areaOpen}" onclick="event.stopPropagation()">
                            <div class="tag-comment-content">${safeText}</div>
                        </div>`;
                }
            }

            const exploreBtn = type === 'custom' ? '' : `<button class="tag-action-btn explore" onclick="event.stopPropagation(); openEntityExplorer('${safeType}', '${safeIdAttr}')" title="Explore Entity Relationships">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M256 128C256 110.3 270.3 96 288 96L352 96C369.7 96 384 110.3 384 128L384 192C384 209.7 369.7 224 352 224L344 224L344 288L464 288C503.8 288 536 320.2 536 360L536 416L544 416C561.7 416 576 430.3 576 448L576 512C576 529.7 561.7 544 544 544L480 544C462.3 544 448 529.7 448 512L448 448C448 430.3 462.3 416 480 416L488 416L488 360C488 346.7 477.3 336 464 336L344 336L344 416L352 416C369.7 416 384 430.3 384 448L384 512C384 529.7 369.7 544 352 544L288 544C270.3 544 256 529.7 256 512L256 448C256 430.3 270.3 416 288 416L296 416L296 336L176 336C162.7 336 152 346.7 152 360L152 416L160 416C177.7 416 192 430.3 192 448L192 512C192 529.7 177.7 544 160 544L96 544C78.3 544 64 529.7 64 512L64 448C64 430.3 78.3 416 96 416L104 416L104 360C104 320.2 136.2 288 176 288L296 288L296 224L288 224C270.3 224 256 209.7 256 192L256 128z"/></svg>
                            </button>`;

            const editBtnAction = type === 'custom'
                ? `event.stopPropagation(); closeEntityModal(); openStixEditor('${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')`
                : `event.stopPropagation(); closeEntityModal(); openMetadataEditor('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')`;
            const editBtnTitle = type === 'custom' ? 'Edit STIX Item' : 'Edit Metadata';

            return `
                <div class="${tagClass}" data-score="${score}" ${compactTitle}
                     draggable="true"
                     ondragstart="handleAssignmentDragStart(event, '${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}', '${safeGroupId}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openEntityModal('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                    <span class="tag-header-row">
                        <span class="id" onclick="event.stopPropagation(); selectEntity('${safeType}', '${safeIdAttr}')">${safeId}</span>
                        ${domainBadge}
                        ${headerMetaIcons}
                        
                        <span class="tag-actions">
                            <span class="tag-action-btn remove" title="Remove" onclick="event.stopPropagation(); removeAssignment('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"/></svg>
                            </span>
                            ${exploreBtn}
                            <button class="tag-action-btn edit" onclick="${editBtnAction}" title="${editBtnTitle}">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                            </button>
                        </span>
                    </span>
                    ${tagBody}
                    ${commentBlock}
                    <div class="tag-footer">
                        ${footerMetaIcons}
                    </div>
                </div>
            `;
        }

        // ============================================================
        // RELATIONSHIP VIEW RENDERING
        // ============================================================
        function getRelationshipChainId(chain) {
            const capecId = chain.capec?.id || 'none';
            const techIds = (chain.techniques || []).map((tech) => tech.id).join(',');
            const cweIds = (chain.cwes || []).map((cwe) => cwe.id).join(',');
            return `${chain.phase.key}|${capecId}|${techIds}|${cweIds}`;
        }

        function renderRelationshipView() {
            const container = document.getElementById('relationship-chain');
            
            // Build relationship chains from assigned CAPECs
            const chains = [];

            const collectMitigations = (techIds) => {
                const mitigationMap = new Map();
                (techIds || []).forEach((techId) => {
                    const entity = state.library.techniques[techId];
                    (entity?.mitigations || []).forEach((mitigation) => {
                        if (!mitigation?.id) return;
                        if (!mitigationMap.has(mitigation.id)) {
                            mitigationMap.set(mitigation.id, {
                                id: mitigation.id,
                                name: mitigation.name || mitigation.id
                            });
                        }
                    });
                });
                return Array.from(mitigationMap.values());
            };
            
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                // For each assigned CAPEC
                const capecAssignments = getAllPhaseItemsByType(phaseData, 'capec');
                for (const capecAssignment of capecAssignments) {
                    const capecId = getAssignmentId(capecAssignment);
                    const capec = state.library.capecs[capecId];
                    if (!capec) continue;
                    
                    // Get CWEs related to this CAPEC
                    const relatedCwes = capec.cwes || [];
                    
                    // Get techniques related to this CAPEC that are in this phase
                    const assignedTechIds = getAllPhaseItemsByType(phaseData, 'attack').map(t => getAssignmentId(t));
                    const relatedTechs = (capec.techniques || []).filter(t => 
                        assignedTechIds.includes(t) || state.library.techniques[t]
                    );
                    
                    chains.push({
                        capec: { id: capecId, name: capec.name },
                        cwes: relatedCwes.slice(0, 5).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })),
                        techniques: relatedTechs.slice(0, 5).map(id => ({ id, name: state.library.techniques[id]?.name || getTechniqueName(id) })),
                        phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) },
                        mitigations: collectMitigations(relatedTechs)
                    });
                }
                
                // For assigned techniques without CAPEC, create partial chains
                const assignedCapecIds = getAllPhaseItemsByType(phaseData, 'capec').map(c => getAssignmentId(c));
                const techAssignments = getAllPhaseItemsByType(phaseData, 'attack');
                for (const techAssignment of techAssignments) {
                    const techId = getAssignmentId(techAssignment);
                    const relatedCapecs = state.techniqueToCapec[techId] || [];
                    // Only show if technique has no assigned CAPEC in this phase
                    const hasCapecInPhase = relatedCapecs.some(c => assignedCapecIds.includes(c));
                    if (!hasCapecInPhase && relatedCapecs.length > 0) {
                        const capecId = relatedCapecs[0];
                        const capec = state.library.capecs[capecId];
                        chains.push({
                            capec: capec ? { id: capecId, name: capec.name } : null,
                            cwes: capec?.cwes?.slice(0, 3).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })) || [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) },
                            mitigations: collectMitigations([techId])
                        });
                    } else if (relatedCapecs.length === 0) {
                        // Technique with no CAPEC
                        chains.push({
                            capec: null,
                            cwes: [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) },
                            mitigations: collectMitigations([techId])
                        });
                    }
                }
            }
            
            if (chains.length === 0) {
                container.innerHTML = `<div class="relationship-empty">No relationships to display.<br>Assign techniques, CAPECs, or CWEs to phases first.</div>`;
                return;
            }
            
            let html = '';
            for (const chain of chains) {
                const chainId = getRelationshipChainId(chain);
                const isExpanded = state.relationshipExpanded?.has(chainId);
                const visibleMitigations = isExpanded
                    ? (chain.mitigations || [])
                    : (chain.mitigations || []).slice(0, 5);
                const mitigationOverflow = Math.max((chain.mitigations || []).length - visibleMitigations.length, 0);
                html += `
                    <div class="relationship-row">
                        <div class="relationship-cell capec">
                            <div class="relationship-cell-header">CAPEC</div>
                            ${chain.capec ? `
                                <div class="relationship-item" onclick="selectEntity('capec', '${escAttr(chain.capec.id)}')">
                                    <span class="id capec">${esc(chain.capec.id)}</span>
                                    <span class="name">${esc(chain.capec.name)}</span>
                                </div>
                            ` : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell cwe">
                            <div class="relationship-cell-header">CWE</div>
                            ${chain.cwes.length > 0 ? chain.cwes.map(cwe => `
                                <div class="relationship-item" onclick="selectEntity('cwe', '${escAttr(cwe.id)}')">
                                    <span class="id cwe">${esc(cwe.id)}</span>
                                    <span class="name">${esc(cwe.name)}</span>
                                </div>
                            `).join('') : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell attack">
                            <div class="relationship-cell-header">ATT&CK</div>
                            ${chain.techniques.map(tech => `
                                <div class="relationship-item" onclick="selectEntity('attack', '${escAttr(tech.id)}')">
                                    <span class="id attack">${esc(tech.id)}</span>
                                    <span class="name">${esc(tech.name)}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="relationship-cell phase">
                            <div class="relationship-cell-header">Phase</div>
                            <div class="relationship-item" onclick="openPhaseDetails('${escAttr(chain.phase.key)}')">
                                <span class="id phase">${esc(chain.phase.key.split(':')[0])}</span>
                                <span class="name">${esc(chain.phase.name)}</span>
                            </div>
                        </div>
                        <div class="relationship-cell mitigation">
                            <div class="relationship-cell-header">Mitigations</div>
                            ${visibleMitigations.length > 0 ? visibleMitigations.map(mitigation => `
                                <div class="relationship-item" onclick="openMitigationExplorer('${escAttr(mitigation.id)}')" title="${escAttr(mitigation.name)}">
                                    <span class="id mitigation">${esc(mitigation.id)}</span>
                                    <span class="name">${esc(mitigation.name)}</span>
                                </div>
                            `).join('') : '<div class="list-info">â€”</div>'}
                            ${!isExpanded && mitigationOverflow > 0
                                ? `<button class="list-info relationship-more" type="button" data-action="expand-mitigations" data-chain-id="${escAttr(chainId)}">+${mitigationOverflow} more</button>`
                                : ''}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function expandRelationshipMitigations(chainId) {
            if (!chainId) return;
            if (!state.relationshipExpanded) state.relationshipExpanded = new Set();
            state.relationshipExpanded.add(chainId);
            renderRelationshipView();
        }

        const SCORE_AVERAGE_VALUES = {
            low: 2.5,
            medium: 5,
            high: 7.5,
            critical: 10
        };

        function getAverageScoreLabel(avg) {
            if (avg === null) return 'N/A';
            if (avg < 3) return 'Low';
            if (avg < 6) return 'Medium';
            if (avg < 9) return 'High';
            return 'Critical';
        }

        function buildPhaseDetails(phaseKey) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return null;

            const groupLabelByInstanceId = new Map();
            (phaseData.groups || []).forEach((group) => {
                (group.items || []).forEach((item) => {
                    const instanceId = getAssignmentInstanceId(item);
                    if (instanceId) groupLabelByInstanceId.set(instanceId, group.label || 'Group');
                });
            });

            const collectItems = (type) => getAllPhaseItemsByType(phaseData, type).map((assignment) => {
                const id = getAssignmentId(assignment);
                const metadata = getAssignmentMetadata(assignment);
                const instanceId = getAssignmentInstanceId(assignment);
                return {
                    type,
                    id,
                    name: getEntityName(type, id),
                    metadata,
                    instanceId,
                    groupLabel: instanceId ? groupLabelByInstanceId.get(instanceId) || '' : ''
                };
            });

            const itemsByType = {
                attack: collectItems('attack'),
                capec: collectItems('capec'),
                cwe: collectItems('cwe'),
                custom: collectItems('custom')
            };

            return itemsByType;
        }

        function getPhaseItemRelationships(type, id) {
            if (type === 'attack') {
                const capecs = state.techniqueToCapec[id] || [];
                const cweSet = new Set();
                capecs.forEach((capecId) => {
                    (state.library.capecs[capecId]?.cwes || []).forEach((cweId) => cweSet.add(cweId));
                });
                const mitigations = (state.library.techniques[id]?.mitigations || []).map((m) => m.id).filter(Boolean);
                return { capecs, cwes: [...cweSet], techniques: [], mitigations };
            }

            if (type === 'capec') {
                const capec = state.library.capecs[id];
                return {
                    capecs: [],
                    cwes: capec?.cwes || [],
                    techniques: capec?.techniques || [],
                    mitigations: []
                };
            }

            if (type === 'cwe') {
                const capecs = state.cweToCapec[id] || [];
                const techniqueSet = new Set();
                capecs.forEach((capecId) => {
                    (state.capecToTechnique[capecId] || []).forEach((techId) => techniqueSet.add(techId));
                });
                return { capecs, cwes: [], techniques: [...techniqueSet], mitigations: [] };
            }

            return { capecs: [], cwes: [], techniques: [], mitigations: [] };
        }

        function getPhaseAverages(itemsByType) {
            let scoreTotal = 0;
            let scoreCount = 0;
            let confidenceTotal = 0;
            let confidenceCount = 0;

            Object.values(itemsByType).flat().forEach((item) => {
                const scoreValue = SCORE_AVERAGE_VALUES[item.metadata.score || ''] || null;
                if (scoreValue !== null) {
                    scoreTotal += scoreValue;
                    scoreCount += 1;
                }
                const confidence = item.metadata.confidence;
                if (confidence !== null && confidence !== undefined && confidence > 0) {
                    confidenceTotal += confidence;
                    confidenceCount += 1;
                }
            });

            const avgScore = scoreCount ? (scoreTotal / scoreCount) : null;
            const avgConfidence = confidenceCount ? (confidenceTotal / confidenceCount) : null;

            return {
                avgScore,
                avgScoreLabel: getAverageScoreLabel(avgScore),
                avgConfidence,
                avgConfidenceLabel: avgConfidence === null ? 'N/A' : getConfidenceLabel(avgConfidence)
            };
        }

        function buildPhaseCveEntries(itemsByType) {
            const entries = [];
            Object.values(itemsByType).flat().forEach((item) => {
                const cveEntries = getCveEntries(item.metadata);
                cveEntries.forEach((entry) => {
                    entries.push({
                        id: entry.id,
                        score: entry.score,
                        vector: entry.vector,
                        parentId: item.id,
                        parentType: item.type
                    });
                });
            });
            return entries;
        }

        function buildPhaseMitigations(itemsByType) {
            const techniqueSet = new Set();

            itemsByType.attack.forEach((item) => techniqueSet.add(item.id));
            itemsByType.capec.forEach((item) => {
                (state.capecToTechnique[item.id] || state.library.capecs[item.id]?.techniques || []).forEach((techId) => {
                    techniqueSet.add(techId);
                });
            });
            itemsByType.cwe.forEach((item) => {
                const capecs = state.cweToCapec[item.id] || [];
                capecs.forEach((capecId) => {
                    (state.capecToTechnique[capecId] || []).forEach((techId) => {
                        techniqueSet.add(techId);
                    });
                });
            });

            const mitigationMap = new Map();
            techniqueSet.forEach((techId) => {
                const tech = state.library.techniques[techId];
                (tech?.mitigations || []).forEach((mitigation) => {
                    if (!mitigation?.id) return;
                    if (!mitigationMap.has(mitigation.id)) {
                        mitigationMap.set(mitigation.id, {
                            id: mitigation.id,
                            name: mitigation.name || mitigation.id,
                            description: mitigation.description || ''
                        });
                    }
                });
            });

            return Array.from(mitigationMap.values());
        }

        function renderPhaseMitigationSection(itemsByType) {
            const mitigations = buildPhaseMitigations(itemsByType);
            if (!mitigations.length) {
                return `
                    <div class="phase-details-section">
                        <div class="phase-details-section-title">Mitigations (0)</div>
                        <div class="list-info">No mitigations</div>
                    </div>
                `;
            }

            const rows = mitigations.map((mitigation) => {
                const safeId = InputSecurity.encodeHtmlEntities(mitigation.id);
                const safeName = esc(mitigation.name || mitigation.id);
                const description = mitigation.description ? `
                    <details class="phase-details-mitigation-desc">
                        <summary>Show description</summary>
                        <p>${esc(mitigation.description)}</p>
                    </details>
                ` : '';

                return `
                    <div class="phase-details-item">
                        <div class="phase-details-item-header">
                            <span class="mitigation-badge" onclick="openMitigationExplorer('${safeId}')">${esc(mitigation.id)}</span>
                            <span>${safeName}</span>
                        </div>
                        ${description}
                    </div>
                `;
            }).join('');

            return `
                <div class="phase-details-section">
                    <div class="phase-details-section-title">Mitigations (${mitigations.length})</div>
                    <div class="phase-details-list">${rows}</div>
                </div>
            `;
        }

        function renderPhaseCveSection(itemsByType) {
            const entries = buildPhaseCveEntries(itemsByType);
            if (!entries.length) {
                return '';
            }

            const rows = entries.map((entry) => {
                const scoreText = entry.score !== null && entry.score !== undefined ? String(entry.score) : 'N/A';
                const vectorText = entry.vector ? entry.vector : 'N/A';
                const parentLabel = `${entry.parentType.toUpperCase()} ${entry.parentId}`;
                return `
                    <div class="phase-details-item">
                        <div class="phase-details-item-header">
                            <span class="phase-details-item-id">${esc(entry.id)}</span>
                            <span>${esc(parentLabel)}</span>
                        </div>
                        <div class="phase-details-meta">
                            <span>Score: ${esc(scoreText)}</span>
                            <span>Vector: ${esc(vectorText)}</span>
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div class="phase-details-section">
                    <div class="phase-details-section-title">CVEs (${entries.length})</div>
                    <div class="phase-details-list">${rows}</div>
                </div>
            `;
        }

        function renderPhaseDetailsSection(title, items, phaseKey) {
            if (!items.length) {
                return '';
            }

            const rows = items.map((item) => {
                const relationships = getPhaseItemRelationships(item.type, item.id);
                const cveEntries = getCveEntries(item.metadata);
                const cveText = cveEntries.length ? cveEntries.map(entry => entry.id).join(', ') : 'None';
                const observables = item.metadata.observables || [];
                const observableCounts = {};
                observables.forEach((obs) => {
                    if (!obs?.type) return;
                    observableCounts[obs.type] = (observableCounts[obs.type] || 0) + 1;
                });
                const observableText = Object.keys(observableCounts).length
                    ? Object.entries(observableCounts).map(([type, count]) => `${type} x${count}`).join(', ')
                    : 'None';

                const scoreLabel = item.metadata.score && item.metadata.score !== 'unclassified'
                    ? item.metadata.score
                    : 'N/A';
                const confidenceLabel = item.metadata.confidence && item.metadata.confidence > 0
                    ? `${item.metadata.confidence}%`
                    : 'N/A';

                const relationChips = [];
                const addRelation = (label, values) => {
                    if (!values || !values.length) return;
                    relationChips.push(`<span class="phase-details-chip">${esc(label)}: ${esc(values.join(', '))}</span>`);
                };
                addRelation('CAPEC', relationships.capecs);
                addRelation('CWE', relationships.cwes);
                addRelation('ATT&CK', relationships.techniques);
                addRelation('Mitigation', relationships.mitigations);

                const groupBadge = item.groupLabel
                    ? `<span class="phase-details-chip">Group: ${esc(item.groupLabel)}</span>`
                    : '';

                const openAction = item.type === 'custom'
                    ? `openEntityModal('custom', '${InputSecurity.encodeHtmlEntities(item.id)}', '${InputSecurity.encodeHtmlEntities(phaseKey)}', '${InputSecurity.encodeHtmlEntities(item.instanceId || '')}')`
                    : `openEntityModal('${escAttr(item.type)}', '${escAttr(item.id)}', '${escAttr(phaseKey)}', '${escAttr(item.instanceId || '')}')`;

                return `
                    <div class="phase-details-item clickable" onclick="${openAction}">
                        <div class="phase-details-item-header">
                            <span class="phase-details-item-id">${esc(item.id)}</span>
                            <span>${esc(item.name || item.id)}</span>
                            ${groupBadge}
                        </div>
                        <div class="phase-details-meta">
                            <span>Score: ${esc(scoreLabel)}</span>
                            <span>Confidence: ${esc(confidenceLabel)}</span>
                            <span>CVEs: ${esc(cveText)}</span>
                            <span>Observables: ${esc(observableText)}</span>
                        </div>
                        ${relationChips.length ? `<div class="phase-details-relations">${relationChips.join('')}</div>` : ''}
                    </div>
                `;
            }).join('');

            return `
                <div class="phase-details-section">
                    <div class="phase-details-section-title">${esc(title)} (${items.length})</div>
                    <div class="phase-details-list">${rows}</div>
                </div>
            `;
        }

        function openPhaseDetails(phaseKey) {
            if (!phaseKey) return;
            const itemsByType = buildPhaseDetails(phaseKey);
            if (!itemsByType) return;
            const averages = getPhaseAverages(itemsByType);

            const phaseName = formatPhaseName(phaseKey.split(':')[1]);
            document.getElementById('phase-details-title').textContent = `${phaseKey} â€” ${phaseName}`;

            const summary = `
                <div class="phase-details-summary">
                    <div class="phase-details-stat">
                        <div class="phase-details-stat-label">Average Score</div>
                        <div class="phase-details-stat-value">${averages.avgScore === null ? 'N/A' : `${averages.avgScoreLabel} (${averages.avgScore.toFixed(2)})`}</div>
                    </div>
                    <div class="phase-details-stat">
                        <div class="phase-details-stat-label">Average Confidence</div>
                        <div class="phase-details-stat-value">${averages.avgConfidence === null ? 'N/A' : `${averages.avgConfidenceLabel} (${averages.avgConfidence.toFixed(0)}%)`}</div>
                    </div>
                </div>
            `;

            const sections = [
                summary,
                renderPhaseDetailsSection('ATT&CK', itemsByType.attack, phaseKey),
                renderPhaseDetailsSection('CAPEC', itemsByType.capec, phaseKey),
                renderPhaseDetailsSection('CWE', itemsByType.cwe, phaseKey),
                renderPhaseDetailsSection('STIX', itemsByType.custom, phaseKey),
                renderPhaseCveSection(itemsByType),
                renderPhaseMitigationSection(itemsByType)
            ].filter(Boolean);

            const content = sections.join('');

            document.getElementById('phase-details-content').innerHTML = content;
            document.getElementById('phase-details-modal').classList.add('visible');
        }

        function closePhaseDetails(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('phase-details-modal').classList.remove('visible');
        }

        function renderStats() {
            const statsEl = document.getElementById('stats-bar');
            
            let phasesUsed = 0;
            const techSet = new Set(), capecSet = new Set(), cweSet = new Set(), customSet = new Set();
            
            for (const phase of Object.values(state.assignments)) {
                const allTechs = getAllPhaseItemsByType(phase, 'attack');
                const allCapecs = getAllPhaseItemsByType(phase, 'capec');
                const allCwes = getAllPhaseItemsByType(phase, 'cwe');
                const allCustom = getAllPhaseItemsByType(phase, 'custom');
                if (allTechs.length + allCapecs.length + allCwes.length + allCustom.length > 0) phasesUsed++;
                allTechs.forEach(t => techSet.add(getAssignmentId(t)));
                allCapecs.forEach(c => capecSet.add(getAssignmentId(c)));
                allCwes.forEach(w => cweSet.add(getAssignmentId(w)));
                allCustom.forEach(x => customSet.add(getAssignmentId(x)));
            }
            
            const customStat = customSet.size > 0 ? `<div class="stat"><div class="stat-value">${customSet.size}</div><div class="stat-label">STIX Objects</div></div>` : '';
            statsEl.innerHTML = `
                <div class="stat"><div class="stat-value">${techSet.size}</div><div class="stat-label">Techniques</div></div>
                <div class="stat"><div class="stat-value">${capecSet.size}</div><div class="stat-label">CAPECs</div></div>
                <div class="stat"><div class="stat-value">${cweSet.size}</div><div class="stat-label">CWEs</div></div>
                ${customStat}
                <div class="stat"><div class="stat-value">${phasesUsed}/18</div><div class="stat-label">Phases</div></div>
            `;
        }

        function togglePhase(header) {
            header.parentElement.classList.toggle('minimized');
        }

        function removeAssignment(type, id, phaseKey, instanceId) {
            const key = TYPE_KEYS[type];
            if (!key) return;
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            if (!window.confirm('Remove this item?')) return;
            const assignments = phaseData[key];
            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                assignments.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                showToast('Item removed.');
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(item => getAssignmentInstanceId(item) === instanceId);
                if (gIdx !== -1) {
                    group.items.splice(gIdx, 1);
                    renderKillChain();
                    filterEntities(state.activeTab);
                    if (state.view === 'relationship') {
                        renderRelationshipView();
                    }
                    showToast('Item removed.');
                    return;
                }
            }
        }

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        function expandAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('minimized'));
        }

        function collapseAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.add('minimized'));
        }

        function clearAssignments() {
            if (!confirm('Clear all assignments from the kill chain? This cannot be undone.')) return;
            initAssignments();
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
            showToast('Cleared all assignments');
        }

        function exportJSON() {
            const exportData = {
                version: APP_VERSION,
                schema: 'killchain-export-lite',
                exportedAt: new Date().toISOString(),
                title: state.title || '',
                description: state.description || '',
                view: state.view,
                activeTab: state.activeTab,
                filters: state.filters,
                layers: state.layers,
                hideEmpty: state.hideEmpty,
                assignments: state.assignments,
                selection: state.selection,
                customLibrary: state.library.custom
            };

            // Generate embedded STIX bundle if custom items exist
            const customIds = Object.keys(state.library.custom);
            if (customIds.length > 0) {
                exportData.stixBundle = buildSTIXBundle();
            }
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const slug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'attack-chain-export';
            a.download = slug + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported JSON');
        }

        // Build STIX 2.1 bundle from custom items + phase relationships
        function buildSTIXBundle() {
            const objects = [];
            const now = new Date().toISOString();

            // Add SDOs from custom library
            for (const [id, item] of Object.entries(state.library.custom)) {
                const sdo = {
                    type: item.stixType,
                    spec_version: '2.1',
                    id: id,
                    created: item.created || now,
                    modified: item.modified || now,
                    name: item.name || ''
                };
                if (item.description) sdo.description = item.description;
                if (item.labels && item.labels.length > 0) sdo.labels = item.labels;
                objects.push(sdo);
            }

            // Generate SROs for co-located items in same phase/group
            const relationshipSet = new Set();
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;

                // Ungrouped custom items in this phase
                const ungroupedCustom = (phaseData.customItems || []).map(a => getAssignmentId(a));
                // All other ungrouped items
                const ungroupedOther = [
                    ...(phaseData.techniques || []).map(a => ({ type: 'attack', id: getAssignmentId(a) })),
                    ...(phaseData.capecs || []).map(a => ({ type: 'capec', id: getAssignmentId(a) })),
                    ...(phaseData.cwes || []).map(a => ({ type: 'cwe', id: getAssignmentId(a) }))
                ];

                // Build phase-level relationships between customâ†”custom
                for (let i = 0; i < ungroupedCustom.length; i++) {
                    for (let j = i + 1; j < ungroupedCustom.length; j++) {
                        addRelationship(objects, relationshipSet, ungroupedCustom[i], ungroupedCustom[j], phaseKey, now);
                    }
                }

                // Grouped items
                for (const group of (phaseData.groups || [])) {
                    const groupCustom = (group.items || []).filter(it => it.type === 'custom').map(it => getAssignmentId(it));
                    const groupOther = (group.items || []).filter(it => it.type !== 'custom');

                    // Customâ†”custom within group
                    for (let i = 0; i < groupCustom.length; i++) {
                        for (let j = i + 1; j < groupCustom.length; j++) {
                            addRelationship(objects, relationshipSet, groupCustom[i], groupCustom[j], phaseKey, now);
                        }
                    }
                }
            }

            // Add attack-pattern SDOs for assigned techniques (deterministic IDs)
            const techniquePhases = new Map(); // techId â†’ Set of phase names
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;
                const techs = getAllPhaseItemsByType(phaseData, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    if (!techniquePhases.has(techId)) techniquePhases.set(techId, new Set());
                    techniquePhases.get(techId).add(phaseKey.split(':')[1]);
                }
            }
            for (const [techId, phases] of techniquePhases) {
                const entity = state.library.techniques[techId];
                objects.push({
                    type: 'attack-pattern',
                    spec_version: '2.1',
                    id: techniqueStixId(techId),
                    created: now,
                    modified: now,
                    name: entity?.name || techId,
                    ...(entity?.description ? { description: entity.description } : {}),
                    external_references: [{
                        source_name: 'mitre-attack',
                        external_id: techId,
                        url: `https://attack.mitre.org/techniques/${techId.replace('.', '/')}`
                    }],
                    kill_chain_phases: [...phases].map(p => ({
                        kill_chain_name: 'unified-kill-chain',
                        phase_name: p
                    }))
                });
            }

            // Add course-of-action SDOs from mitigations linked to assigned techniques
            const mitigationMap = new Map();
            const techMitLinks = new Map();
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;
                const techs = getAllPhaseItemsByType(phaseData, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    const entity = state.library.techniques[techId];
                    if (!entity?.mitigations) continue;
                    const techSid = techniqueStixId(techId);
                    for (const m of entity.mitigations) {
                        if (!mitigationMap.has(m.id)) mitigationMap.set(m.id, m);
                        if (!techMitLinks.has(techSid)) techMitLinks.set(techSid, new Set());
                        techMitLinks.get(techSid).add(mitigationStixId(m.id));
                    }
                }
            }

            for (const [mitreId, m] of mitigationMap) {
                objects.push({
                    type: 'course-of-action',
                    spec_version: '2.1',
                    id: mitigationStixId(mitreId),
                    created: now,
                    modified: now,
                    name: m.name,
                    ...(m.description ? { description: m.description } : {}),
                    external_references: [{
                        source_name: 'mitre-attack',
                        external_id: mitreId,
                        url: `https://attack.mitre.org/mitigations/${mitreId}`
                    }]
                });
            }

            // Emit mitigates SROs
            for (const [techSid, mitSids] of techMitLinks) {
                for (const mitSid of mitSids) {
                    const key = `${mitSid}|${techSid}|mitigates`;
                    if (relationshipSet.has(key)) continue;
                    relationshipSet.add(key);
                    objects.push({
                        type: 'relationship',
                        spec_version: '2.1',
                        id: `relationship--${generateUUID()}`,
                        created: now,
                        modified: now,
                        relationship_type: 'mitigates',
                        source_ref: mitSid,
                        target_ref: techSid
                    });
                }
            }

            return {
                type: 'bundle',
                id: `bundle--${generateUUID()}`,
                spec_version: '2.1',
                objects: objects
            };
        }

        function addRelationship(objects, seen, sourceId, targetId, phaseKey, timestamp) {
            const sourceType = sourceId.split('--')[0] || '';
            const targetType = targetId.split('--')[0] || '';
            if (!sourceType || !targetType) return;

            // Look up relationship type from STIX_RELATIONSHIP_MAP
            const relType = STIX_RELATIONSHIP_MAP[sourceType]?.[targetType] || 'related-to';
            const key = `${sourceId}|${targetId}|${relType}`;
            const reverseKey = `${targetId}|${sourceId}|${relType}`;
            if (seen.has(key) || seen.has(reverseKey)) return;
            seen.add(key);

            objects.push({
                type: 'relationship',
                spec_version: '2.1',
                id: `relationship--${generateUUID()}`,
                created: timestamp,
                modified: timestamp,
                relationship_type: relType,
                source_ref: sourceId,
                target_ref: targetId,
                description: `Co-located in phase ${phaseKey}`
            });
        }

        function exportSTIXBundle() {
            const hasCustom = Object.keys(state.library.custom).length > 0;
            const hasAssignments = Object.values(state.assignments).some(phase =>
                getAllPhaseItemsByType(phase, 'attack').length > 0
            );
            if (!hasCustom && !hasAssignments) {
                showToast('No STIX objects to export');
                return;
            }
            const bundle = buildSTIXBundle();
            const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const slug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'stix-bundle';
            a.download = slug + '-stix-bundle.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported STIX 2.1 Bundle');
        }

        function triggerImportKillChain() {
            const input = document.getElementById('import-killchain-input');
            if (input) input.click();
        }

        function ensureAssignmentShape(assignments) {
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseData) continue;
                phaseData.groups = Array.isArray(phaseData.groups) ? phaseData.groups : [];
                phaseData.layout = Array.isArray(phaseData.layout) ? phaseData.layout : [];

                for (const key of ['techniques', 'capecs', 'cwes', 'customItems']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    phaseData[key] = list.map(a => migrateAssignment(a));
                }

                phaseData.groups = phaseData.groups.map(group => {
                    const items = Array.isArray(group.items) ? group.items : [];
                    return {
                        groupId: group.groupId || generateGroupId(),
                        label: sanitizeImportedString(group.label || 'Group', 80),
                        collapsed: !!group.collapsed,
                        items: items.map(item => ({
                            ...migrateAssignment(item),
                            type: item.type || 'attack'
                        }))
                    };
                });

                ensurePhaseLayout(phaseKey, phaseData);
                assignments[phaseKey] = phaseData;
            }
        }

        function ensureLibraryFallbacks(assignments) {
            for (const phaseData of Object.values(assignments)) {
                const allTechs = getAllPhaseItemsByType(phaseData, 'attack');
                const allCapecs = getAllPhaseItemsByType(phaseData, 'capec');
                const allCwes = getAllPhaseItemsByType(phaseData, 'cwe');

                for (const tech of allTechs) {
                    const id = getAssignmentId(tech);
                    if (!state.library.techniques[id]) {
                        state.library.techniques[id] = {
                            id,
                            name: getTechniqueName(id),
                            domain: detectDomain(id)
                        };
                    }
                }
                for (const capec of allCapecs) {
                    const id = getAssignmentId(capec);
                    if (!state.library.capecs[id]) {
                        state.library.capecs[id] = { id, name: id };
                    }
                }
                for (const cwe of allCwes) {
                    const id = getAssignmentId(cwe);
                    if (!state.library.cwes[id]) {
                        state.library.cwes[id] = { id, name: id };
                    }
                }
                const allCustom = getAllPhaseItemsByType(phaseData, 'custom');
                for (const custom of allCustom) {
                    const id = getAssignmentId(custom);
                    if (!state.library.custom[id]) {
                        state.library.custom[id] = {
                            id,
                            stixType: id.split('--')[0] || 'x-custom',
                            name: id,
                            description: '',
                            labels: [],
                            created: new Date().toISOString(),
                            modified: new Date().toISOString()
                        };
                    }
                }
            }
        }

        // Validation and sanitization for imported kill chain data
        const KILLCHAIN_IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024,  // 5 MB
            maxAssignmentsPerPhase: 500,
            maxHyperlinks: 50,
            maxObservables: 100,
            maxStringLength: 5000
        };

        function validateKillChainImport(data) {
            if (!data || typeof data !== 'object') {
                return { valid: false, error: 'Invalid export format: expected object' };
            }

            const assignments = data.assignments;
            if (!assignments || typeof assignments !== 'object') {
                return { valid: false, error: 'Missing or invalid assignments object' };
            }

            // Validate schema version if present
            if (hasOwn(data, 'schemaVersion') && data.schemaVersion && !/^\d+\.\d+(\.\d+)?$/.test(data.schemaVersion)) {
                return { valid: false, error: 'Invalid schema version format' };
            }

            // Validate phase keys and structure
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseKey.includes(':')) {
                    return { valid: false, error: `Invalid phase key format: ${phaseKey}` };
                }
                if (!phaseData || typeof phaseData !== 'object') {
                    return { valid: false, error: `Invalid phase data for: ${phaseKey}` };
                }

                // Check assignment counts
                for (const key of ['techniques', 'capecs', 'cwes', 'customItems']) {
                    const list = phaseData[key];
                    if (list && !Array.isArray(list)) {
                        return { valid: false, error: `${key} must be an array in ${phaseKey}` };
                    }
                    if (list && list.length > KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase) {
                        return { valid: false, error: `Too many ${key} in ${phaseKey} (max ${KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase})` };
                    }
                }

                if (phaseData.groups && !Array.isArray(phaseData.groups)) {
                    return { valid: false, error: `groups must be an array in ${phaseKey}` };
                }
            }

            // Validate optional title
            if (hasOwn(data, 'title') && data.title !== undefined && data.title !== null) {
                if (typeof data.title !== 'string') {
                    return { valid: false, error: 'title must be a string' };
                }
                if (data.title.length > (CONFIG.display?.maxTitleLength || 200)) {
                    return { valid: false, error: 'title is too long' };
                }
            }

            return { valid: true };
        }

        function sanitizeImportedString(str, maxLength = KILLCHAIN_IMPORT_LIMITS.maxStringLength) {
            if (str === null || str === undefined) return '';
            if (typeof str !== 'string') return '';
            // Normalize, remove dangerous chars, limit length
            return String(str)
                .replace(/[\x00-\x1F\x7F]/g, '')  // Control chars
                .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Script tags
                .replace(/on\w+\s*=/gi, '')  // Event handlers (onmouseover=, onerror=, etc.)
                .replace(/[\[\]\{\};"'`]/g, '')  // Blocked chars including double quotes
                .replace(/--+/g, '')  // SQL comments
                .replace(/</g, '&lt;').replace(/>/g, '&gt;')  // Encode angle brackets
                .trim()
                .slice(0, maxLength);
        }

        function sanitizeImportedAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') return null;

            // ID validation - must match expected patterns
            const id = assignment.id || assignment.entityId;
            if (typeof id !== 'string') return null;
            
            // Validate ID format (T1234, T1234.001, CAPEC-123, CWE-123)
            if (!/^(T\d{4}(\.\d{3})?|CAPEC-\d+|CWE-\d+)$/.test(id)) {
                return null;  // Reject invalid ID patterns
            }

            // Extract metadata
            const metadata = sanitizeAssignmentMetadata(assignment);

            return { id: id, metadata: metadata, instanceId: assignment.instanceId || createAssignmentInstanceId() };
        }

        function sanitizeImportedCustomAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') return null;

            const id = assignment.id || assignment.entityId;
            if (typeof id !== 'string') return null;

            // Validate STIX ID format: {type}--{uuid}
            if (!STIX_ID_PATTERN.test(id)) return null;

            // Extract and validate STIX type from ID
            const stixType = id.split('--')[0];
            if (!VALID_STIX_TYPES.has(stixType)) return null;

            // Extract metadata
            const metadata = sanitizeAssignmentMetadata(assignment);

            return { id: id, metadata: metadata, instanceId: assignment.instanceId || createAssignmentInstanceId() };
        }

        function sanitizeAssignmentMetadata(assignment) {
            const sourceMeta = assignment.metadata || assignment;
            const metadata = {
                score: 'unclassified',
                confidence: null,
                comments: '',
                cveEntries: [],
                cveId: '',
                cveIds: [],
                hyperlinks: [],
                observables: []
            };

            // Sanitize score - must be valid enum
            const validScores = ['unclassified', 'low', 'medium', 'high', 'critical'];
            if (sourceMeta.score && validScores.includes(sourceMeta.score)) {
                metadata.score = sourceMeta.score;
            }

            // Sanitize confidence - must be number 0-100
            if (typeof sourceMeta.confidence === 'number') {
                metadata.confidence = Math.max(0, Math.min(100, Math.floor(sourceMeta.confidence)));
            }

            // Sanitize CVE entries (handle cveEntries, cveIds, legacy cveId/cve + cvssVector)
            const cveEntries = [];
            if (Array.isArray(sourceMeta.cveEntries)) {
                sourceMeta.cveEntries.forEach(entry => {
                    if (!entry || typeof entry !== 'object') return;
                    const id = typeof entry.id === 'string' ? entry.id.trim().toUpperCase() : '';
                    if (!/^CVE-\d{4}-\d{4,}$/.test(id)) return;
                    let score = null;
                    if (entry.score !== null && entry.score !== undefined && entry.score !== '') {
                        const scoreValue = parseFloat(entry.score);
                        if (Number.isFinite(scoreValue) && scoreValue >= 0 && scoreValue <= 10) {
                            score = Math.round(scoreValue * 10) / 10;
                        }
                    }
                    let vector = '';
                    const vectorRaw = typeof entry.vector === 'string' ? entry.vector : (typeof entry.cvssVector === 'string' ? entry.cvssVector : '');
                    if (vectorRaw) {
                        const cvss = vectorRaw.trim();
                        if (/^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(cvss)) {
                            vector = cvss;
                        }
                    }
                    cveEntries.push({ id, score, vector });
                });
            }

            const cveValues = [];
            if (Array.isArray(sourceMeta.cveIds)) {
                cveValues.push(...sourceMeta.cveIds);
            } else if (typeof sourceMeta.cveIds === 'string') {
                cveValues.push(...sourceMeta.cveIds.split(/[\s,]+/));
            }
            const cveSource = sourceMeta.cveId || sourceMeta.cve;
            if (cveSource && typeof cveSource === 'string') {
                cveValues.push(cveSource);
            }

            const cvssSource = sourceMeta.cvssVector || sourceMeta.cvss;
            const legacyVector = (typeof cvssSource === 'string' && /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(cvssSource.trim()))
                ? cvssSource.trim()
                : '';

            const normalizedCves = [...new Set(
                cveValues
                    .map(value => (value || '').trim().toUpperCase())
                    .filter(value => /^CVE-\d{4}-\d{4,}$/.test(value))
            )];

            normalizedCves.forEach(id => {
                if (!cveEntries.some(entry => entry.id === id)) {
                    cveEntries.push({ id, score: null, vector: legacyVector });
                }
            });

            metadata.cveEntries = cveEntries;
            metadata.cveIds = cveEntries.map(entry => entry.id);
            metadata.cveId = metadata.cveIds[0] || '';

            // Sanitize comments
            if (sourceMeta.comments) {
                metadata.comments = sanitizeImportedString(sourceMeta.comments, 2000);
            }

            // Sanitize hyperlinks array
            if (Array.isArray(sourceMeta.hyperlinks)) {
                metadata.hyperlinks = sourceMeta.hyperlinks
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxHyperlinks)
                    .filter(h => h && typeof h === 'object')
                    .map(h => ({
                        label: sanitizeImportedString(h.label || '', 200),
                        url: (typeof h.url === 'string' && /^https?:\/\//.test(h.url)) 
                            ? sanitizeImportedString(h.url, 2000) 
                            : ''
                    }))
                    .filter(h => h.url);  // Keep only valid URLs
            }

            // Sanitize observables array
            if (Array.isArray(sourceMeta.observables)) {
                const validTypes = ['ipv4-addr', 'ipv6-addr', 'domain-name', 'url', 'file-hash-md5', 
                    'file-hash-sha1', 'file-hash-sha256', 'file-name', 'email-addr', 'threat-actor', 'other'];
                metadata.observables = sourceMeta.observables
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxObservables)
                    .filter(o => o && typeof o === 'object' && validTypes.includes(o.type))
                    .map(o => ({
                        type: o.type,
                        value: sanitizeImportedString(o.value || '', 500)
                    }))
                    .filter(o => o.value);
            }

            return metadata;
        }

        function sanitizeImportedData(data) {
            const sanitized = {
                assignments: createSafeObject()
            };

            // Sanitize assignments
            const assignmentSource = (data && typeof data === 'object' && data.assignments && typeof data.assignments === 'object')
                ? data.assignments
                : createSafeObject();
            for (const [phaseKey, phaseData] of Object.entries(assignmentSource)) {
                if (isDangerousObjectKey(phaseKey)) continue;
                sanitized.assignments[phaseKey] = {
                    techniques: [],
                    capecs: [],
                    cwes: [],
                    customItems: [],
                    groups: [],
                    layout: Array.isArray(phaseData.layout) ? phaseData.layout : []
                };

                for (const key of ['techniques', 'capecs', 'cwes']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    sanitized.assignments[phaseKey][key] = list
                        .map(a => sanitizeImportedAssignment(a))
                        .filter(a => a !== null);
                }

                // Sanitize custom items separately (STIX ID format)
                if (Array.isArray(phaseData.customItems)) {
                    sanitized.assignments[phaseKey].customItems = phaseData.customItems
                        .map(a => sanitizeImportedCustomAssignment(a))
                        .filter(a => a !== null);
                }

                if (Array.isArray(phaseData.groups)) {
                    sanitized.assignments[phaseKey].groups = phaseData.groups
                        .filter(g => g && typeof g === 'object')
                        .map(g => {
                            const rawItems = Array.isArray(g.items) ? g.items : [];
                            const items = rawItems
                                .map(item => {
                                    if (item.type === 'custom') {
                                        const sanitizedItem = sanitizeImportedCustomAssignment(item);
                                        if (!sanitizedItem) return null;
                                        return { ...sanitizedItem, type: 'custom' };
                                    }
                                    const sanitizedItem = sanitizeImportedAssignment(item);
                                    if (!sanitizedItem) return null;
                                    const type = ['attack', 'capec', 'cwe'].includes(item.type) ? item.type : null;
                                    if (!type) return null;
                                    return { ...sanitizedItem, type };
                                })
                                .filter(item => item && item.id && item.type);

                            return {
                                groupId: typeof g.groupId === 'string' ? g.groupId : generateGroupId(),
                                label: sanitizeImportedString(g.label || 'Group', 80),
                                collapsed: !!g.collapsed,
                                items
                            };
                        });
                }
            }

            // Sanitize optional view state (booleans/strings only)
            if (data.layers && typeof data.layers === 'object') {
                sanitized.layers = {
                    attack: !!data.layers.attack,
                    capec: !!data.layers.capec,
                    cwe: !!data.layers.cwe,
                    custom: !!data.layers.custom
                };
            }

            if (typeof data.hideEmpty === 'boolean') {
                sanitized.hideEmpty = data.hideEmpty;
            }

            if (typeof data.view === 'string' && ['killchain', 'relations'].includes(data.view)) {
                sanitized.view = data.view;
            }

            if (typeof data.activeTab === 'string' && ['attack', 'capec', 'cwe', 'custom'].includes(data.activeTab)) {
                sanitized.activeTab = data.activeTab;
            }

            // Sanitize optional title
            if (typeof data.title === 'string') {
                sanitized.title = sanitizeImportedString(data.title, CONFIG.display?.maxTitleLength || 200);
            }

            // Sanitize optional description
            if (typeof data.description === 'string') {
                sanitized.description = sanitizeImportedString(data.description, CONFIG.display?.maxKillChainDescLength || 2000);
            }

            // Sanitize custom library
            if (data.customLibrary && typeof data.customLibrary === 'object') {
                sanitized.customLibrary = createSafeObject();
                const maxItems = 500;
                let count = 0;
                for (const [id, item] of Object.entries(data.customLibrary)) {
                    if (count >= maxItems) break;
                    if (isDangerousObjectKey(id)) continue;
                    if (!STIX_ID_PATTERN.test(id)) continue;
                    if (!item || typeof item !== 'object') continue;
                    const stixType = id.split('--')[0];
                    if (!VALID_STIX_TYPES.has(stixType)) continue;

                    const entry = {
                        id: id,
                        stixType: stixType,
                        name: sanitizeImportedString(item.name || '', CONFIG.display?.maxLabelLength || 50),
                        description: sanitizeImportedString(item.description || '', CONFIG.display?.maxCustomDescLength || 2000),
                        labels: Array.isArray(item.labels)
                            ? item.labels
                                .slice(0, CONFIG.display?.maxCustomLabels || 20)
                                .filter(l => typeof l === 'string')
                                .map(l => sanitizeImportedString(l, CONFIG.display?.maxLabelLength || 50))
                            : [],
                        customTypeName: stixType === 'x-custom' && typeof item.customTypeName === 'string'
                            ? sanitizeImportedString(item.customTypeName, CONFIG.display?.maxLabelLength || 50)
                            : '',
                        created: typeof item.created === 'string' ? item.created.slice(0, 30) : new Date().toISOString(),
                        modified: typeof item.modified === 'string' ? item.modified.slice(0, 30) : new Date().toISOString()
                    };

                    // Preserve STIX spec-defined properties from stix-config.js
                    const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
                    if (typeDef) {
                        const coreKeys = new Set(['name', 'description', 'labels']);
                        const specFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !coreKeys.has(f.key));
                        for (const field of specFields) {
                            if (!field || isDangerousObjectKey(field.key)) continue;
                            if (!hasOwn(item, field.key)) continue;
                            const raw = item[field.key];
                            if (field.type === 'boolean') {
                                entry[field.key] = !!raw;
                            } else if (field.type === 'integer') {
                                const num = parseInt(raw, 10);
                                if (!isNaN(num)) entry[field.key] = num;
                            } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                                if (Array.isArray(raw)) {
                                    entry[field.key] = raw
                                        .slice(0, 50)
                                        .filter(v => typeof v === 'string')
                                        .map(v => sanitizeImportedString(v, 200));
                                }
                            } else {
                                // string, enum, open-vocab, timestamp
                                if (typeof raw === 'string') {
                                    entry[field.key] = sanitizeImportedString(raw, 2000);
                                }
                            }
                        }
                    }

                    sanitized.customLibrary[id] = entry;
                    count++;
                }
            }

            return sanitized;
        }

        function importKillChain(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check file size
            if (file.size > KILLCHAIN_IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large (max ${KILLCHAIN_IMPORT_LIMITS.maxFileSize / 1024 / 1024} MB)`);
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = parseJsonSafe(e.target.result);
                    const data = stripAngleBracketsFromJson(rawData);

                    // Validate structure before processing
                    const validation = validateKillChainImport(data);
                    if (!validation.valid) {
                        throw new Error(validation.error);
                    }

                    // Sanitize all imported data
                    const sanitized = sanitizeImportedData(data);

                    // Reset assignments and load sanitized state
                    initAssignments();
                    for (const [phaseKey, phaseData] of Object.entries(sanitized.assignments)) {
                        if (state.assignments[phaseKey]) {
                            state.assignments[phaseKey] = phaseData;
                        }
                    }

                    ensureAssignmentShape(state.assignments);
                    ensureLibraryFallbacks(state.assignments);

                    // Restore custom library from sanitized data
                    if (CONFIG.imports?.clearStixOnKillChainImport) {
                        state.library.custom = {};
                    }
                    if (sanitized.customLibrary) {
                        for (const [id, item] of Object.entries(sanitized.customLibrary)) {
                            state.library.custom[id] = item;
                        }
                    }

                    // Restore sanitized view state
                    if (typeof sanitized.title === 'string') {
                        state.title = sanitizeForStorage(sanitized.title, CONFIG.display?.maxTitleLength || 200);
                    }
                    if (typeof sanitized.description === 'string') {
                        state.description = sanitizeForStorage(sanitized.description, CONFIG.display?.maxKillChainDescLength || 2000);
                    }
                    syncTitleToDOM();
                    syncDescriptionToDOM();
                    if (sanitized.layers) state.layers = sanitized.layers;
                    if (sanitized.hideEmpty !== undefined) state.hideEmpty = sanitized.hideEmpty;
                    if (sanitized.activeTab) state.activeTab = sanitized.activeTab;
                    if (state.compactMode) state.hideEmpty = true;

                    // Apply UI state
                    document.getElementById('layer-attack').checked = !!state.layers.attack;
                    document.getElementById('layer-capec').checked = !!state.layers.capec;
                    document.getElementById('layer-cwe').checked = !!state.layers.cwe;
                    document.getElementById('layer-custom').checked = !!state.layers.custom;
                    updateHideEmptyControl();

                    if (sanitized.view) {
                        setView(sanitized.view);
                    } else {
                        renderKillChain();
                    }

                    switchTab(state.activeTab);
                    renderAll();
                    showToast('Imported kill chain');
                } catch (err) {
                    showToast('Import failed: ' + InputSecurity.escapeHtml(err.message));
                }
            };

            reader.readAsText(file);
            event.target.value = '';
        }

        function exportCSV() {
            // Build CSV with phases as header columns
            // Format: Entity Type, Entity ID, Entity Name, Score, Confidence, CVE, Comments, Phase1, Phase2, ...
            
            // Title metadata row
            const titleRow = ['Title', state.title || 'Untitled Kill Chain'];

            const headers = ['Type', 'ID', 'Name', 'Score', 'Confidence', 'CVE(s)', 'Comments', ...ALL_PHASES.map(p => formatPhaseName(p.split(':')[1]))];
            const rows = [titleRow, headers];
            
            // Collect all unique entities with their metadata
            const allTechs = new Map();  // id -> { phases: Set, metadata }
            const allCapecs = new Map();
            const allCwes = new Map();
            const allCustom = new Map();
            
            for (const [phaseKey, phase] of Object.entries(state.assignments)) {
                const techs = getAllPhaseItemsByType(phase, 'attack');
                const capecs = getAllPhaseItemsByType(phase, 'capec');
                const cwes = getAllPhaseItemsByType(phase, 'cwe');
                const customs = getAllPhaseItemsByType(phase, 'custom');

                techs.forEach(t => {
                    const id = getAssignmentId(t);
                    if (!allTechs.has(id)) {
                        allTechs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(t) });
                    }
                    allTechs.get(id).phases.add(phaseKey);
                });
                capecs.forEach(c => {
                    const id = getAssignmentId(c);
                    if (!allCapecs.has(id)) {
                        allCapecs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(c) });
                    }
                    allCapecs.get(id).phases.add(phaseKey);
                });
                cwes.forEach(w => {
                    const id = getAssignmentId(w);
                    if (!allCwes.has(id)) {
                        allCwes.set(id, { phases: new Set(), metadata: getAssignmentMetadata(w) });
                    }
                    allCwes.get(id).phases.add(phaseKey);
                });
                customs.forEach(x => {
                    const id = getAssignmentId(x);
                    if (!allCustom.has(id)) {
                        allCustom.set(id, { phases: new Set(), metadata: getAssignmentMetadata(x) });
                    }
                    allCustom.get(id).phases.add(phaseKey);
                });
            }
            
            // Helper to format confidence for CSV
            const formatConfidence = (meta) => {
                if (meta.confidence === null || meta.confidence === undefined) return '';
                return `${meta.confidence}% (${getConfidenceLabel(meta.confidence)})`;
            };

            const formatCveList = (meta) => {
                const cveEntries = getCveEntries(meta);
                if (!cveEntries.length) return '';
                return cveEntries.map(entry => {
                    const parts = [];
                    if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                    if (entry.vector) parts.push(entry.vector);
                    return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                }).join('; ');
            };
            
            // Add technique rows
            for (const [techId, data] of allTechs) {
                const tech = state.library.techniques[techId];
                const meta = data.metadata;
                const row = [
                    'ATT&CK', 
                    techId, 
                    tech?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CAPEC rows
            for (const [capecId, data] of allCapecs) {
                const capec = state.library.capecs[capecId];
                const meta = data.metadata;
                const row = [
                    'CAPEC', 
                    capecId, 
                    capec?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CWE rows
            for (const [cweId, data] of allCwes) {
                const cwe = state.library.cwes[cweId];
                const meta = data.metadata;
                const row = [
                    'CWE', 
                    cweId, 
                    cwe?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }

            // Add Custom STIX rows
            for (const [customId, data] of allCustom) {
                const item = state.library.custom[customId];
                const meta = data.metadata;
                const stixLabel = (item?.stixType || 'x-custom').replace(/-/g, ' ');
                const row = [
                    'STIX: ' + stixLabel,
                    customId,
                    item?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }

            // Add Mitigation rows (derived from assigned techniques)
            const allMitigations = new Map(); // M-id â†’ { name, phases: Set, techniqueIds: Set }
            for (const [phaseKey, phase] of Object.entries(state.assignments)) {
                const techs = getAllPhaseItemsByType(phase, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    const entity = state.library.techniques[techId];
                    if (!entity?.mitigations) continue;
                    for (const m of entity.mitigations) {
                        if (!allMitigations.has(m.id)) {
                            allMitigations.set(m.id, { name: m.name, phases: new Set(), techniqueIds: new Set() });
                        }
                        allMitigations.get(m.id).phases.add(phaseKey);
                        allMitigations.get(m.id).techniqueIds.add(techId);
                    }
                }
            }
            for (const [mitId, data] of allMitigations) {
                const row = [
                    'Mitigation',
                    mitId,
                    data.name,
                    '',
                    '',
                    '',
                    'Mitigates: ' + [...data.techniqueIds].sort().join(', ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Convert to CSV string
            // KCE-SEC-004: Prefix cells starting with formula characters to prevent injection
            const sanitizeForCsv = (value) => {
                const str = String(value);
                // Prefix with single quote if starts with formula characters
                if (/^[=+\-@\t\r]/.test(str)) {
                    return "'" + str;
                }
                return str;
            };
            
            const csvContent = rows.map(row => 
                row.map(cell => {
                    // Sanitize for formula injection, then escape quotes
                    const sanitized = sanitizeForCsv(cell);
                    const escaped = sanitized.replace(/"/g, '""');
                    return escaped.includes(',') || escaped.includes('"') || escaped.includes('\n') 
                        ? `"${escaped}"` 
                        : escaped;
                }).join(',')
            ).join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const csvSlug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'attack-chain-export';
            a.download = csvSlug + '.csv';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported CSV');
        }

        // ============================================================
        // DROPDOWN UTILS
        // ============================================================
        function toggleDropdown(id) {
            const dropdown = document.getElementById(id);
            const isOpen = dropdown.classList.contains('open');
            closeDropdowns();
            if (!isOpen) {
                dropdown.classList.add('open');
            }
        }

        function closeDropdowns() {
            document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                closeDropdowns();
            }
        });

        const relationshipContainer = document.getElementById('relationship-container');
        if (relationshipContainer) {
            relationshipContainer.addEventListener('click', (event) => {
                const target = event.target.closest('[data-action="expand-mitigations"]');
                if (!target) return;
                event.preventDefault();
                expandRelationshipMitigations(target.getAttribute('data-chain-id'));
            });
        }

        // ============================================================
        // METADATA EDITOR
        // ============================================================
        let currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };

        function openMetadataEditor(type, id, phaseKey, instanceId) {
            currentMetadataEdit = { type, id, phaseKey, instanceId };
            
            // Find the assignment
            const assignment = findAssignment(phaseKey, type, id, instanceId);
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            
            // Populate form
            document.getElementById('metadata-entity-id').textContent = id;
            
            // Score selector (renamed from confidence)
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === (metadata.score || 'unclassified'));
                opt.onclick = () => selectScore(opt.dataset.value);
            });
            
            // Confidence slider (new percentage field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = metadata.confidence || 0;
            confidenceSlider.value = confidenceValue;
            updateConfidenceLabel(confidenceValue);
            confidenceSlider.oninput = (e) => updateConfidenceLabel(parseInt(e.target.value));
            
            // CVE entries
            const cveListEl = document.getElementById('cve-list');
            cveListEl.innerHTML = '';
            const cveEntries = getCveEntries(metadata);
            if (cveEntries.length) {
                cveEntries.forEach(entry => addCveRow(entry.id, entry.score, entry.vector));
            }
            document.getElementById('meta-cve-list-error').textContent = '';
            
            // Comments
            document.getElementById('meta-comments').value = metadata.comments || '';
            
            // Hyperlinks
            const hyperlinkList = document.getElementById('hyperlink-list');
            hyperlinkList.innerHTML = '';
            (metadata.hyperlinks || []).forEach((link, i) => {
                addHyperlinkRow(link.label, link.url);
            });
            
            // Observables
            const observableList = document.getElementById('observable-list');
            observableList.innerHTML = '';
            (metadata.observables || []).forEach((obs, i) => {
                addObservableRow(obs.type, obs.value);
            });
            
            // Show modal
            document.getElementById('metadata-editor-modal').classList.add('visible');
        }

        function closeMetadataEditor(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('metadata-editor-modal').classList.remove('visible');
            currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };
        }

        function selectScore(value) {
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === value);
            });
        }

        function updateConfidenceLabel(value) {
            const label = document.getElementById('confidence-label');
            const labelText = getConfidenceLabel(value);
            const labelClass = getConfidenceClass(value);
            label.textContent = value === 0 ? 'Unknown' : `${value}% (${labelText})`;
            label.className = `confidence-label ${labelClass}`;
        }

        function addCveRow(id = '', score = '', vector = '') {
            const list = document.getElementById('cve-list');
            const row = document.createElement('div');
            row.className = 'cve-item';

            const idInput = document.createElement('input');
            idInput.type = 'text';
            idInput.className = 'metadata-input cve-id-input';
            idInput.placeholder = 'CVE-2024-12345';
            idInput.value = id || '';

            const scoreInput = document.createElement('input');
            scoreInput.type = 'text';
            scoreInput.className = 'metadata-input cve-score-input';
            scoreInput.placeholder = 'Score (0-10)';
            scoreInput.value = (score === null || score === undefined) ? '' : String(score);

            const vectorInput = document.createElement('input');
            vectorInput.type = 'text';
            vectorInput.className = 'metadata-input cve-vector-input';
            vectorInput.placeholder = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H';
            vectorInput.value = vector || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(idInput);
            row.appendChild(scoreInput);
            row.appendChild(vectorInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function addHyperlinkRow(label = '', url = '') {
            const list = document.getElementById('hyperlink-list');
            const row = document.createElement('div');
            row.className = 'hyperlink-item';
            const labelInput = document.createElement('input');
            labelInput.type = 'text';
            labelInput.className = 'metadata-input';
            labelInput.placeholder = 'Label';
            labelInput.value = label || '';

            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.className = 'metadata-input';
            urlInput.placeholder = 'https://...';
            urlInput.value = url || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(labelInput);
            row.appendChild(urlInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function addObservableRow(type = 'ipv4-addr', value = '') {
            const list = document.getElementById('observable-list');
            const row = document.createElement('div');
            row.className = 'observable-item';
            const select = document.createElement('select');
            select.className = 'metadata-select';
            OBSERVABLE_TYPES.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.label;
                if (t.value === type) opt.selected = true;
                select.appendChild(opt);
            });

            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.className = 'metadata-input';
            valueInput.placeholder = 'Value';
            valueInput.value = value || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(select);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function saveMetadata() {
            const { type, id, phaseKey, instanceId } = currentMetadataEdit;
            if (!type || !id || !phaseKey) return;
            
            // Get score (renamed from confidence)
            const selectedScore = document.querySelector('#score-selector .score-option.selected');
            const score = selectedScore ? selectedScore.dataset.value : 'unclassified';
            
            // Get confidence percentage (new field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = parseInt(confidenceSlider.value) || 0;
            const confidence = confidenceValue === 0 ? null : confidenceValue;
            
            // Get CVE entries (with validation)
            const cveError = document.getElementById('meta-cve-list-error');
            cveError.textContent = '';
            const cveEntries = [];
            const cveEntryMap = new Map();
            let hasInvalidCve = false;
            document.querySelectorAll('#cve-list .cve-item').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const idRaw = sanitizeForStorage(inputs[0].value, 50).toUpperCase();
                const scoreRaw = sanitizeForStorage(inputs[1].value, 10);
                const vectorRaw = sanitizeForStorage(inputs[2].value, 200);

                inputs.forEach(input => input.classList.remove('invalid'));

                if (!idRaw && !scoreRaw && !vectorRaw) {
                    return;
                }

                if (!idRaw || !InputSecurity.validators.cveId(idRaw).valid) {
                    inputs[0].classList.add('invalid');
                    hasInvalidCve = true;
                    return;
                }

                let score = null;
                if (scoreRaw) {
                    const scoreValue = parseFloat(scoreRaw);
                    if (!Number.isFinite(scoreValue) || scoreValue < 0 || scoreValue > 10) {
                        inputs[1].classList.add('invalid');
                        hasInvalidCve = true;
                        return;
                    }
                    score = Math.round(scoreValue * 10) / 10;
                }

                let vector = '';
                if (vectorRaw) {
                    if (!InputSecurity.validators.cvssVector(vectorRaw).valid) {
                        inputs[2].classList.add('invalid');
                        hasInvalidCve = true;
                        return;
                    }
                    vector = vectorRaw;
                }

                if (!cveEntryMap.has(idRaw)) {
                    const entry = { id: idRaw, score, vector };
                    cveEntryMap.set(idRaw, entry);
                    cveEntries.push(entry);
                } else {
                    const existing = cveEntryMap.get(idRaw);
                    if (existing.score === null && score !== null) existing.score = score;
                    if (!existing.vector && vector) existing.vector = vector;
                }
            });

            if (hasInvalidCve) {
                cveError.textContent = 'Fix invalid CVE entries (format, score 0-10, or CVSS vector).';
                return;
            }
            
            // Get comments
            const comments = sanitizeForStorage(document.getElementById('meta-comments').value, 2000);
            
            // Get hyperlinks (with validation)
            const hyperlinks = [];
            document.querySelectorAll('#hyperlink-list .hyperlink-item').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const label = sanitizeForStorage(inputs[0].value, 100);
                const url = sanitizeForStorage(inputs[1].value, 500);
                if (label && url) {
                    if (InputSecurity.validators.url(url).valid) {
                        hyperlinks.push({ label, url });
                    }
                }
            });
            
            // Get observables (with validation)
            const observables = [];
            let hasInvalidObservable = false;
            document.querySelectorAll('#observable-list .observable-item').forEach(row => {
                const select = row.querySelector('select');
                const input = row.querySelector('input');
                const obsType = select.value;
                const obsValue = sanitizeForStorage(input.value, 500);
                
                if (obsValue) {
                    const validation = InputSecurity.validateObservable(obsType, obsValue);
                    if (validation.valid) {
                        observables.push({ type: obsType, value: obsValue });
                        input.classList.remove('invalid');
                    } else {
                        input.classList.add('invalid');
                        hasInvalidObservable = true;
                    }
                }
            });
            
            if (hasInvalidObservable) {
                showToast('Fix invalid observable values');
                return;
            }
            
            // Build new metadata
            const cveIds = cveEntries.map(entry => entry.id);
            const newMetadata = {
                score,
                confidence,
                cveEntries,
                cveId: cveIds[0] || '',
                cveIds,
                comments,
                hyperlinks,
                observables
            };
            
            // Update the assignment
            updateAssignmentMetadata(phaseKey, type, id, newMetadata, instanceId);
            
            // Close and re-render
            closeMetadataEditor();
            renderKillChain();
            showToast('Metadata saved');
        }

        // ============================================================
        // USAGE GUIDE
        // ============================================================
        function showUsageGuide() {
            document.getElementById('usage-guide-modal').classList.add('visible');
        }

        function closeUsageGuide(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('usage-guide-modal').classList.remove('visible');
        }

        // ============================================================
        // CHANGELOG MODAL
        // ============================================================
        async function showChangelog() {
            const modal = document.getElementById('changelog-modal');
            const content = document.getElementById('changelog-content');
            modal.classList.add('visible');
            
            try {
                if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
                    content.textContent = 'Changelog preview is unavailable in file:// mode. Open via localhost to load CHANGELOG.md dynamically.';
                    return;
                }
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                content.textContent = text;
            } catch (e) {
                content.textContent = 'Error loading changelog: ' + e.message;
            }
        }

        function closeChangelog(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('changelog-modal').classList.remove('visible');
        }

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeUsageGuide();
                closeChangelog();
                closeEntityModal();
                closeMetadataEditor();
            }
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderAll() {
            filterEntities('attack');
            filterEntities('capec');
            filterEntities('cwe');
            filterEntities('custom');
            renderKillChain();
            syncTitleToDOM();
            syncDescriptionToDOM();
        }

        // ============================================================
        // LEAVE SITE CONFIRMATION
        // ============================================================
        function enableLeaveSiteConfirmation() {
            window.addEventListener('beforeunload', (e) => {
                e.preventDefault();
                e.returnValue = '';
                return '';
            });
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        initThemeControls();
        logLocalIframeIPCSplash('index');
        updateLoadingContextInfo();
        window.addEventListener('storage', (e) => {
            if (e.key === THEME_STORAGE_KEYS.mode) {
                syncThemeFromStorage();
            }
        });
        if (typeof CONFIG !== 'undefined') {
            if (CONFIG.navigation?.confirmOnLeave !== false) {
                enableLeaveSiteConfirmation();
            }
        } else {
            enableLeaveSiteConfirmation();
        }
        initEmbeddedMessageBridge();
        applyNavigationConfig();
        initAssignments();
        initCompactMode();
        window.addEventListener('resize', () => {
            if (state.compactMode) {
                applyCompactLayout();
            }
        });
        applyInputGuards();
        initGlobalSearch();
        populateStixTypeDropdown();
        loadVersion();
        loadData();
    </script>
</body>
</html>
