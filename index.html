<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AttackFlow - Kill Chain Editor</title>
    <script src="config.js"></script>
    <style>
        :root {
            --phase-in: #10b981;
            --phase-through: #06b6d4;
            --phase-out: #ef4444;
            --bg-dark: #1a1a1a;
            --bg-card: #242424;
            --bg-phase: #2d2d2d;
            --text-primary: #e5e5e5;
            --text-secondary: #a3a3a3;
            --border-color: #404040;
            --accent: #71717a;
            --capec-color: #8b5cf6;
            --cwe-color: #f59e0b;
            --attack-color: #3b82f6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
            flex-wrap: wrap;
        }

        .header-title {
            font-size: 1rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
        }

        .version-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 2px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            transition: all 0.15s;
        }

        .version-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .help-link {
            color: var(--text-secondary);
            text-decoration: none;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-phase);
            border-radius: 50%;
            font-weight: 600;
            transition: all 0.15s;
        }

        .help-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 4px;
            background: var(--bg-phase);
            border-radius: 4px;
            padding: 2px;
        }

        .view-tab-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px;
            border-radius: 3px;
        }

        .view-tab-group.active {
            background: rgba(113, 113, 122, 0.25);
        }

        .view-btn {
            padding: 5px 12px;
            border: none;
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .view-btn.active {
            background: var(--accent);
            color: var(--text-primary);
        }

        .view-breadcrumb {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .breadcrumb-sep {
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .view-btn.view-btn-crumb {
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid transparent;
        }

        .view-btn.view-btn-crumb.active {
            background: rgba(113, 113, 122, 0.35);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        /* Layer Toggles */
        .layer-toggles {
            display: flex;
            gap: 12px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .layer-toggle input {
            display: none;
        }

        .layer-toggle .checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .layer-toggle input:checked + .checkbox {
            background: var(--accent);
            border-color: var(--accent);
        }

        .layer-toggle input:checked + .checkbox::after {
            content: 'âœ“';
            font-size: 10px;
            color: white;
        }

        .layer-toggle.attack .checkbox { border-color: var(--attack-color); }
        .layer-toggle.attack input:checked + .checkbox { background: var(--attack-color); border-color: var(--attack-color); }
        .layer-toggle.capec .checkbox { border-color: var(--capec-color); }
        .layer-toggle.capec input:checked + .checkbox { background: var(--capec-color); border-color: var(--capec-color); }
        .layer-toggle.cwe .checkbox { border-color: var(--cwe-color); }
        .layer-toggle.cwe input:checked + .checkbox { background: var(--cwe-color); border-color: var(--cwe-color); }

        /* Buttons */
        .btn {
            padding: 5px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover { background: #3a3a3a; }
        .btn.active { background: var(--accent); border-color: var(--accent); }

        /* Dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 100px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .dropdown.open .dropdown-content { display: block; }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 0.7rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.15s;
        }

        .dropdown-item:hover { background: var(--bg-phase); }
        .dropdown-item.active { background: var(--bg-phase); color: var(--text-primary); }
        .dropdown-item:first-child { border-radius: 4px 4px 0 0; }
        .dropdown-item:last-child { border-radius: 0 0 4px 4px; }

        /* Main Layout */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .explorer-container {
            flex: 1;
            display: none;
            background: var(--bg-dark);
        }

        .explorer-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        .app.explorer-view .sidebar,
        .app.explorer-view .content {
            display: none;
        }

        .app.explorer-view .header-controls {
            display: none;
        }

        .app.explorer-view .explorer-container {
            display: block;
        }

        .app.sidebar-collapsed .sidebar {
            width: 44px;
        }

        .app.sidebar-collapsed .sidebar-tabs,
        .app.sidebar-collapsed .sidebar-content {
            display: none;
        }

        /* Sidebar */
        .sidebar {
            width: 340px;
            background: var(--bg-card);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.2s ease;
        }

        .sidebar-toggle {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sidebar-toggle:hover {
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .sidebar-toggle-icon {
            font-size: 0.7rem;
            transition: transform 0.2s;
            display: inline-block;
        }

        .sidebar-toggle-icon svg {
            width: 14px;
            height: 14px;
            display: block;
            fill: currentColor;
        }

        .app.sidebar-collapsed .sidebar-toggle-icon { transform: rotate(180deg); }

        .content-title-wrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px 8px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
        }

        .sidebar-tab:hover { color: var(--text-primary); }
        .sidebar-tab.active { color: var(--text-primary); border-bottom-color: var(--accent); }
        .sidebar-tab.attack.active { border-bottom-color: var(--attack-color); }
        .sidebar-tab.capec.active { border-bottom-color: var(--capec-color); }
        .sidebar-tab.cwe.active { border-bottom-color: var(--cwe-color); }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .tab-panel.active { display: flex; }

        /* Search & Filters */
        .search-bar {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .search-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .search-input:focus { outline: none; border-color: var(--accent); }

        .filter-row {
            display: flex;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 3px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .filter-btn.active { background: var(--accent); border-color: var(--accent); color: var(--text-primary); }

        /* Entity List */
        .entity-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .entity-item {
            display: flex;
            flex-direction: column;
            padding: 8px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .entity-item:hover { border-color: var(--accent); }
        .entity-item.selected { border-color: var(--accent); background: rgba(113, 113, 122, 0.2); }
        .entity-item.assigned { opacity: 0.5; border-style: dashed; }
        .entity-item.dragging { opacity: 0.4; transform: scale(0.95); }
        .entity-item[draggable="true"] { cursor: grab; }
        .entity-item[draggable="true"]:active { cursor: grabbing; }

        .entity-item.attack { border-left: 3px solid var(--attack-color); }
        .entity-item.capec { border-left: 3px solid var(--capec-color); }
        .entity-item.cwe { border-left: 3px solid var(--cwe-color); }

        .entity-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .entity-id {
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .entity-item.attack .entity-id { color: var(--attack-color); }
        .entity-item.capec .entity-id { color: var(--capec-color); }
        .entity-item.cwe .entity-id { color: var(--cwe-color); }

        .entity-name {
            font-size: 0.75rem;
            color: var(--text-primary);
            margin-top: 2px;
        }

        .entity-meta {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .entity-badge {
            font-size: 0.6rem;
            padding: 1px 5px;
            border-radius: 2px;
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .entity-badge.severity-high { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .entity-badge.severity-medium { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .entity-badge.severity-low { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .list-info {
            padding: 8px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        /* Import Section */
        .import-section {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .import-btns {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .import-btn {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--bg-phase);
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .import-btn:hover { border-color: var(--attack-color); color: var(--text-primary); }

        /* Main Content */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .view-controls {
            display: flex;
            gap: 6px;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 16px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
            padding: 4px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .stat-value { font-size: 1rem; font-weight: bold; }
        .stat-label { font-size: 0.6rem; color: var(--text-secondary); text-transform: uppercase; }

        /* Kill Chain View */
        .kill-chain-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }

        .kill-chain-container.hidden { display: none; }

        .kill-chain {
            display: flex;
            gap: 8px;
            min-height: 100%;
        }

        .super-phase {
            flex: 1;
            min-width: 240px;
            display: flex;
            flex-direction: column;
        }

        .super-phase-header {
            text-align: center;
            padding: 8px;
            border-radius: 4px 4px 0 0;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-left: 3px solid;
        }

        .super-phase.in .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-in); }
        .super-phase.through .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-through); }
        .super-phase.out .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-out); }

        .super-phase-content {
            background: var(--bg-card);
            border-radius: 0 0 4px 4px;
            padding: 6px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: 1px solid var(--border-color);
            border-top: none;
        }

        .phase {
            background: var(--bg-phase);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .phase.empty { opacity: 0.4; }
        .phase.hidden { display: none; }
        .phase.drop-target { border-color: var(--accent); background: rgba(113, 113, 122, 0.15); }
        .phase.minimized .phase-content { display: none; }

        .phase-header {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
        }

        .phase-header:hover { background: rgba(255, 255, 255, 0.03); }

        .phase-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .phase-header-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .phase-name { font-weight: 500; font-size: 1rem; }

        .phase-count {
            background: var(--border-color);
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 600;
        }

        .phase-count.zero { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); }

        .phase-toggle {
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 2px;
            cursor: pointer;
        }

        .phase-group-btn:hover { color: var(--text-primary); border-color: var(--accent); }

        .phase.minimized .phase-toggle { transform: rotate(-90deg); }

        .phase-content {
            padding: 4px 6px 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .phase-group {
            border: 1px dashed rgba(113, 113, 122, 0.35);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(17, 24, 39, 0.25);
        }

        .phase-group.collapsed .phase-group-content { display: none; }

        .phase-group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.4);
            cursor: pointer;
        }

        .phase-group-title { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
        .phase-group-count { font-size: 0.65rem; color: var(--text-secondary); }
        .phase-group-toggle {
            display: inline-block;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group.collapsed .phase-group-toggle { transform: rotate(-90deg); }

        .group-header-actions {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .group-actions {
            display: inline-flex;
            gap: 4px;
        }

        .group-action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .group-action-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .group-action-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .group-action-btn.delete:hover { border-color: #f87171; color: #f87171; }

        .phase-group-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        /* Technique Tag */
        .technique-tag {
            display: inline-flex;
            flex-direction: column;
            padding: 4px 6px;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .technique-tag:hover { border-color: var(--attack-color); background: rgba(59, 130, 246, 0.25); }

        .technique-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .technique-tag .id {
            font-family: monospace;
            font-weight: 600;
            color: #fff;
            background: rgba(59, 130, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .technique-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .technique-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .technique-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .technique-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .technique-tag:hover .remove { opacity: 1; }

        /* CWE Tag */
        .cwe-tag {
            display: inline-flex;
            flex-direction: column;
            padding: 4px 6px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .cwe-tag:hover { border-color: var(--cwe-color); background: rgba(245, 158, 11, 0.2); }

        .cwe-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .cwe-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(245, 158, 11, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .cwe-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .cwe-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .cwe-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .cwe-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .cwe-tag:hover .remove { opacity: 1; }

        /* CAPEC Tag */
        .capec-tag {
            display: inline-flex;
            flex-direction: column;
            padding: 4px 6px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .capec-tag:hover { border-color: var(--capec-color); background: rgba(139, 92, 246, 0.2); }

        .capec-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .domain-badge {
            font-size: 0.55rem;
            padding: 1px 4px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            background: var(--bg-phase);
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        .capec-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(139, 92, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .capec-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .capec-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .capec-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .capec-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .remove svg {
            fill: #ff6565f7;
        }

        .capec-tag:hover .remove { opacity: 1; }

        .technique-tag .name,
        .capec-tag .name,
        .cwe-tag .name {
            flex: 1;
            min-width: 0;
            font-size: 0.8rem;
        }

        .tag-actions {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .tag-body {
            margin-top: 4px;
        }

        .tag-footer {
            margin-top: 4px;
        }

        .tag-action-btn {
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text-secondary);
            font-size: 0.7rem;
            padding: 3px 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            line-height: 1.1;
        }

        .tag-action-btn:hover {
            color: var(--text-primary);
            border-color: var(--accent);
            background: rgba(113, 113, 122, 0.25);
        }

        .tag-action-btn.explore { color: #93c5fd; }
        .tag-action-btn.edit { color: #fcd34d; }

        /* ============================================================
           SCORE RIBBONS & METADATA INDICATORS
           ============================================================ */
        
        /* Score ribbon (left border only - preserves framework background colors) */
        .technique-tag[data-score="low"],
        .capec-tag[data-score="low"],
        .cwe-tag[data-score="low"] {
            border-left: 3px solid #22c55e;
        }
        
        .technique-tag[data-score="medium"],
        .capec-tag[data-score="medium"],
        .cwe-tag[data-score="medium"] {
            border-left: 3px solid #eab308;
        }
        
        .technique-tag[data-score="high"],
        .capec-tag[data-score="high"],
        .cwe-tag[data-score="high"] {
            border-left: 3px solid #f97316;
        }
        
        .technique-tag[data-score="critical"],
        .capec-tag[data-score="critical"],
        .cwe-tag[data-score="critical"] {
            border-left: 3px solid #ef4444;
        }

        /* Metadata indicators - displayed below title */
        .metadata-icons {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }
        
        .metadata-icons .meta-icon {
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--meta-default-bg);
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
            color: var(--meta-default-fg);
            white-space: nowrap;
            gap: 4px;
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .meta-icon svg,
        .tag-action-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            stroke: currentColor;
            flex: 0 0 auto;
        }

        .tag-action-btn:hover svg {
            fill: currentColor;
            stroke: currentColor;
        }
        
        .metadata-icons .meta-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .metadata-icons .meta-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .metadata-icons .meta-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .metadata-icons .meta-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .metadata-icons .meta-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }

        /* Score Legend */
        .score-legend {
            display: flex;
            gap: 12px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .metadata-legend {
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .metadata-legend .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .legend-icon {
            width: 14px;
            height: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            background: var(--meta-default-bg);
            color: var(--meta-default-fg);
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .legend-icon svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .legend-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .legend-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .legend-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .legend-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .legend-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* ============================================================
           METADATA EDITOR MODAL
           ============================================================ */
        .metadata-editor-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }
        
        .metadata-editor-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .metadata-editor {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        
        .metadata-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .metadata-editor-title {
            font-size: 1rem;
            font-weight: 600;
        }
        
        .metadata-editor-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 4px;
        }
        
        .metadata-editor-close:hover { color: var(--text-primary); }
        
        .metadata-editor-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .metadata-section {
            margin-bottom: 16px;
        }
        
        .metadata-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .metadata-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
        }
        
        .metadata-input:focus {
            outline: none;
            border-color: var(--attack-color);
        }
        
        .metadata-input.invalid {
            border-color: #ef4444;
        }
        
        .metadata-input-error {
            font-size: 0.7rem;
            color: #ef4444;
            margin-top: 4px;
        }
        
        .metadata-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .metadata-select {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        /* Score selector */
        .score-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .score-option {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }
        
        .score-option:hover {
            border-color: var(--text-secondary);
        }
        
        .score-option.selected {
            border-color: var(--attack-color);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .score-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        /* Confidence slider */
        .confidence-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .confidence-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            outline: none;
        }
        
        .confidence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .confidence-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .confidence-value {
            min-width: 80px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-primary);
        }
        
        .confidence-label {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .confidence-label.unknown { background: rgba(107, 114, 128, 0.3); color: #9ca3af; }
        .confidence-label.low { background: rgba(239, 68, 68, 0.3); color: #fca5a5; }
        .confidence-label.medium { background: rgba(251, 191, 36, 0.3); color: #fcd34d; }
        .confidence-label.high { background: rgba(34, 197, 94, 0.3); color: #86efac; }
        
        /* Observable list */
        .observable-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .observable-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .observable-item select {
            width: 140px;
            flex-shrink: 0;
        }
        
        .observable-item input {
            flex: 1;
        }
        
        .observable-remove {
            background: none;
            border: none;
            color: #ef4444;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
        }
        
        .add-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: var(--bg-phase);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .add-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }
        
        /* Hyperlink list */
        .hyperlink-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .hyperlink-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .hyperlink-item input:first-child {
            width: 120px;
            flex-shrink: 0;
        }
        
        .hyperlink-item input:nth-child(2) {
            flex: 1;
        }
        
        .metadata-editor-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
        }
        
        .metadata-btn {
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .metadata-btn-cancel {
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .metadata-btn-cancel:hover {
            background: var(--bg-dark);
        }
        
        .metadata-btn-save {
            background: var(--attack-color);
            border: 1px solid var(--attack-color);
            color: white;
        }
        
        .metadata-btn-save:hover {
            background: #2563eb;
        }

        /* Relationship View */
        .relationship-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
            display: none;
        }

        .relationship-container.visible { display: block; }

        .relationship-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .relationship-header-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .relationship-header-item .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .relationship-header-item .dot.capec { background: var(--capec-color); }
        .relationship-header-item .dot.cwe { background: var(--cwe-color); }
        .relationship-header-item .dot.attack { background: var(--attack-color); }
        .relationship-header-item .dot.phase { background: var(--accent); }

        .relationship-arrow {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .relationship-chain {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .relationship-wrapper {
            display: flex;
            gap: 12px;
        }

        .flow-arrow {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 16px 8px;
            min-height: 100px;
        }

        .flow-arrow-line {
            width: 2px;
            flex: 1;
            background: linear-gradient(to bottom, var(--phase-in), var(--phase-through), var(--phase-out));
            border-radius: 1px;
            position: relative;
        }

        .flow-arrow-head {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 12px solid var(--phase-out);
            margin-top: -1px;
        }

        .flow-arrow-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin-bottom: 8px;
        }

        .relationship-row {
            display: flex;
            align-items: stretch;
            gap: 4px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .relationship-cell {
            flex: 1;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border-right: 1px solid var(--border-color);
            min-width: 0;
        }

        .relationship-cell:last-child { border-right: none; }

        .relationship-cell-header {
            font-size: 0.6rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .relationship-cell.capec { background: rgba(139, 92, 246, 0.05); }
        .relationship-cell.cwe { background: rgba(245, 158, 11, 0.05); }
        .relationship-cell.attack { background: rgba(59, 130, 246, 0.05); }
        .relationship-cell.phase { background: rgba(113, 113, 122, 0.05); }

        .relationship-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .relationship-item:hover { background: var(--bg-dark); }

        .relationship-item .id {
            font-family: monospace;
            font-weight: 600;
        }

        .relationship-item .id.capec { color: var(--capec-color); }
        .relationship-item .id.cwe { color: var(--cwe-color); }
        .relationship-item .id.attack { color: var(--attack-color); }
        .relationship-item .id.phase { color: var(--accent); }

        .relationship-item .name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .relationship-empty {
            padding: 30px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Detail Panel */
        .detail-panel {
            width: 320px;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .detail-panel.visible { display: flex; }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
        }

        .detail-header-content {
            flex: 1;
            min-width: 0;
        }

        .detail-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .detail-close:hover { color: var(--text-primary); }

        .detail-id {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .detail-id.attack { color: var(--attack-color); }
        .detail-id.capec { color: var(--capec-color); }
        .detail-id.cwe { color: var(--cwe-color); }

        .detail-name {
            font-size: 0.95rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .detail-section {
            margin-bottom: 16px;
        }

        .detail-section h4 {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .detail-section p {
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .detail-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .detail-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 8px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .detail-list-item:hover { background: var(--bg-dark); }

        .detail-list-item .id { font-family: monospace; font-weight: 600; }
        .detail-list-item .id.attack { color: var(--attack-color); }
        .detail-list-item .id.capec { color: var(--capec-color); }
        .detail-list-item .id.cwe { color: var(--cwe-color); }

        /* Legend */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 8px 16px;
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-color.attack { background: var(--attack-color); }
        .legend-color.capec { background: var(--capec-color); }
        .legend-color.cwe { background: var(--cwe-color); }
        .legend-color.in { background: var(--phase-in); }
        .legend-color.through { background: var(--phase-through); }
        .legend-color.out { background: var(--phase-out); }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 18px;
            background: var(--bg-card);
            border: 1px solid var(--accent);
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show { opacity: 1; transform: translateY(0); }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text-primary); }

        .modal-body {
            padding: 16px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .modal-wide {
            max-width: 700px;
            max-height: 80vh;
        }

        .changelog-body {
            white-space: pre-wrap;
            font-family: var(--font-mono, 'SF Mono', Consolas, monospace);
            font-size: 0.8rem;
            background: var(--bg-dark);
            border-radius: 4px;
            padding: 16px;
            max-height: 60vh;
        }

        .guide-section {
            margin-bottom: 16px;
        }

        .guide-section h4 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .guide-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .guide-section li {
            margin-bottom: 4px;
        }

        .guide-key {
            display: inline-block;
            background: var(--bg-phase);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            margin: 0 2px;
        }

        .guide-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading.hidden { display: none; }

        .loading-text {
            color: var(--text-primary);
            font-size: 1rem;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Loading data...</div>
    </div>

    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="header-brand">
                    <div class="header-title">AttackFlow</div>
                    <div class="header-meta">
                        <a href="#" class="version-link" id="app-version" title="View changelog" onclick="showChangelog(); return false;">v2.4.2</a>
                        <a href="#" class="help-link" onclick="showUsageGuide(); return false;" title="Usage guide">?</a>
                    </div>
                </div>
                <div class="header-nav">
                    <div class="view-toggle">
                        <div class="view-tab-group active" id="view-editor-group">
                            <button class="view-btn active" id="view-killchain" onclick="setView('killchain')">Kill Chain Editor</button>
                            <span class="view-breadcrumb">
                                <span class="breadcrumb-sep">â€º</span>
                                <button class="view-btn view-btn-crumb" id="view-relationship" onclick="setView('relationship')">Relationships</button>
                            </span>
                        </div>
                        <div class="view-tab-group" id="view-explorer-group">
                            <button class="view-btn" id="view-explorer" onclick="setView('explorer')">Relationship Explorer</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="header-controls">
                <div class="control-group">
                    <span class="control-label">Theme</span>
                    <button class="btn" id="theme-mode-toggle" onclick="toggleThemeMode()">Dark</button>
                </div>
                <div class="control-group">
                    <span class="control-label">Layers</span>
                    <div class="layer-toggles">
                        <label class="layer-toggle attack">
                            <input type="checkbox" id="layer-attack" checked onchange="toggleLayer('attack')">
                            <span class="checkbox"></span>
                            <span>ATT&CK</span>
                        </label>
                        <label class="layer-toggle capec">
                            <input type="checkbox" id="layer-capec" checked onchange="toggleLayer('capec')">
                            <span class="checkbox"></span>
                            <span>CAPEC</span>
                        </label>
                        <label class="layer-toggle cwe">
                            <input type="checkbox" id="layer-cwe" checked onchange="toggleLayer('cwe')">
                            <span class="checkbox"></span>
                            <span>CWE</span>
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <button class="btn" onclick="expandAll()">Expand</button>
                    <button class="btn" onclick="collapseAll()">Collapse</button>
                    <button class="btn" onclick="clearAssignments()">Clear</button>
                    <div class="dropdown" id="export-dropdown">
                        <button class="btn" onclick="toggleDropdown('export-dropdown')">Export â–¼</button>
                        <div class="dropdown-content">
                            <button class="dropdown-item" onclick="exportJSON(); closeDropdowns()">JSON</button>
                            <button class="dropdown-item" onclick="exportCSV(); closeDropdowns()">CSV</button>
                        </div>
                    </div>
                    <button class="btn" onclick="triggerImportKillChain()">Import</button>
                    <input id="import-killchain-input" type="file" accept=".json" onchange="importKillChain(event)" style="display: none;" />
                </div>
            </div>
        </div>

        <!-- Main -->
        <div class="main">
            <!-- Sidebar -->
            <div class="sidebar">
                <div class="sidebar-tabs">
                    <button class="sidebar-tab attack active" onclick="switchTab('attack')">ATT&CK</button>
                    <button class="sidebar-tab capec" onclick="switchTab('capec')">CAPEC</button>
                    <button class="sidebar-tab cwe" onclick="switchTab('cwe')">CWE</button>
                </div>

                <div class="sidebar-content">
                    <!-- ATT&CK Tab -->
                    <div class="tab-panel active" id="tab-attack">
                        <div class="import-section">
                            <div class="import-btns">
                                <button class="import-btn" onclick="loadNavigator('enterprise')">Enterprise</button>
                                <button class="import-btn" onclick="loadNavigator('mobile')">Mobile</button>
                                <button class="import-btn" onclick="loadNavigator('ics')">ICS</button>
                                <label class="import-btn" style="cursor: pointer;">
                                    Import JSON
                                    <input type="file" accept=".json" onchange="importNavigator(event)" style="display: none;">
                                </label>
                            </div>
                        </div>
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-attack" placeholder="Search techniques..." oninput="filterEntities('attack')">
                        </div>
                        <div class="filter-row" id="filter-attack">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('attack', 'all')">All</button>
                            <button class="filter-btn" data-filter="enterprise" onclick="setFilter('attack', 'enterprise')">Enterprise</button>
                            <button class="filter-btn" data-filter="mobile" onclick="setFilter('attack', 'mobile')">Mobile</button>
                            <button class="filter-btn" data-filter="ics" onclick="setFilter('attack', 'ics')">ICS</button>
                        </div>
                        <div class="entity-list" id="list-attack"></div>
                    </div>

                    <!-- CAPEC Tab -->
                    <div class="tab-panel" id="tab-capec">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-capec" placeholder="Search patterns..." oninput="filterEntities('capec')">
                        </div>
                        <div class="filter-row" id="filter-capec">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('capec', 'all')">All</button>
                            <button class="filter-btn" data-filter="meta" onclick="setFilter('capec', 'meta')">Meta</button>
                            <button class="filter-btn" data-filter="standard" onclick="setFilter('capec', 'standard')">Standard</button>
                            <button class="filter-btn" data-filter="detailed" onclick="setFilter('capec', 'detailed')">Detailed</button>
                        </div>
                        <div class="entity-list" id="list-capec"></div>
                    </div>

                    <!-- CWE Tab -->
                    <div class="tab-panel" id="tab-cwe">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-cwe" placeholder="Search weaknesses..." oninput="filterEntities('cwe')">
                        </div>
                        <div class="filter-row" id="filter-cwe">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('cwe', 'all')">All</button>
                            <button class="filter-btn" data-filter="pillar" onclick="setFilter('cwe', 'pillar')">Pillar</button>
                            <button class="filter-btn" data-filter="class" onclick="setFilter('cwe', 'class')">Class</button>
                            <button class="filter-btn" data-filter="base" onclick="setFilter('cwe', 'base')">Base</button>
                        </div>
                        <div class="entity-list" id="list-cwe"></div>
                    </div>
                </div>
            </div>

            <div class="explorer-container" id="explorer-container">
                <iframe class="explorer-frame" src="explorer.html" title="Relationship Explorer"></iframe>
            </div>

            <!-- Content -->
            <div class="content" id="content">
                <div class="content-header">
                    <div class="content-title-wrap">
                        <button class="sidebar-toggle" onclick="toggleSidebar()" aria-label="Toggle sidebar" title="Toggle sidebar">
                            <span class="sidebar-toggle-icon">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M169.4 297.4C156.9 309.9 156.9 330.2 169.4 342.7L361.4 534.7C373.9 547.2 394.2 547.2 406.7 534.7C419.2 522.2 419.2 501.9 406.7 489.4L237.3 320L406.6 150.6C419.1 138.1 419.1 117.8 406.6 105.3C394.1 92.8 373.8 92.8 361.3 105.3L169.3 297.3z"/></svg>                            </span>
                        </button>
                        <span style="font-size: 0.9rem; font-weight: 500;" id="content-title">Unified Kill Chain</span>
                    </div>
                    <div class="view-controls">
                        <button class="btn" id="btn-hide-empty" onclick="toggleHideEmpty()">Hide Empty</button>
                    </div>
                </div>

                <div class="stats-bar" id="stats-bar"></div>
                
                <!-- Score Legend -->
                <div class="legend-row" id="legend-row">
                    <div class="score-legend" id="score-legend">
                        <span style="color: var(--text-secondary); margin-right: 8px;">Score:</span>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #6b7280;"></div>
                            <span>Unclassified</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #22c55e;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #eab308;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #f97316;"></div>
                            <span>High</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #ef4444;"></div>
                            <span>Critical</span>
                        </div>
                    </div>
                    <div class="metadata-legend" id="metadata-legend">
                        <span style="color: var(--text-secondary); margin-right: 6px;">Metadata:</span>
                        <div class="legend-item">
                            <span class="legend-icon has-cve">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                            </span>
                            <span>CVE</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-observable">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg>
                            </span>
                            <span>Observable</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-link">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg>
                            </span>
                            <span>Link</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-comment">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg>
                            </span>
                            <span>Comment</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-confidence">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg>
                            </span>
                            <span>Confidence</span>
                        </div>
                    </div>
                </div>

                <div class="kill-chain-container" id="kill-chain-container">
                    <div class="kill-chain" id="kill-chain"></div>
                </div>

                <div class="relationship-container" id="relationship-container">
                    <div class="relationship-header">
                        <div class="relationship-header-item"><div class="dot capec"></div>CAPEC</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot cwe"></div>CWE</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot attack"></div>ATT&CK</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot phase"></div>Phase</div>
                    </div>
                    <div class="relationship-wrapper">
                        <div class="relationship-chain" id="relationship-chain"></div>
                        <div class="flow-arrow">
                            <div class="flow-arrow-label">Attack Flow</div>
                            <div class="flow-arrow-line"></div>
                            <div class="flow-arrow-head"></div>
                        </div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color attack"></div><span>ATT&CK Technique</span></div>
                    <div class="legend-item"><div class="legend-color capec"></div><span>CAPEC Pattern</span></div>
                    <div class="legend-item"><div class="legend-color cwe"></div><span>CWE Weakness</span></div>
                    <div class="legend-item" style="margin-left: 16px; padding-left: 16px; border-left: 1px solid var(--border-color);">
                        <div class="legend-color in"></div><span>IN</span>
                    </div>
                    <div class="legend-item"><div class="legend-color through"></div><span>THROUGH</span></div>
                    <div class="legend-item"><div class="legend-color out"></div><span>OUT</span></div>
                </div>
            </div>

            <!-- Detail Panel -->
            <div class="detail-panel" id="detail-panel">
                <div class="detail-header">
                    <div class="detail-header-content">
                        <div class="detail-id" id="detail-id"></div>
                        <div class="detail-name" id="detail-name"></div>
                    </div>
                    <button class="detail-close" onclick="closeDetail()">Ã—</button>
                </div>
                <div class="detail-content" id="detail-content"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Entity Detail Modal -->
    <div class="modal-overlay" id="entity-modal" onclick="closeEntityModal(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">
                    <span id="entity-modal-id"></span>
                    <span id="entity-modal-name" style="margin-left: 8px; color: var(--text-secondary);"></span>
                </div>
                <button class="modal-close" onclick="closeEntityModal()">Ã—</button>
            </div>
            <div class="modal-body" id="entity-modal-content"></div>
        </div>
    </div>

    <!-- Metadata Editor Modal -->
    <div class="metadata-editor-overlay" id="metadata-editor-modal" onclick="closeMetadataEditor(event)">
        <div class="metadata-editor" onclick="event.stopPropagation()">
            <div class="metadata-editor-header">
                <div class="metadata-editor-title">Edit Metadata: <span id="metadata-entity-id"></span></div>
                <button class="metadata-editor-close" onclick="closeMetadataEditor()">&times;</button>
            </div>
            <div class="metadata-editor-body">
                <!-- Score -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Score (Severity)</div>
                    <div class="score-selector" id="score-selector">
                        <label class="score-option" data-value="unclassified">
                            <span class="score-dot" style="background: #6b7280;"></span>
                            Unclassified
                        </label>
                        <label class="score-option" data-value="low">
                            <span class="score-dot" style="background: #22c55e;"></span>
                            Low
                        </label>
                        <label class="score-option" data-value="medium">
                            <span class="score-dot" style="background: #eab308;"></span>
                            Medium
                        </label>
                        <label class="score-option" data-value="high">
                            <span class="score-dot" style="background: #f97316;"></span>
                            High
                        </label>
                        <label class="score-option" data-value="critical">
                            <span class="score-dot" style="background: #ef4444;"></span>
                            Critical
                        </label>
                    </div>
                </div>
                
                <!-- Confidence -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Confidence Level</div>
                    <div class="confidence-slider-container">
                        <input type="range" class="confidence-slider" id="meta-confidence" min="0" max="100" value="0">
                        <div class="confidence-value">
                            <span class="confidence-label unknown" id="confidence-label">Unknown</span>
                        </div>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px;">
                        0 = Unknown, 1-33% = Low, 34-66% = Medium, 67-100% = High
                    </div>
                </div>
                
                <!-- CVE & CVSS -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Vulnerability Reference</div>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 180px;">
                            <input type="text" class="metadata-input" id="meta-cve-id" placeholder="CVE-2024-12345">
                            <div class="metadata-input-error" id="meta-cve-id-error"></div>
                        </div>
                        <div style="flex: 2; min-width: 280px;">
                            <input type="text" class="metadata-input" id="meta-cvss-vector" placeholder="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H">
                            <div class="metadata-input-error" id="meta-cvss-vector-error"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Comments -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Comments</div>
                    <textarea class="metadata-input metadata-textarea" id="meta-comments" placeholder="Add notes about this assignment..."></textarea>
                </div>
                
                <!-- Hyperlinks -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Hyperlinks</div>
                    <div class="hyperlink-list" id="hyperlink-list"></div>
                    <button class="add-btn" onclick="addHyperlinkRow()">+ Add Link</button>
                </div>
                
                <!-- Observables -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Observables</div>
                    <div class="observable-list" id="observable-list"></div>
                    <button class="add-btn" onclick="addObservableRow()">+ Add Observable</button>
                </div>
            </div>
            <div class="metadata-editor-footer">
                <button class="metadata-btn metadata-btn-cancel" onclick="closeMetadataEditor()">Cancel</button>
                <button class="metadata-btn metadata-btn-save" onclick="saveMetadata()">Save</button>
            </div>
        </div>
    </div>

    <!-- Usage Guide Modal -->
    <div class="modal-overlay" id="usage-guide-modal" onclick="closeUsageGuide(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Usage Guide</div>
                <button class="modal-close" onclick="closeUsageGuide()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="guide-section">
                    <h4>Getting Started</h4>
                    <ul>
                        <li>Browse <span class="guide-key">ATT&CK</span>, <span class="guide-key">CAPEC</span>, and <span class="guide-key">CWE</span> tabs in the left sidebar</li>
                        <li>Use the search bar to find specific techniques, patterns, or weaknesses</li>
                        <li>Click any entity to view detailed information in the right panel</li>
                        <li>Switch to <span class="guide-key">Relationship Explorer</span> to investigate ATT&CK â†” CAPEC â†” CWE â†” Mitigations without assigning items</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Drag & Drop</h4>
                    <ul>
                        <li>Drag entities from the sidebar directly onto kill chain phases</li>
                        <li>Drop zones highlight when dragging over them</li>
                        <li>Entities can be reassigned by dragging to a different phase</li>
                        <li>Click the <span class="guide-key">Ã—</span> on an assigned entity to remove it</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Metadata & Enrichment</h4>
                    <ul>
                        <li>Click assigned entities in the diagram to open the metadata editor</li>
                        <li>Add <strong>Score</strong> (severity) and <strong>Confidence</strong> (assessment certainty)</li>
                        <li>Link <strong>CVE-IDs</strong> and <strong>CVSS vectors</strong> to vulnerabilities</li>
                        <li>Add <strong>Observables</strong>: IPs, hashes, domains, URLs, file names</li>
                        <li>Attach <strong>Hyperlinks</strong> and <strong>Comments</strong> for context</li>
                        <li>CVE-IDs display as badges on phase items</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Kill Chain Phases</h4>
                    <ul>
                        <li><span class="guide-color" style="background: var(--phase-in)"></span><strong>IN</strong> â€” Initial Foothold (reconnaissance â†’ C2)</li>
                        <li><span class="guide-color" style="background: var(--phase-through)"></span><strong>THROUGH</strong> â€” Network Propagation (pivoting â†’ lateral movement)</li>
                        <li><span class="guide-color" style="background: var(--phase-out)"></span><strong>OUT</strong> â€” Action on Objectives (collection â†’ impact)</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>View Controls</h4>
                    <ul>
                        <li>Toggle <span class="guide-key">ATT&CK</span> <span class="guide-key">CAPEC</span> <span class="guide-key">CWE</span> layers to show/hide entity types</li>
                        <li>Use domain filters (All / Enterprise / Mobile / ICS) for techniques</li>
                        <li>Use abstraction filters for CAPECs and CWEs</li>
                        <li>Enable <span class="guide-key">Hide Empty</span> to focus on phases with assignments</li>
                        <li>Enable <span class="guide-key">Group by CAPEC</span> to nest techniques under patterns</li>
                        <li>Switch to <span class="guide-key">Relationships</span> view for CAPECâ†’CWEâ†’ATT&CK chains</li>
                        <li>Use <span class="guide-key">Relationship Explorer</span> for full entity and mitigation browsing</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Import & Export</h4>
                    <ul>
                        <li><strong>JSON Export</strong> â€” Lightweight kill chain state for sharing</li>
                        <li><strong>JSON Import</strong> â€” Restore exported kill chains</li>
                        <li><strong>CSV Export</strong> â€” Spreadsheet format with all metadata</li>
                        <li><strong>Navigator Import</strong> â€” Load ATT&CK Navigator layer files</li>
                        <li>Use <span class="guide-key">Clear All</span> to reset the workspace</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Tips</h4>
                    <ul>
                        <li>Assigned entities appear dimmed in the sidebar</li>
                        <li>Click phase headers to expand/collapse</li>
                        <li>Score colors appear as left border ribbons on items</li>
                        <li>Related CAPECs and CWEs are shown in the detail panel</li>
                        <li>Click the version number to view the changelog</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div class="modal-overlay" id="changelog-modal" onclick="closeChangelog(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Changelog</div>
                <button class="modal-close" onclick="closeChangelog()">Ã—</button>
            </div>
            <div class="modal-body changelog-body" id="changelog-content">
                <div class="loading-text">Loading changelog...</div>
            </div>
        </div>
    </div>

    <script src="kill-chain-visualizer.js"></script>
    <script>
        // ============================================================
        // VERSION - Loaded dynamically from changelog
        // ============================================================
        let APP_VERSION = '2.4.2';  // Fallback version
        
        async function loadVersion() {
            try {
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                const match = text.match(/^## \[([\d.]+)\]/m);
                if (match) {
                    APP_VERSION = match[1];
                    const versionEl = document.getElementById('app-version');
                    if (versionEl) versionEl.textContent = 'v' + APP_VERSION;
                }
            } catch (e) {
                console.warn('Could not load version from changelog:', e);
            }
        }

        // ============================================================
        // INPUT SECURITY - Validation, Sanitization, Escaping
        // ============================================================
        const InputSecurity = {
            // HTML escape to prevent XSS
            escapeHtml(str) {
                if (str === null || str === undefined) return '';
                const div = document.createElement('div');
                div.textContent = String(str);
                return div.innerHTML;
            },

            // Encode HTML entities (including quotes and backticks)
            encodeHtmlEntities(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/`/g, '&#96;');
            },

            // Normalize input: remove control chars, strip script tags, trim, limit length
            normalize(str, maxLength = 1000) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/[\x00-\x1F\x7F]/g, '')  // Remove control chars
                    .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Remove script tags
                    .trim()
                    .slice(0, maxLength);
            },
            
            // Sanitize: remove control chars, strip disallowed chars, trim, limit length, encode entities
            sanitize(str, maxLength = 1000) {
                let value = this.normalize(str, maxLength);
                // Remove disallowed bracket/quote/semicolon characters and SQL comment markers
                value = value.replace(/[\[\]\{\};"'`]/g, '');
                value = value.replace(/--+/g, '');
                return this.encodeHtmlEntities(value);
            },
            
            // Sanitize for use in HTML attributes
            sanitizeAttr(str, maxLength = 200) {
                return this.encodeHtmlEntities(this.sanitize(str, maxLength));
            },
            
            // Validators - return { valid: boolean, message?: string }
            validators: {
                ipv4(v) {
                    const valid = /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv4 address' };
                },
                ipv6(v) {
                    const valid = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::$|^(?:[0-9a-fA-F]{1,4}:){1,7}:$|^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv6 address' };
                },
                md5(v) {
                    const valid = /^[a-fA-F0-9]{32}$/.test(v);
                    return { valid, message: valid ? null : 'MD5 must be 32 hex characters' };
                },
                sha1(v) {
                    const valid = /^[a-fA-F0-9]{40}$/.test(v);
                    return { valid, message: valid ? null : 'SHA1 must be 40 hex characters' };
                },
                sha256(v) {
                    const valid = /^[a-fA-F0-9]{64}$/.test(v);
                    return { valid, message: valid ? null : 'SHA256 must be 64 hex characters' };
                },
                domain(v) {
                    const valid = /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid domain name' };
                },
                url(v) {
                    const valid = /^https?:\/\/[^\s<>"{}|\\^`\[\]]+$/.test(v);
                    return { valid, message: valid ? null : 'Invalid URL (must start with http:// or https://)' };
                },
                cveId(v) {
                    const valid = /^CVE-\d{4}-\d{4,}$/.test(v);
                    return { valid, message: valid ? null : 'CVE format: CVE-YYYY-NNNNN' };
                },
                cvssVector(v) {
                    const valid = /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(v);
                    return { valid, message: valid ? null : 'Invalid CVSS 3.x vector string' };
                },
                filename(v) {
                    const valid = /^[^<>:"/\\|?*\x00-\x1F]+$/.test(v) && v.length <= 255;
                    return { valid, message: valid ? null : 'Invalid filename' };
                },
                text(v, maxLen = 1000) {
                    const valid = v.length <= maxLen;
                    return { valid, message: valid ? null : `Text exceeds ${maxLen} characters` };
                }
            },
            
            // Validate observable based on type
            validateObservable(type, value) {
                const v = this.normalize(value, 500);
                switch (type) {
                    case 'ipv4-addr': return this.validators.ipv4(v);
                    case 'ipv6-addr': return this.validators.ipv6(v);
                    case 'file-hash-md5': return this.validators.md5(v);
                    case 'file-hash-sha1': return this.validators.sha1(v);
                    case 'file-hash-sha256': return this.validators.sha256(v);
                    case 'domain-name': return this.validators.domain(v);
                    case 'url': return this.validators.url(v);
                    case 'file-name': return this.validators.filename(v);
                    case 'threat-actor':
                    case 'malware':
                        return this.validators.text(v, 100);
                    default:
                        return { valid: true };
                }
            }
        };

        // KCE-SEC-001: Shorthand for escaping HTML in template strings
        const esc = (str) => InputSecurity.escapeHtml(str);
        const escAttr = (str) => InputSecurity.sanitizeAttr(str);

        const BLOCKED_INPUT_CHARS = new Set(['<', '>', '[', ']', '{', '}', '"', "'", '`', ';']);

        function isTextInputElement(el) {
            return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA');
        }

        function sanitizeUserInputText(text) {
            let value = InputSecurity.normalize(text, 10000);
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function sanitizeForStorage(text, maxLength = 1000) {
            let value = InputSecurity.normalize(text, maxLength);
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function truncateAtBoundary(text, maxLen = 500) {
            if (!text) return '';
            if (text.length <= maxLen) return text;
            const slice = text.slice(0, maxLen);
            const sentenceMatch = slice.match(/([\s\S]*?[.!?])\s[^.!?]*$/);
            let cut = sentenceMatch ? sentenceMatch[1].trimEnd() : '';
            if (!cut || cut.length < maxLen * 0.6) {
                const wsIndex = slice.lastIndexOf(' ');
                cut = wsIndex > 0 ? slice.slice(0, wsIndex).trimEnd() : slice.trimEnd();
            }
            return `${cut}â€¦`;
        }

        function applyInputGuards() {
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                const key = e.key;
                if (BLOCKED_INPUT_CHARS.has(key)) {
                    e.preventDefault();
                    return;
                }

                if (key === '-') {
                    const value = target.value || '';
                    const start = target.selectionStart ?? 0;
                    const end = target.selectionEnd ?? start;
                    const prev = start > 0 ? value[start - 1] : '';
                    const next = end < value.length ? value[end] : '';
                    if (prev === '-' || next === '-') {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('beforeinput', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.inputType === 'insertText' && e.data) {
                    if ([...e.data].some(ch => BLOCKED_INPUT_CHARS.has(ch))) {
                        e.preventDefault();
                    }
                    if (e.data.includes('--')) {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('paste', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = (e.clipboardData || window.clipboardData)?.getData('text');
                if (!data) return;
                const sanitized = sanitizeUserInputText(data);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('drop', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = e.dataTransfer?.getData('text');
                if (!data) return;
                const sanitized = sanitizeUserInputText(data);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('input', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const value = target.value || '';
                const sanitized = sanitizeUserInputText(value);
                if (sanitized !== value) {
                    const pos = target.selectionStart ?? sanitized.length;
                    target.value = sanitized;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(pos, pos);
                    }
                }
            });
        }

        // Encode < and > in any JSON-loaded strings
        function stripAngleBracketsFromJson(value) {
            if (typeof value === 'string') {
                return value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }
            if (Array.isArray(value)) {
                return value.map(stripAngleBracketsFromJson);
            }
            if (value && typeof value === 'object') {
                const cleaned = {};
                for (const [key, val] of Object.entries(value)) {
                    cleaned[key] = stripAngleBracketsFromJson(val);
                }
                return cleaned;
            }
            return value;
        }

        // ============================================================
        // METADATA HELPERS
        // ============================================================
        // Default metadata structure
        function createDefaultMetadata() {
            return {
                score: 'unclassified',     // Color-coded severity: unclassified|low|medium|high|critical
                confidence: null,           // Percentage: null (Unknown) or 1-100
                comments: '',
                cveId: '',
                cvssVector: '',
                hyperlinks: [],    // [{ label, url }]
                observables: []    // [{ type, value }]
            };
        }

        // Get confidence label from percentage value
        function getConfidenceLabel(value) {
            if (value === null || value === undefined || value === 0) return 'Unknown';
            if (value <= 33) return 'Low';
            if (value <= 66) return 'Medium';
            return 'High';
        }

        // Get confidence CSS class
        function getConfidenceClass(value) {
            if (value === null || value === undefined || value === 0) return 'unknown';
            if (value <= 33) return 'low';
            if (value <= 66) return 'medium';
            return 'high';
        }

        let assignmentInstanceCounter = 0;

        function createAssignmentInstanceId() {
            assignmentInstanceCounter += 1;
            return `itm-${Date.now().toString(36)}-${assignmentInstanceCounter}`;
        }

        // Migrate old ID-only format to new object format
        function migrateAssignment(idOrObj) {
            if (typeof idOrObj === 'string') {
                return { id: idOrObj, metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
            }
            // Ensure metadata exists
            if (!idOrObj.metadata) {
                idOrObj.metadata = createDefaultMetadata();
            }
            if (!idOrObj.instanceId) {
                idOrObj.instanceId = createAssignmentInstanceId();
            }
            return idOrObj;
        }

        // Get ID from assignment (handles both old and new format)
        function getAssignmentId(assignment) {
            return typeof assignment === 'string' ? assignment : assignment.id;
        }

        // Get metadata from assignment
        function getAssignmentMetadata(assignment) {
            return typeof assignment === 'string' ? createDefaultMetadata() : (assignment.metadata || createDefaultMetadata());
        }

        function getAssignmentInstanceId(assignment) {
            return typeof assignment === 'string' ? null : assignment.instanceId;
        }

        function getPhaseUngroupedItems(phaseData, type) {
            const key = type === 'attack' ? 'techniques' : type === 'capec' ? 'capecs' : 'cwes';
            return phaseData?.[key] || [];
        }

        function getPhaseGroupedItems(phaseData, type) {
            const groups = Array.isArray(phaseData?.groups) ? phaseData.groups : [];
            return groups.flatMap(group => (group.items || []).filter(item => item.type === type));
        }

        function getAllPhaseItemsByType(phaseData, type) {
            return [...getPhaseUngroupedItems(phaseData, type), ...getPhaseGroupedItems(phaseData, type)];
        }

        function ensurePhaseLayout(phaseKey, phaseData) {
            if (!phaseData.layout || !Array.isArray(phaseData.layout)) {
                phaseData.layout = [];
            }

            const existingItemIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'item').map(entry => entry.instanceId)
            );
            const existingGroupIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'group').map(entry => entry.groupId)
            );

            for (const type of ['capec', 'attack', 'cwe']) {
                const items = getPhaseUngroupedItems(phaseData, type);
                items.forEach(item => {
                    const instanceId = getAssignmentInstanceId(item);
                    if (instanceId && !existingItemIds.has(instanceId)) {
                        phaseData.layout.push({ kind: 'item', type, instanceId });
                        existingItemIds.add(instanceId);
                    }
                });
            }

            (phaseData.groups || []).forEach(group => {
                if (group?.groupId && !existingGroupIds.has(group.groupId)) {
                    phaseData.layout.push({ kind: 'group', groupId: group.groupId });
                    existingGroupIds.add(group.groupId);
                }
            });

            phaseData.layout = phaseData.layout.filter(entry => {
                if (entry.kind === 'item') {
                    const type = entry.type;
                    return getPhaseUngroupedItems(phaseData, type)
                        .some(item => getAssignmentInstanceId(item) === entry.instanceId);
                }
                if (entry.kind === 'group') {
                    return (phaseData.groups || []).some(group => group.groupId === entry.groupId);
                }
                return false;
            });
        }

        function generateGroupId() {
            return `grp-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;
        }

        function createGroup(phaseKey) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = {
                groupId: generateGroupId(),
                label: 'New Group',
                collapsed: false,
                items: []
            };
            phaseData.groups = phaseData.groups || [];
            phaseData.groups.push(group);
            ensurePhaseLayout(phaseKey, phaseData);
            renderKillChain();
            startRenameGroup(phaseKey, group.groupId);
        }

        function toggleGroupCollapse(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.collapsed = !group.collapsed;
            const escapedId = window.CSS && CSS.escape ? CSS.escape(groupId) : groupId.replace(/"/g, '\\"');
            const groupEl = document.querySelector(`.phase-group[data-group-id="${escapedId}"]`);
            if (groupEl) {
                groupEl.classList.toggle('collapsed', group.collapsed);
            } else {
                renderKillChain();
            }
        }

        function startRenameGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = true;
            renderKillChain();
            setTimeout(() => {
                const input = document.getElementById(`group-rename-${groupId}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 0);
        }

        function commitRenameGroup(phaseKey, groupId, value, cancel = false) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = false;
            if (!cancel) {
                const sanitized = sanitizeForStorage(value || '', 80).trim();
                group.label = sanitized || 'New Group';
            }
            renderKillChain();
        }

        function removeGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const groupIdx = (phaseData.groups || []).findIndex(g => g.groupId === groupId);
            if (groupIdx === -1) return;

            const group = phaseData.groups[groupIdx];
            if (!window.confirm('Delete this group and move its items back to the phase?')) return;

            const items = group.items || [];
            items.forEach(item => {
                const key = item.type === 'attack' ? 'techniques' : item.type === 'capec' ? 'capecs' : 'cwes';
                phaseData[key].push(item);
                phaseData.layout.push({ kind: 'item', type: item.type, instanceId: getAssignmentInstanceId(item) });
            });

            phaseData.groups.splice(groupIdx, 1);
            phaseData.layout = (phaseData.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function extractAssignmentInstance(phaseKey, type, instanceId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return null;
            const key = type === 'attack' ? 'techniques' : type === 'capec' ? 'capecs' : 'cwes';

            const list = phaseData[key];
            const idx = list.findIndex(a => getAssignmentInstanceId(a) === instanceId);
            if (idx !== -1) {
                const [removed] = list.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                return removed;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => getAssignmentInstanceId(a) === instanceId);
                if (gIdx !== -1) {
                    const [removed] = group.items.splice(gIdx, 1);
                    return removed;
                }
            }

            return null;
        }

        function moveGroupBetweenPhases(fromPhase, toPhase, groupId) {
            if (!fromPhase || !toPhase || fromPhase === toPhase) return;
            const source = state.assignments[fromPhase];
            const target = state.assignments[toPhase];
            if (!source || !target) return;

            const idx = (source.groups || []).findIndex(g => g.groupId === groupId);
            if (idx === -1) return;
            const [group] = source.groups.splice(idx, 1);
            target.groups = target.groups || [];
            target.groups.push(group);

            source.layout = (source.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            ensurePhaseLayout(toPhase, target);
        }

        // Find assignment object by ID in a phase
        function findAssignment(phaseKey, entityType, id, instanceId = null) {
            const key = entityType === 'attack' ? 'techniques' : entityType === 'capec' ? 'capecs' : 'cwes';
            const phaseData = state.assignments[phaseKey];
            const assignments = phaseData?.[key] || [];
            if (instanceId) {
                const match = assignments.find(a => getAssignmentInstanceId(a) === instanceId);
                if (match) return match;
                for (const group of phaseData?.groups || []) {
                    const groupMatch = (group.items || []).find(a => getAssignmentInstanceId(a) === instanceId);
                    if (groupMatch) return groupMatch;
                }
                return null;
            }

            const match = assignments.find(a => getAssignmentId(a) === id);
            if (match) return match;
            for (const group of phaseData?.groups || []) {
                const groupMatch = (group.items || []).find(a => getAssignmentId(a) === id && a.type === entityType);
                if (groupMatch) return groupMatch;
            }
            return null;
        }

        // Update metadata for an assignment
        function updateAssignmentMetadata(phaseKey, entityType, id, newMetadata, instanceId = null) {
            const key = entityType === 'attack' ? 'techniques' : entityType === 'capec' ? 'capecs' : 'cwes';
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const assignments = phaseData[key] || [];

            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                if (typeof assignments[idx] === 'string') {
                    assignments[idx] = { id: assignments[idx], metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
                }
                assignments[idx].metadata = { ...assignments[idx].metadata, ...newMetadata };
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => instanceId
                    ? getAssignmentInstanceId(a) === instanceId
                    : (getAssignmentId(a) === id && a.type === entityType)
                );
                if (gIdx !== -1) {
                    group.items[gIdx].metadata = { ...group.items[gIdx].metadata, ...newMetadata };
                    return;
                }
            }
        }

        // Score level config (color-coded severity)
        const SCORE_LEVELS = {
            unclassified: { label: 'Unclassified', color: null, bgColor: null },
            low: { label: 'Low', color: '#22c55e', bgColor: 'rgba(34, 197, 94, 0.1)' },
            medium: { label: 'Medium', color: '#eab308', bgColor: 'rgba(234, 179, 8, 0.1)' },
            high: { label: 'High', color: '#f97316', bgColor: 'rgba(249, 115, 22, 0.1)' },
            critical: { label: 'Critical', color: '#ef4444', bgColor: 'rgba(239, 68, 68, 0.15)' }
        };

        // Observable types
        const OBSERVABLE_TYPES = [
            { value: 'ipv4-addr', label: 'IPv4 Address' },
            { value: 'ipv6-addr', label: 'IPv6 Address' },
            { value: 'file-hash-md5', label: 'Hash (MD5)' },
            { value: 'file-hash-sha1', label: 'Hash (SHA1)' },
            { value: 'file-hash-sha256', label: 'Hash (SHA256)' },
            { value: 'domain-name', label: 'Domain Name' },
            { value: 'url', label: 'URL' },
            { value: 'file-name', label: 'File Name' },
            { value: 'malware', label: 'Malware Name' },
            { value: 'threat-actor', label: 'Threat Actor' }
        ];

        // ============================================================
        // STATE
        // ============================================================
        const state = {
            view: 'killchain',  // 'killchain' | 'relationship'
            layers: { attack: true, capec: true, cwe: true },
            hideEmpty: false,
            activeTab: 'attack',
            filters: { attack: 'all', capec: 'all', cwe: 'all' },
            
            // Full data libraries (loaded from JSON)
            library: {
                techniques: {},  // T1566 -> { id, name, domain }
                capecs: {},      // CAPEC-98 -> { id, name, severity, ... }
                cwes: {}         // CWE-89 -> { id, name, ... }
            },
            
            // Mappings
            techniqueToCapec: {},
            cweToCapec: {},
            capecToTechnique: {},
            
            // Assigned entities (by phase)
            assignments: {},
            
            // Current selection
            selection: { type: null, id: null }
        };

        // Kill chain structure
        const KILL_CHAIN = {
            'IN': {
                name: 'Initial Foothold',
                phases: ['reconnaissance', 'resource-development', 'delivery', 'social-engineering', 'exploitation', 'persistence', 'defense-evasion', 'command-control']
            },
            'THROUGH': {
                name: 'Network Propagation',
                phases: ['pivoting', 'discovery', 'privilege-escalation', 'execution', 'credential-access', 'lateral-movement']
            },
            'OUT': {
                name: 'Action on Objectives',
                phases: ['collection', 'exfiltration', 'impact', 'objectives']
            }
        };

        // All phases in order
        const ALL_PHASES = [];
        for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
            for (const phase of data.phases) {
                ALL_PHASES.push(`${superPhase}:${phase}`);
            }
        }

        // Phase name formatter
        function formatPhaseName(id) {
            return id.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // Initialize all phase assignments
        function initAssignments() {
            for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
                for (const phase of data.phases) {
                    const key = `${superPhase}:${phase}`;
                    state.assignments[key] = { techniques: [], capecs: [], cwes: [], groups: [], layout: [] };
                }
            }
        }

        // ============================================================
        // DATA LOADING
        // ============================================================
        async function loadData() {
            try {
                // Load ATT&CK techniques data
                const attackRes = await fetch('resources/attack-techniques.json');
                state.library.techniques = stripAngleBracketsFromJson(await attackRes.json());
                
                // Load CAPEC data
                const capecRes = await fetch('resources/capec-full.json');
                const capecData = stripAngleBracketsFromJson(await capecRes.json());
                state.library.capecs = capecData.patterns;
                
                // Load CWE data
                const cweRes = await fetch('resources/cwe-full.json');
                const cweData = stripAngleBracketsFromJson(await cweRes.json());
                state.library.cwes = cweData.weaknesses;
                
                // Load mappings
                const t2cRes = await fetch('resources/technique-to-capec.json');
                state.techniqueToCapec = stripAngleBracketsFromJson(await t2cRes.json());
                
                const c2tRes = await fetch('resources/capec-to-technique.json');
                state.capecToTechnique = stripAngleBracketsFromJson(await c2tRes.json());
                
                const c2cRes = await fetch('resources/cwe-to-capec.json');
                state.cweToCapec = stripAngleBracketsFromJson(await c2cRes.json());
                
                console.log(`Loaded: ${Object.keys(state.library.techniques).length} techniques, ${Object.keys(state.library.capecs).length} CAPECs, ${Object.keys(state.library.cwes).length} CWEs`);
                
                document.getElementById('loading').classList.add('hidden');
                renderAll();
            } catch (err) {
                console.error('Failed to load data:', err);
                // KCE-SEC-009: Use textContent instead of innerHTML for error messages
                const loadingEl = document.getElementById('loading');
                loadingEl.innerHTML = '<div class="loading-text"></div>';
                loadingEl.querySelector('.loading-text').textContent = 'Error loading data: ' + err.message;
            }
        }

        // Load Navigator layer (techniques become searchable, not auto-assigned)
        async function loadNavigator(domain) {
            try {
                const res = await fetch(`resources/Nav_Layer_${domain.toUpperCase()}.json`);
                const layer = stripAngleBracketsFromJson(await res.json());
                
                let added = 0, existing = 0;
                for (const tech of layer.techniques || []) {
                    if (tech.enabled === false) continue;
                    const id = tech.techniqueID;
                    if (state.library.techniques[id]) {
                        existing++;
                    } else {
                        // Add technique with minimal info (not in our technique library)
                        state.library.techniques[id] = {
                            id,
                            name: getTechniqueName(id),
                            domain: detectDomain(id)
                        };
                        added++;
                    }
                }
                
                showToast(`Navigator: ${existing} techniques found in library, ${added} new`);
                filterEntities('attack');
            } catch (err) {
                showToast('Error: ' + err.message);
            }
        }

        // KCE-SEC-003: Navigator import validation constants
        const IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024 * 5,  // 25MB
            maxTechniques: 5000,
            maxStringLength: 500,
            techniqueIdPattern: /^T\d{4}(\.\d{3})?$/  // T1234 or T1234.001
        };

        function importNavigator(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // KCE-SEC-003: Validate file size
            if (file.size > IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max 25MB)`);
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layer = stripAngleBracketsFromJson(JSON.parse(e.target.result));
                    
                    // KCE-SEC-003: Validate it's an object (basic schema check)
                    if (typeof layer !== 'object' || layer === null || Array.isArray(layer)) {
                        throw new Error('Invalid layer format: expected object');
                    }
                    
                    // KCE-SEC-003: Validate techniques array exists and has reasonable size
                    const techniques = layer.techniques;
                    if (!Array.isArray(techniques)) {
                        throw new Error('Invalid layer format: techniques array required');
                    }
                    
                    if (techniques.length > IMPORT_LIMITS.maxTechniques) {
                        throw new Error(`Too many techniques: ${techniques.length} (max ${IMPORT_LIMITS.maxTechniques})`);
                    }
                    
                    let added = 0, existing = 0, skipped = 0;
                    
                    for (const tech of techniques) {
                        if (tech.enabled === false) continue;
                        
                        // KCE-SEC-003: Validate technique ID format
                        const id = tech.techniqueID;
                        if (!id || typeof id !== 'string') {
                            skipped++;
                            continue;
                        }
                        
                        // Validate ID matches expected pattern (T1234 or T1234.001)
                        if (!IMPORT_LIMITS.techniqueIdPattern.test(id)) {
                            skipped++;
                            continue;
                        }
                        
                        if (state.library.techniques[id]) {
                            existing++;
                        } else {
                            state.library.techniques[id] = {
                                id,
                                name: getTechniqueName(id),
                                domain: detectDomain(id)
                            };
                            added++;
                        }
                    }
                    
                    let msg = `Import: ${existing} in library, ${added} new techniques`;
                    if (skipped > 0) msg += `, ${skipped} skipped (invalid ID)`;
                    showToast(msg);
                    filterEntities('attack');
                } catch (err) {
                    showToast('Invalid JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';  // Reset input
        }

        // Domain detection (from visualizer)
        function detectDomain(techId) {
            if (techId.startsWith('T0')) return 'ics';
            const num = parseInt(techId.replace(/^T/, '').split('.')[0], 10);
            if (num >= 1398 && num <= 1665) return 'mobile';
            return 'enterprise';
        }

        // Technique name lookup
        function getTechniqueName(techId) {
            // First, check our loaded technique library
            if (state.library.techniques[techId]) {
                return state.library.techniques[techId].name;
            }
            // Fallback to visualizer if available
            if (typeof KillChainVisualizer !== 'undefined') {
                const viz = new KillChainVisualizer(null, null);
                const name = viz.getTechniqueName(techId);
                if (name) return name;
            }
            return `Technique ${techId}`;
        }

        // ============================================================
        // VIEW & LAYER CONTROLS
        // ============================================================
        const THEME_STORAGE_KEYS = {
            mode: 'af-theme-mode'
        };
        let currentTheme = {
            mode: CONFIG?.themeDefaults?.mode || 'light',
            scheme: 'default'
        };

        function getPreferredThemeMode() {
            const configured = CONFIG?.themeMode || CONFIG?.themeDefaults?.mode || 'light';
            if (configured !== 'auto') return configured;
            if (typeof window === 'undefined') return CONFIG?.themeDefaults?.mode || 'light';
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        function normalizeThemeMode(mode) {
            return mode === 'light' || mode === 'dark' ? mode : (CONFIG?.themeDefaults?.mode || 'light');
        }

        function normalizeThemeScheme(mode, scheme) {
            const schemes = CONFIG?.themes?.[mode] || {};
            if (scheme && schemes[scheme]) return scheme;
            if (schemes.default) return 'default';
            const first = Object.keys(schemes)[0];
            return first || 'default';
        }

        function applyTheme(mode, scheme, persist = true) {
            const resolvedMode = normalizeThemeMode(mode);
            const resolvedScheme = normalizeThemeScheme(resolvedMode, scheme);
            const theme = typeof resolveTheme === 'function'
                ? resolveTheme(resolvedMode, resolvedScheme)
                : null;
            if (typeof applyConfigColors === 'function') {
                applyConfigColors(theme || undefined);
            }
            document.documentElement.dataset.theme = resolvedMode;
            currentTheme = { mode: resolvedMode, scheme: resolvedScheme };
            updateThemeControls();
            if (persist) {
                try {
                    localStorage.setItem(THEME_STORAGE_KEYS.mode, resolvedMode);
                } catch (e) {
                    console.warn('Theme preference could not be saved:', e);
                }
            }
        }

        function updateThemeControls() {
            const modeBtn = document.getElementById('theme-mode-toggle');
            if (modeBtn) {
                modeBtn.textContent = currentTheme.mode === 'dark' ? 'Dark' : 'Light';
            }
        }

        function toggleThemeMode() {
            const nextMode = currentTheme.mode === 'dark' ? 'light' : 'dark';
            const nextScheme = normalizeThemeScheme(nextMode, currentTheme.scheme);
            applyTheme(nextMode, nextScheme);
        }

        function initThemeControls() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                console.warn('Theme preference could not be read:', e);
            }

            const mode = normalizeThemeMode(storedMode || getPreferredThemeMode());
            applyTheme(mode, 'default', false);
        }

        function syncThemeFromStorage() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                return;
            }

            const mode = normalizeThemeMode(storedMode || currentTheme.mode);
            if (mode !== currentTheme.mode) {
                applyTheme(mode, 'default', false);
            }
        }

        function setView(view) {
            state.view = view;
            const isExplorer = view === 'explorer';
            const isRelationship = view === 'relationship';
            document.getElementById('view-killchain').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-relationship').classList.toggle('active', isRelationship);
            document.getElementById('view-explorer').classList.toggle('active', isExplorer);
            document.getElementById('view-editor-group').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-explorer-group').classList.toggle('active', isExplorer);
            document.getElementById('kill-chain-container').classList.toggle('hidden', isExplorer || isRelationship);
            document.getElementById('relationship-container').classList.toggle('visible', isRelationship);
            document.getElementById('content-title').textContent = isRelationship ? 'Kill Chain Relationships' : 'Unified Kill Chain';
            document.getElementById('btn-hide-empty').style.display = !isExplorer && !isRelationship ? 'inline-block' : 'none';
            document.getElementById('stats-bar').style.display = isExplorer ? 'none' : 'flex';
            document.getElementById('legend-row').style.display = isExplorer ? 'none' : 'flex';
            document.querySelector('.app').classList.toggle('explorer-view', isExplorer);
            if (isRelationship) {
                renderRelationshipView();
            }
        }

        function toggleSidebar() {
            const app = document.querySelector('.app');
            if (!app) return;
            app.classList.toggle('sidebar-collapsed');
        }

        function toggleLayer(layer) {
            state.layers[layer] = document.getElementById(`layer-${layer}`).checked;
            renderKillChain();
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function toggleHideEmpty() {
            state.hideEmpty = !state.hideEmpty;
            document.getElementById('btn-hide-empty').classList.toggle('active', state.hideEmpty);
            renderKillChain();
        }

        function openMitigationExplorer(mitigationId) {
            if (!mitigationId) return;

            // Validate mitigationId to ensure it matches the expected ID format
            const mitigationIdPattern = /^[A-Za-z0-9_-]+$/;
            if (!mitigationIdPattern.test(mitigationId)) {
                console.error('Invalid mitigationId provided to openMitigationExplorer:', mitigationId);
                return;
            }
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?mitigation=${encodeURIComponent(mitigationId)}`;
            }
            setView('explorer');
        }

        function openEntityExplorer(type, id) {
            if (!type || !id) return;
            const allowed = new Set(['attack', 'capec', 'cwe']);
            if (!allowed.has(type)) return;
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?entity=${encodeURIComponent(`${type}:${id}`)}`;
            }
            setView('explorer');
        }

        // ============================================================
        // TAB & FILTER CONTROLS
        // ============================================================
        function switchTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.sidebar-tab.${tab}`).classList.add('active');
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function setFilter(type, filter) {
            state.filters[type] = filter;
            document.querySelectorAll(`#filter-${type} .filter-btn`).forEach(b => {
                b.classList.toggle('active', b.dataset.filter === filter);
            });
            filterEntities(type);
        }

        // ============================================================
        // ENTITY LIST RENDERING
        // ============================================================
        function filterEntities(type) {
            const searchTerm = document.getElementById(`search-${type}`).value.toLowerCase();
            const filter = state.filters[type];
            const listEl = document.getElementById(`list-${type}`);
            
            let entities = [];
            
            if (type === 'attack') {
                entities = Object.values(state.library.techniques).filter(t => {
                    if (searchTerm && !t.id.toLowerCase().includes(searchTerm) && !t.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && t.domain !== filter) return false;
                    return true;
                });
            } else if (type === 'capec') {
                entities = Object.values(state.library.capecs).filter(c => {
                    if (searchTerm && !c.id.toLowerCase().includes(searchTerm) && !c.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && c.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            } else if (type === 'cwe') {
                entities = Object.values(state.library.cwes).filter(w => {
                    if (searchTerm && !w.id.toLowerCase().includes(searchTerm) && !w.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && w.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            }
            
            // Limit display for performance
            const maxDisplay = 100;
            const total = entities.length;
            entities = entities.slice(0, maxDisplay);
            
            let html = '';
            
            for (const entity of entities) {
                const isSelected = state.selection.type === type && state.selection.id === entity.id;
                
                if (type === 'attack') {
                    const subIndicator = entity.isSubtechnique ? 'â†³ ' : '';
                    const tacticBadge = entity.tactics?.length ? `<span class="entity-badge">${esc(entity.tactics[0])}</span>` : '';
                    html += `
                        <div class="entity-item attack ${isSelected ? 'selected' : ''}" 
                             onclick="selectEntity('attack', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'attack', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)"
                             title="${escAttr(entity.description ? entity.description.substring(0, 200) + '...' : '')}">
                            <div class="entity-header">
                                <span class="entity-id">${subIndicator}${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.domain?.toUpperCase() || 'ENT')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                ${tacticBadge}
                                ${entity.platforms?.length ? `<span class="entity-badge">${esc(entity.platforms.slice(0,2).join(', '))}</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'capec') {
                    const severityClass = entity.severity?.toLowerCase().includes('high') ? 'severity-high' : 
                                         entity.severity?.toLowerCase().includes('medium') ? 'severity-medium' : 'severity-low';
                    html += `
                        <div class="entity-item capec ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('capec', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'capec', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge ${severityClass}">${esc(entity.severity || 'Unknown')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                <span class="entity-badge">${esc(entity.abstraction || 'Standard')}</span>
                                ${entity.techniques?.length ? `<span class="entity-badge">${entity.techniques.length} techniques</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'cwe') {
                    html += `
                        <div class="entity-item cwe ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('cwe', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'cwe', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.abstraction || 'Base')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                        </div>
                    `;
                }
            }
            
            if (total > maxDisplay) {
                html += `<div class="list-info">Showing ${maxDisplay} of ${total}. Refine your search.</div>`;
            } else if (entities.length === 0) {
                html += `<div class="list-info">No ${type === 'attack' ? 'techniques' : type === 'capec' ? 'patterns' : 'weaknesses'} found</div>`;
            }
            
            listEl.innerHTML = html;
        }

        function isEntityAssigned(type, id) {
            for (const phase of Object.values(state.assignments)) {
                const items = getAllPhaseItemsByType(phase, type);
                if (items.some(a => getAssignmentId(a) === id)) return true;
            }
            return false;
        }

        // ============================================================
        // SELECTION & DETAIL
        // ============================================================
        function selectEntity(type, id) {
            state.selection = { type, id };
            
            // Update list selection
            filterEntities(type);
            
            // Show detail panel
            showDetail(type, id);
        }

        function buildEntityDetail(type, id) {
            let entity, html = '', name = 'Unknown';

            if (type === 'attack') {
                entity = state.library.techniques[id];
                name = entity?.name || 'Unknown';

                const relatedCapecs = state.techniqueToCapec[id] || [];
                const platforms = entity?.platforms?.join(', ') || 'N/A';
                const tactics = entity?.tactics?.map(t => t.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(', ') || 'N/A';

                const mitigations = entity?.mitigations || [];
                const mitigationsHtml = mitigations.length > 0 
                    ? mitigations.slice(0, 8).map(m => `
                        <div class="detail-list-item" style="cursor: pointer;" onclick="openMitigationExplorer('${escAttr(m.id)}')" title="${escAttr(m.description || '')}">
                            <span class="id" style="color: #10b981;">${esc(m.id)}</span>
                            <span>${esc(m.name)}</span>
                        </div>
                    `).join('') + (mitigations.length > 8 ? `<div class="list-info">+${mitigations.length - 8} more</div>` : '')
                    : '<div class="list-info">No mitigations available</div>';

                const refs = entity?.references || [];
                const refsHtml = refs.slice(0, 3).map(r => {
                    const url = r.url || '';
                    const isSafeUrl = /^https?:\/\//i.test(url);
                    return isSafeUrl ? `
                    <div class="detail-list-item">
                        <a href="${esc(url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(r.name)} â†’
                        </a>
                    </div>
                ` : '';
                }).join('');

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <p>${esc(entity?.description || 'No description available.')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Domain:</span><span>${esc((entity?.domain || 'enterprise').toUpperCase())}</span></div>
                            <div class="detail-list-item"><span>Platforms:</span><span>${esc(platforms)}</span></div>
                            <div class="detail-list-item"><span>Tactics:</span><span>${esc(tactics)}</span></div>
                            ${entity?.isSubtechnique ? `<div class="detail-list-item"><span>Parent:</span><span onclick="selectEntity('attack', '${escAttr(entity.parentTechnique)}')" style="cursor:pointer; color: var(--attack-color);">${esc(entity.parentTechnique)}</span></div>` : ''}
                            <div class="detail-list-item"><span>Version:</span><span>${esc(entity?.version || '1.0')}</span></div>
                        </div>
                    </div>
                    ${entity?.detection ? `
                    <div class="detail-section">
                        <h4>Detection</h4>
                        <p style="font-size: 0.75rem;">${esc(entity.detection)}</p>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <h4>Mitigations (${mitigations.length})</h4>
                        <div class="detail-list">
                            ${mitigationsHtml}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length === 0 ? '<div class="list-info">No CAPEC mappings</div>' : ''}
                        </div>
                    </div>
                    ${refs.length > 0 ? `
                    <div class="detail-section">
                        <h4>References</h4>
                        <div class="detail-list">
                            ${refsHtml}
                        </div>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <a href="https://attack.mitre.org/techniques/${id.replace('.', '/')}" target="_blank" rel="noopener noreferrer" style="color: var(--attack-color);">View on MITRE ATT&CK â†’</a>
                    </div>
                `;
            } else if (type === 'capec') {
                entity = state.library.capecs[id];
                name = entity?.name || 'Unknown';

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <p>${esc(entity?.description || 'No description available.')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Severity:</span><span>${esc(entity?.severity || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Likelihood:</span><span>${esc(entity?.likelihood || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Abstraction:</span><span>${esc(entity?.abstraction || 'Standard')}</span></div>
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related Techniques (${entity?.techniques?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.techniques || []).map(t => `
                                <div class="detail-list-item" onclick="selectEntity('attack', '${escAttr(t)}')">
                                    <span class="id attack">${esc(t)}</span>
                                    <span>${esc(state.library.techniques[t]?.name || getTechniqueName(t))}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CWEs (${entity?.cwes?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.cwes || []).slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('cwe', '${escAttr(c)}')">
                                    <span class="id cwe">${esc(c)}</span>
                                    <span>${esc(state.library.cwes[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${(entity?.cwes?.length || 0) > 10 ? `<div class="list-info">+${entity.cwes.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        <a href="https://capec.mitre.org/data/definitions/${esc(id.replace('CAPEC-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--capec-color);">View on MITRE CAPEC â†’</a>
                    </div>
                `;
            } else if (type === 'cwe') {
                entity = state.library.cwes[id];
                name = entity?.name || 'Unknown';
                const relatedCapecs = state.cweToCapec[id] || entity?.capecs || [];

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <p>${esc(entity?.description || 'No description available.')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Abstraction</h4>
                        <p>${esc(entity?.abstraction || 'Base')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length > 10 ? `<div class="list-info">+${relatedCapecs.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        <a href="https://cwe.mitre.org/data/definitions/${esc(id.replace('CWE-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--cwe-color);">View on MITRE CWE â†’</a>
                    </div>
                `;
            }

            return { id, name, html };
        }

        function buildMetadataSummary(type, id, phaseKey, instanceId) {
            const assignment = phaseKey ? findAssignment(phaseKey, type, id, instanceId) : null;
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            const score = metadata.score || 'unclassified';
            const scoreLabel = SCORE_LEVELS[score]?.label || 'Unclassified';
            const confidence = metadata.confidence ? `${metadata.confidence}% (${getConfidenceLabel(metadata.confidence)})` : 'Unknown';
            const safePhase = phaseKey ? `${phaseKey.split(':')[0]} â€” ${formatPhaseName(phaseKey.split(':')[1])}` : '';

            const links = (metadata.hyperlinks || []).filter(l => l?.url && /^https?:\/\//i.test(l.url));
            const linksHtml = links.length
                ? links.map(l => `
                    <div class="detail-list-item">
                        <a href="${escAttr(l.url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(l.label || l.url)} â†’
                        </a>
                    </div>
                `).join('')
                : '<div class="list-info">No hyperlinks</div>';

            const observables = metadata.observables || [];
            const observablesHtml = observables.length
                ? observables.map(o => `
                    <div class="detail-list-item">
                        <span>${esc(o.type)}</span>
                        <span>${esc(o.value)}</span>
                    </div>
                `).join('')
                : '<div class="list-info">No observables</div>';

            return `
                <div class="detail-section">
                    <h4>Metadata</h4>
                    <div class="detail-list">
                        <div class="detail-list-item"><span>Score:</span><span>${esc(scoreLabel)}</span></div>
                        <div class="detail-list-item"><span>Confidence:</span><span>${esc(confidence)}</span></div>
                        ${safePhase ? `<div class="detail-list-item"><span>Phase:</span><span>${esc(safePhase)}</span></div>` : ''}
                        ${metadata.cveId ? `<div class="detail-list-item"><span>CVE:</span><span>${esc(metadata.cveId)}</span></div>` : ''}
                        ${metadata.cvssVector ? `<div class="detail-list-item"><span>CVSS:</span><span>${esc(metadata.cvssVector)}</span></div>` : ''}
                    </div>
                </div>
                ${metadata.comments ? `
                <div class="detail-section">
                    <h4>Comments</h4>
                    <p>${esc(metadata.comments).replace(/\n/g, '<br>')}</p>
                </div>
                ` : ''}
                <div class="detail-section">
                    <h4>Hyperlinks</h4>
                    <div class="detail-list">
                        ${linksHtml}
                    </div>
                </div>
                <div class="detail-section">
                    <h4>Observables</h4>
                    <div class="detail-list">
                        ${observablesHtml}
                    </div>
                </div>
            `;
        }

        function openEntityModal(type, id, phaseKey, instanceId) {
            if (!type || !id) return;
            const detail = buildEntityDetail(type, id);
            document.getElementById('entity-modal-id').textContent = detail.id;
            document.getElementById('entity-modal-name').textContent = detail.name;
            const content = document.getElementById('entity-modal-content');
            content.innerHTML = detail.html + buildMetadataSummary(type, id, phaseKey, instanceId);
            document.getElementById('entity-modal').classList.add('visible');
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type, id };
        }

        function closeEntityModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('entity-modal').classList.remove('visible');
        }

        function showDetail(type, id) {
            const panel = document.getElementById('detail-panel');
            const idEl = document.getElementById('detail-id');
            const nameEl = document.getElementById('detail-name');
            const contentEl = document.getElementById('detail-content');
            
            panel.classList.add('visible');
            idEl.className = `detail-id ${type}`;
            
            const detail = buildEntityDetail(type, id);
            idEl.textContent = detail.id;
            nameEl.textContent = detail.name;
            contentEl.innerHTML = detail.html;
            
            // Set current assignment in dropdown
        }

        function closeDetail() {
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type: null, id: null };
            filterEntities(state.activeTab);
        }

        function findEntityPhase(type, id) {
            for (const [phase, data] of Object.entries(state.assignments)) {
                const items = getAllPhaseItemsByType(data, type);
                if (items.some(a => getAssignmentId(a) === id)) return phase;
            }
            return null;
        }

        // ============================================================
        // DRAG & DROP
        // ============================================================
        let dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };

        function handleDragStart(event, type, id) {
            dragData = { kind: 'item', type, id, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);
            
            // Highlight all phases as potential drop targets
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            
            // Remove drop target highlighting
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.remove('drop-target');
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            event.currentTarget.style.background = 'rgba(113, 113, 122, 0.25)';
        }

        function handleDragLeave(event) {
            event.currentTarget.style.background = '';
        }

        function handleDrop(event, phaseKey) {
            event.preventDefault();
            event.currentTarget.style.background = '';
            
            const { kind, type, id, fromPhase, instanceId, groupId, sourceGroupId } = dragData;
            if (!kind) return;

            if (kind === 'group') {
                if (!fromPhase || !groupId) return;
                moveGroupBetweenPhases(fromPhase, phaseKey, groupId);
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                return;
            }
            
            if (!type || !id) return;
            
            const key = type === 'attack' ? 'techniques' : type === 'capec' ? 'capecs' : 'cwes';
            if (fromPhase && fromPhase === phaseKey && !sourceGroupId) {
                return;
            }

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }
            
            // Add to target phase with metadata (new format)
            if (state.assignments[phaseKey]) {
                const newAssignment = {
                    id: id,
                    metadata: existingMetadata || createDefaultMetadata(),
                    instanceId: instanceId || createAssignmentInstanceId()
                };
                state.assignments[phaseKey][key].push(newAssignment);
                ensurePhaseLayout(phaseKey, state.assignments[phaseKey]);
                showToast(`${id} â†’ ${formatPhaseName(phaseKey.split(':')[1])}`);
            }
            
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function handleAssignmentDragStart(event, type, id, phaseKey, instanceId, sourceGroupId) {
            dragData = { kind: 'item', type, id, fromPhase: phaseKey, instanceId, groupId: null, sourceGroupId };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDragStart(event, phaseKey, groupId) {
            dragData = { kind: 'group', type: null, id: null, fromPhase: phaseKey, instanceId: null, groupId, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `group:${groupId}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDrop(event, phaseKey, groupId) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-target');
            
            const { kind, type, id, fromPhase, instanceId, sourceGroupId } = dragData;
            if (kind !== 'item' || !type || !id) return;
            if (sourceGroupId && sourceGroupId === groupId) return;

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }

            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;

            const assignment = {
                id,
                metadata: existingMetadata || createDefaultMetadata(),
                instanceId: instanceId || createAssignmentInstanceId(),
                type
            };
            group.items = group.items || [];
            group.items.push(assignment);
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        // ============================================================
        // KILL CHAIN RENDERING
        // ============================================================
        function renderKillChain() {
            const container = document.getElementById('kill-chain');
            let html = '';
            
            for (const [superPhaseId, superPhase] of Object.entries(KILL_CHAIN)) {
                html += `
                    <div class="super-phase ${superPhaseId.toLowerCase()}">
                        <div class="super-phase-header">${superPhaseId} - ${superPhase.name}</div>
                        <div class="super-phase-content">
                `;
                
                for (const phaseId of superPhase.phases) {
                    const phaseKey = `${superPhaseId}:${phaseId}`;
                    const phaseData = state.assignments[phaseKey] || { techniques: [], capecs: [], cwes: [], groups: [], layout: [] };
                    
                    const techCount = state.layers.attack ? getAllPhaseItemsByType(phaseData, 'attack').length : 0;
                    const capecCount = state.layers.capec ? getAllPhaseItemsByType(phaseData, 'capec').length : 0;
                    const cweCount = state.layers.cwe ? getAllPhaseItemsByType(phaseData, 'cwe').length : 0;
                    const totalCount = techCount + capecCount + cweCount;
                    const isHidden = state.hideEmpty && totalCount === 0;
                    
                    ensurePhaseLayout(phaseKey, phaseData);

                    html += `
                        <div class="phase ${totalCount === 0 ? 'empty' : ''} ${isHidden ? 'hidden' : ''}" data-phase="${phaseKey}"
                             ondragover="handleDragOver(event)"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${phaseKey}')">
                            <div class="phase-header" onclick="togglePhase(this)">
                                <div class="phase-title">
                                    <span class="phase-name">${formatPhaseName(phaseId)}</span>
                                    <span class="phase-count ${totalCount === 0 ? 'zero' : ''}">${totalCount}</span>
                                </div>
                                <div class="phase-header-actions">
                                    <button class="phase-group-btn" onclick="event.stopPropagation(); createGroup('${phaseKey}')">+ Group</button>
                                    <span class="phase-toggle">â–¼</span>
                                </div>
                            </div>
                            <div class="phase-content">
                    `;

                    for (const entry of phaseData.layout) {
                        if (entry.kind === 'item') {
                            const list = getPhaseUngroupedItems(phaseData, entry.type);
                            const assignment = list.find(a => getAssignmentInstanceId(a) === entry.instanceId);
                            if (!assignment) continue;
                            const id = getAssignmentId(assignment);
                            const meta = getAssignmentMetadata(assignment);
                            if (entry.type === 'capec' && state.layers.capec) {
                                html += renderEntityTag('capec', id, state.library.capecs[id]?.name || '', meta, phaseKey, getAssignmentInstanceId(assignment), null);
                            }
                            if (entry.type === 'attack' && state.layers.attack) {
                                html += renderEntityTag('attack', id, state.library.techniques[id]?.name || '', meta, phaseKey, getAssignmentInstanceId(assignment), null);
                            }
                            if (entry.type === 'cwe' && state.layers.cwe) {
                                html += renderEntityTag('cwe', id, state.library.cwes[id]?.name || '', meta, phaseKey, getAssignmentInstanceId(assignment), null);
                            }
                        }

                        if (entry.kind === 'group') {
                            const group = (phaseData.groups || []).find(g => g.groupId === entry.groupId);
                            if (!group) continue;
                            const collapsedClass = group.collapsed ? 'collapsed' : '';
                            const groupItems = group.items || [];
                            const safeGroupLabel = esc(group.label || 'Group');
                            const groupHeaderClick = group.editing
                                ? 'event.stopPropagation();'
                                : `toggleGroupCollapse('${phaseKey}', '${group.groupId}')`;
                            const groupDragStart = group.editing
                                ? 'event.preventDefault();'
                                : `handleGroupDragStart(event, '${phaseKey}', '${group.groupId}')`;
                            html += `
                                <div class="phase-group ${collapsedClass}" data-group-id="${escAttr(group.groupId)}" ondragover="event.stopPropagation(); handleDragOver(event)" ondragleave="event.stopPropagation(); handleDragLeave(event)" ondrop="handleGroupDrop(event, '${phaseKey}', '${group.groupId}')">
                                    <div class="phase-group-header" draggable="${group.editing ? 'false' : 'true'}" ondragstart="${groupDragStart}" ondragend="handleDragEnd(event)" onclick="${groupHeaderClick}">
                                        ${group.editing ? `
                                            <input class="metadata-input" id="group-rename-${escAttr(group.groupId)}" value="${safeGroupLabel}"
                                                onclick="event.stopPropagation()" onmousedown="event.stopPropagation()"
                                                onblur="commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value)"
                                                onkeydown="if (event.key === 'Enter') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value); } if (event.key === 'Escape') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value, true); }" />
                                        ` : `<span class="phase-group-title">${safeGroupLabel}</span>`}
                                        <span class="phase-group-count">${groupItems.length}</span>
                                        <span class="group-header-actions">
                                            <span class="group-actions">
                                                <button class="group-action-btn rename" title="Rename" onclick="event.stopPropagation(); startRenameGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                                                </button>
                                                <button class="group-action-btn delete" title="Delete Group" onclick="event.stopPropagation(); removeGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"></path></svg>
                                                </button>
                                            </span>
                                            <span class="phase-group-toggle">â–¼</span>
                                        </span>
                                    </div>
                                    <div class="phase-group-content">
                                        ${groupItems.map(item => {
                                            const type = item.type;
                                            const id = getAssignmentId(item);
                                            const meta = getAssignmentMetadata(item);
                                            const instanceId = getAssignmentInstanceId(item);
                                            if (type === 'capec' && state.layers.capec) {
                                                return renderEntityTag('capec', id, state.library.capecs[id]?.name || '', meta, phaseKey, instanceId, group.groupId);
                                            }
                                            if (type === 'attack' && state.layers.attack) {
                                                return renderEntityTag('attack', id, state.library.techniques[id]?.name || '', meta, phaseKey, instanceId, group.groupId);
                                            }
                                            if (type === 'cwe' && state.layers.cwe) {
                                                return renderEntityTag('cwe', id, state.library.cwes[id]?.name || '', meta, phaseKey, instanceId, group.groupId);
                                            }
                                            return '';
                                        }).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    if (totalCount === 0) {
                        html += `<div class="list-info">Empty</div>`;
                    }
                    
                    html += `</div></div>`;
                }
                
                html += `</div></div>`;
            }
            
            container.innerHTML = html;
            renderStats();
        }

        // Render a single entity tag with metadata indicators
        function renderEntityTag(type, id, name, metadata, phaseKey, instanceId, sourceGroupId = null) {
            const tagClass = type === 'attack' ? 'technique-tag' : type === 'capec' ? 'capec-tag' : 'cwe-tag';
            const score = metadata.score || 'unclassified';
            const safeId = InputSecurity.escapeHtml(id);
            const displayName = truncateAtBoundary(name || '', 500);
            const safeName = InputSecurity.escapeHtml(displayName || '');
            const safeType = InputSecurity.sanitizeAttr(type, 20);
            const safeIdAttr = InputSecurity.sanitizeAttr(id);
            const safePhaseKey = InputSecurity.sanitizeAttr(phaseKey);
            const safeInstanceId = InputSecurity.sanitizeAttr(instanceId || '');
            const safeGroupId = InputSecurity.sanitizeAttr(sourceGroupId || '');
            let domainBadge = '';
            if (type === 'attack') {
                const domain = state.library.techniques[id]?.domain || detectDomain(id);
                const label = domain === 'enterprise' ? 'ENT' : domain === 'mobile' ? 'MOB' : domain === 'ics' ? 'ICS' : '';
                if (label) {
                    domainBadge = `<span class="domain-badge">${label}</span>`;
                }
            }
            
            // Build metadata icons
            let metaIcons = '';
            const hasComment = metadata.comments && metadata.comments.trim().length > 0;
            const hasLinks = metadata.hyperlinks && metadata.hyperlinks.length > 0;
            const hasObservables = metadata.observables && metadata.observables.length > 0;
            const hasCve = metadata.cveId && metadata.cveId.trim().length > 0;
            const hasConfidence = metadata.confidence !== null && metadata.confidence !== undefined && metadata.confidence > 0;
            
            if (hasCve || hasObservables || hasLinks || hasComment || hasConfidence) {
                metaIcons = '<div class="metadata-icons">';
                if (hasCve) metaIcons += `<span class="meta-icon has-cve" title="${esc(metadata.cveId)}">
                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                    <span>${esc(metadata.cveId)}</span>
                </span>`;
                if (hasObservables) metaIcons += '<span class="meta-icon has-observable" title="Has Observables"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg></span>';
                if (hasLinks) metaIcons += '<span class="meta-icon has-link" title="Has Links"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg></span>';
                if (hasComment) metaIcons += '<span class="meta-icon has-comment" title="Has Comments"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg></span>';
                if (hasConfidence) metaIcons += `<span class="meta-icon has-confidence" title="Confidence: ${metadata.confidence}%"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg><span>${metadata.confidence}%</span></span>`;
                metaIcons += '</div>';
            }
            
            return `
                <div class="${tagClass}" data-score="${score}" 
                     draggable="true"
                     ondragstart="handleAssignmentDragStart(event, '${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}', '${safeGroupId}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openEntityModal('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                    <span class="tag-header-row">
                        <span class="id" onclick="event.stopPropagation(); selectEntity('${safeType}', '${safeIdAttr}')">${safeId}</span>
                        ${domainBadge}
                        <span class="remove" title="Remove" onclick="event.stopPropagation(); removeAssignment('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"/></svg>
                            </span>
                        <span class="tag-actions">
                            <button class="tag-action-btn explore" onclick="event.stopPropagation(); openEntityExplorer('${safeType}', '${safeIdAttr}')" title="Explore Entity Relationships">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M256 128C256 110.3 270.3 96 288 96L352 96C369.7 96 384 110.3 384 128L384 192C384 209.7 369.7 224 352 224L344 224L344 288L464 288C503.8 288 536 320.2 536 360L536 416L544 416C561.7 416 576 430.3 576 448L576 512C576 529.7 561.7 544 544 544L480 544C462.3 544 448 529.7 448 512L448 448C448 430.3 462.3 416 480 416L488 416L488 360C488 346.7 477.3 336 464 336L344 336L344 416L352 416C369.7 416 384 430.3 384 448L384 512C384 529.7 369.7 544 352 544L288 544C270.3 544 256 529.7 256 512L256 448C256 430.3 270.3 416 288 416L296 416L296 336L176 336C162.7 336 152 346.7 152 360L152 416L160 416C177.7 416 192 430.3 192 448L192 512C192 529.7 177.7 544 160 544L96 544C78.3 544 64 529.7 64 512L64 448C64 430.3 78.3 416 96 416L104 416L104 360C104 320.2 136.2 288 176 288L296 288L296 224L288 224C270.3 224 256 209.7 256 192L256 128z"/></svg>
                            </button>
                            <button class="tag-action-btn edit" onclick="event.stopPropagation(); closeEntityModal(); openMetadataEditor('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')" title="Edit Metadata">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                            </button>
                        </span>
                    </span>
                    <div class="tag-body">
                        <span class="name">${safeName}</span>
                    </div>
                    <div class="tag-footer">
                        ${metaIcons}
                    </div>
                </div>
            `;
        }

        // ============================================================
        // RELATIONSHIP VIEW RENDERING
        // ============================================================
        function renderRelationshipView() {
            const container = document.getElementById('relationship-chain');
            
            // Build relationship chains from assigned CAPECs
            const chains = [];
            
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                // For each assigned CAPEC
                const capecAssignments = getAllPhaseItemsByType(phaseData, 'capec');
                for (const capecAssignment of capecAssignments) {
                    const capecId = getAssignmentId(capecAssignment);
                    const capec = state.library.capecs[capecId];
                    if (!capec) continue;
                    
                    // Get CWEs related to this CAPEC
                    const relatedCwes = capec.cwes || [];
                    
                    // Get techniques related to this CAPEC that are in this phase
                    const assignedTechIds = getAllPhaseItemsByType(phaseData, 'attack').map(t => getAssignmentId(t));
                    const relatedTechs = (capec.techniques || []).filter(t => 
                        assignedTechIds.includes(t) || state.library.techniques[t]
                    );
                    
                    chains.push({
                        capec: { id: capecId, name: capec.name },
                        cwes: relatedCwes.slice(0, 5).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })),
                        techniques: relatedTechs.slice(0, 5).map(id => ({ id, name: state.library.techniques[id]?.name || getTechniqueName(id) })),
                        phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                    });
                }
                
                // For assigned techniques without CAPEC, create partial chains
                const assignedCapecIds = getAllPhaseItemsByType(phaseData, 'capec').map(c => getAssignmentId(c));
                const techAssignments = getAllPhaseItemsByType(phaseData, 'attack');
                for (const techAssignment of techAssignments) {
                    const techId = getAssignmentId(techAssignment);
                    const relatedCapecs = state.techniqueToCapec[techId] || [];
                    // Only show if technique has no assigned CAPEC in this phase
                    const hasCapecInPhase = relatedCapecs.some(c => assignedCapecIds.includes(c));
                    if (!hasCapecInPhase && relatedCapecs.length > 0) {
                        const capecId = relatedCapecs[0];
                        const capec = state.library.capecs[capecId];
                        chains.push({
                            capec: capec ? { id: capecId, name: capec.name } : null,
                            cwes: capec?.cwes?.slice(0, 3).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })) || [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                        });
                    } else if (relatedCapecs.length === 0) {
                        // Technique with no CAPEC
                        chains.push({
                            capec: null,
                            cwes: [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                        });
                    }
                }
            }
            
            if (chains.length === 0) {
                container.innerHTML = `<div class="relationship-empty">No relationships to display.<br>Assign techniques, CAPECs, or CWEs to phases first.</div>`;
                return;
            }
            
            let html = '';
            for (const chain of chains) {
                html += `
                    <div class="relationship-row">
                        <div class="relationship-cell capec">
                            <div class="relationship-cell-header">CAPEC</div>
                            ${chain.capec ? `
                                <div class="relationship-item" onclick="selectEntity('capec', '${escAttr(chain.capec.id)}')">
                                    <span class="id capec">${esc(chain.capec.id)}</span>
                                    <span class="name">${esc(chain.capec.name)}</span>
                                </div>
                            ` : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell cwe">
                            <div class="relationship-cell-header">CWE</div>
                            ${chain.cwes.length > 0 ? chain.cwes.map(cwe => `
                                <div class="relationship-item" onclick="selectEntity('cwe', '${escAttr(cwe.id)}')">
                                    <span class="id cwe">${esc(cwe.id)}</span>
                                    <span class="name">${esc(cwe.name)}</span>
                                </div>
                            `).join('') : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell attack">
                            <div class="relationship-cell-header">ATT&CK</div>
                            ${chain.techniques.map(tech => `
                                <div class="relationship-item" onclick="selectEntity('attack', '${escAttr(tech.id)}')">
                                    <span class="id attack">${esc(tech.id)}</span>
                                    <span class="name">${esc(tech.name)}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="relationship-cell phase">
                            <div class="relationship-cell-header">Phase</div>
                            <div class="relationship-item">
                                <span class="id phase">${esc(chain.phase.key.split(':')[0])}</span>
                                <span class="name">${esc(chain.phase.name)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function renderStats() {
            const statsEl = document.getElementById('stats-bar');
            
            let phasesUsed = 0;
            const techSet = new Set(), capecSet = new Set(), cweSet = new Set();
            
            for (const phase of Object.values(state.assignments)) {
                const allTechs = getAllPhaseItemsByType(phase, 'attack');
                const allCapecs = getAllPhaseItemsByType(phase, 'capec');
                const allCwes = getAllPhaseItemsByType(phase, 'cwe');
                if (allTechs.length + allCapecs.length + allCwes.length > 0) phasesUsed++;
                allTechs.forEach(t => techSet.add(getAssignmentId(t)));
                allCapecs.forEach(c => capecSet.add(getAssignmentId(c)));
                allCwes.forEach(w => cweSet.add(getAssignmentId(w)));
            }
            
            statsEl.innerHTML = `
                <div class="stat"><div class="stat-value">${techSet.size}</div><div class="stat-label">Techniques</div></div>
                <div class="stat"><div class="stat-value">${capecSet.size}</div><div class="stat-label">CAPECs</div></div>
                <div class="stat"><div class="stat-value">${cweSet.size}</div><div class="stat-label">CWEs</div></div>
                <div class="stat"><div class="stat-value">${phasesUsed}/18</div><div class="stat-label">Phases</div></div>
            `;
        }

        function togglePhase(header) {
            header.parentElement.classList.toggle('minimized');
        }

        function removeAssignment(type, id, phaseKey, instanceId) {
            const key = type === 'attack' ? 'techniques' : type === 'capec' ? 'capecs' : 'cwes';
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            if (!window.confirm('Remove this item?')) return;
            const assignments = phaseData[key];
            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                assignments.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                showToast('Item removed.');
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(item => getAssignmentInstanceId(item) === instanceId);
                if (gIdx !== -1) {
                    group.items.splice(gIdx, 1);
                    renderKillChain();
                    filterEntities(state.activeTab);
                    if (state.view === 'relationship') {
                        renderRelationshipView();
                    }
                    showToast('Item removed.');
                    return;
                }
            }
        }

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        function expandAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('minimized'));
        }

        function collapseAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.add('minimized'));
        }

        function clearAssignments() {
            initAssignments();
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
            showToast('Cleared all assignments');
        }

        function exportJSON() {
            const exportData = {
                version: APP_VERSION,
                schema: 'killchain-export-lite',
                exportedAt: new Date().toISOString(),
                view: state.view,
                activeTab: state.activeTab,
                filters: state.filters,
                layers: state.layers,
                hideEmpty: state.hideEmpty,
                assignments: state.assignments,
                selection: state.selection
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'attack-chain-export.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported JSON');
        }

        function triggerImportKillChain() {
            const input = document.getElementById('import-killchain-input');
            if (input) input.click();
        }

        function ensureAssignmentShape(assignments) {
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseData) continue;
                phaseData.groups = Array.isArray(phaseData.groups) ? phaseData.groups : [];
                phaseData.layout = Array.isArray(phaseData.layout) ? phaseData.layout : [];

                for (const key of ['techniques', 'capecs', 'cwes']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    phaseData[key] = list.map(a => migrateAssignment(a));
                }

                phaseData.groups = phaseData.groups.map(group => {
                    const items = Array.isArray(group.items) ? group.items : [];
                    return {
                        groupId: group.groupId || generateGroupId(),
                        label: sanitizeImportedString(group.label || 'Group', 80),
                        collapsed: !!group.collapsed,
                        items: items.map(item => ({
                            ...migrateAssignment(item),
                            type: item.type || 'attack'
                        }))
                    };
                });

                ensurePhaseLayout(phaseKey, phaseData);
                assignments[phaseKey] = phaseData;
            }
        }

        function ensureLibraryFallbacks(assignments) {
            for (const phaseData of Object.values(assignments)) {
                const allTechs = getAllPhaseItemsByType(phaseData, 'attack');
                const allCapecs = getAllPhaseItemsByType(phaseData, 'capec');
                const allCwes = getAllPhaseItemsByType(phaseData, 'cwe');

                for (const tech of allTechs) {
                    const id = getAssignmentId(tech);
                    if (!state.library.techniques[id]) {
                        state.library.techniques[id] = {
                            id,
                            name: getTechniqueName(id),
                            domain: detectDomain(id)
                        };
                    }
                }
                for (const capec of allCapecs) {
                    const id = getAssignmentId(capec);
                    if (!state.library.capecs[id]) {
                        state.library.capecs[id] = { id, name: id };
                    }
                }
                for (const cwe of allCwes) {
                    const id = getAssignmentId(cwe);
                    if (!state.library.cwes[id]) {
                        state.library.cwes[id] = { id, name: id };
                    }
                }
            }
        }

        // Validation and sanitization for imported kill chain data
        const KILLCHAIN_IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024,  // 5 MB
            maxAssignmentsPerPhase: 500,
            maxHyperlinks: 50,
            maxObservables: 100,
            maxStringLength: 5000
        };

        function validateKillChainImport(data) {
            if (!data || typeof data !== 'object') {
                return { valid: false, error: 'Invalid export format: expected object' };
            }

            const assignments = data.assignments;
            if (!assignments || typeof assignments !== 'object') {
                return { valid: false, error: 'Missing or invalid assignments object' };
            }

            // Validate schema version if present
            if (data.schemaVersion && !/^\d+\.\d+(\.\d+)?$/.test(data.schemaVersion)) {
                return { valid: false, error: 'Invalid schema version format' };
            }

            // Validate phase keys and structure
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseKey.includes(':')) {
                    return { valid: false, error: `Invalid phase key format: ${phaseKey}` };
                }
                if (!phaseData || typeof phaseData !== 'object') {
                    return { valid: false, error: `Invalid phase data for: ${phaseKey}` };
                }

                // Check assignment counts
                for (const key of ['techniques', 'capecs', 'cwes']) {
                    const list = phaseData[key];
                    if (list && !Array.isArray(list)) {
                        return { valid: false, error: `${key} must be an array in ${phaseKey}` };
                    }
                    if (list && list.length > KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase) {
                        return { valid: false, error: `Too many ${key} in ${phaseKey} (max ${KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase})` };
                    }
                }

                if (phaseData.groups && !Array.isArray(phaseData.groups)) {
                    return { valid: false, error: `groups must be an array in ${phaseKey}` };
                }
            }

            return { valid: true };
        }

        function sanitizeImportedString(str, maxLength = KILLCHAIN_IMPORT_LIMITS.maxStringLength) {
            if (str === null || str === undefined) return '';
            if (typeof str !== 'string') return '';
            // Normalize, remove dangerous chars, limit length
            return String(str)
                .replace(/[\x00-\x1F\x7F]/g, '')  // Control chars
                .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Script tags
                .replace(/on\w+\s*=/gi, '')  // Event handlers (onmouseover=, onerror=, etc.)
                .replace(/[\[\]\{\};"'`]/g, '')  // Blocked chars including double quotes
                .replace(/--+/g, '')  // SQL comments
                .replace(/</g, '&lt;').replace(/>/g, '&gt;')  // Encode angle brackets
                .trim()
                .slice(0, maxLength);
        }

        function sanitizeImportedAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') return null;

            // ID validation - must match expected patterns
            const id = assignment.id || assignment.entityId;
            if (typeof id !== 'string') return null;
            
            // Validate ID format (T1234, T1234.001, CAPEC-123, CWE-123)
            if (!/^(T\d{4}(\.\d{3})?|CAPEC-\d+|CWE-\d+)$/.test(id)) {
                return null;  // Reject invalid ID patterns
            }

            // Extract metadata from either nested or flat structure
            const sourceMeta = assignment.metadata || assignment;
            const metadata = {
                score: 'unclassified',
                confidence: null,
                comments: '',
                cveId: '',
                cvssVector: '',
                hyperlinks: [],
                observables: []
            };

            // Sanitize score - must be valid enum
            const validScores = ['unclassified', 'low', 'medium', 'high', 'critical'];
            if (sourceMeta.score && validScores.includes(sourceMeta.score)) {
                metadata.score = sourceMeta.score;
            }

            // Sanitize confidence - must be number 0-100
            if (typeof sourceMeta.confidence === 'number') {
                metadata.confidence = Math.max(0, Math.min(100, Math.floor(sourceMeta.confidence)));
            }

            // Sanitize CVE - must match pattern (handle both cveId and cve field names)
            const cveSource = sourceMeta.cveId || sourceMeta.cve;
            if (cveSource && typeof cveSource === 'string') {
                const cve = cveSource.trim();
                if (/^CVE-\d{4}-\d{4,}$/.test(cve)) {
                    metadata.cveId = cve;
                }
            }

            // Sanitize CVSS vector (handle both cvssVector and cvss field names)
            const cvssSource = sourceMeta.cvssVector || sourceMeta.cvss;
            if (cvssSource && typeof cvssSource === 'string') {
                const cvss = cvssSource.trim();
                if (/^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(cvss)) {
                    metadata.cvssVector = cvss;
                }
            }

            // Sanitize comments
            if (sourceMeta.comments) {
                metadata.comments = sanitizeImportedString(sourceMeta.comments, 2000);
            }

            // Sanitize hyperlinks array
            if (Array.isArray(sourceMeta.hyperlinks)) {
                metadata.hyperlinks = sourceMeta.hyperlinks
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxHyperlinks)
                    .filter(h => h && typeof h === 'object')
                    .map(h => ({
                        label: sanitizeImportedString(h.label || '', 200),
                        url: (typeof h.url === 'string' && /^https?:\/\//.test(h.url)) 
                            ? sanitizeImportedString(h.url, 2000) 
                            : ''
                    }))
                    .filter(h => h.url);  // Keep only valid URLs
            }

            // Sanitize observables array
            if (Array.isArray(sourceMeta.observables)) {
                const validTypes = ['ipv4-addr', 'ipv6-addr', 'domain-name', 'url', 'file-hash-md5', 
                    'file-hash-sha1', 'file-hash-sha256', 'file-name', 'email-addr', 'threat-actor', 'other'];
                metadata.observables = sourceMeta.observables
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxObservables)
                    .filter(o => o && typeof o === 'object' && validTypes.includes(o.type))
                    .map(o => ({
                        type: o.type,
                        value: sanitizeImportedString(o.value || '', 500)
                    }))
                    .filter(o => o.value);
            }

            return { id: id, metadata: metadata, instanceId: assignment.instanceId || createAssignmentInstanceId() };
        }

        function sanitizeImportedData(data) {
            const sanitized = {
                assignments: {}
            };

            // Sanitize assignments
            for (const [phaseKey, phaseData] of Object.entries(data.assignments || {})) {
                sanitized.assignments[phaseKey] = {
                    techniques: [],
                    capecs: [],
                    cwes: [],
                    groups: [],
                    layout: Array.isArray(phaseData.layout) ? phaseData.layout : []
                };

                for (const key of ['techniques', 'capecs', 'cwes']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    sanitized.assignments[phaseKey][key] = list
                        .map(a => sanitizeImportedAssignment(a))
                        .filter(a => a !== null);
                }

                if (Array.isArray(phaseData.groups)) {
                    sanitized.assignments[phaseKey].groups = phaseData.groups
                        .filter(g => g && typeof g === 'object')
                        .map(g => {
                            const rawItems = Array.isArray(g.items) ? g.items : [];
                            const items = rawItems
                                .map(item => {
                                    const sanitizedItem = sanitizeImportedAssignment(item);
                                    if (!sanitizedItem) return null;
                                    const type = ['attack', 'capec', 'cwe'].includes(item.type) ? item.type : null;
                                    if (!type) return null;
                                    return { ...sanitizedItem, type };
                                })
                                .filter(item => item && item.id && item.type);

                            return {
                                groupId: typeof g.groupId === 'string' ? g.groupId : generateGroupId(),
                                label: sanitizeImportedString(g.label || 'Group', 80),
                                collapsed: !!g.collapsed,
                                items
                            };
                        });
                }
            }

            // Sanitize optional view state (booleans/strings only)
            if (data.layers && typeof data.layers === 'object') {
                sanitized.layers = {
                    attack: !!data.layers.attack,
                    capec: !!data.layers.capec,
                    cwe: !!data.layers.cwe
                };
            }

            if (typeof data.hideEmpty === 'boolean') {
                sanitized.hideEmpty = data.hideEmpty;
            }

            if (typeof data.view === 'string' && ['killchain', 'relations'].includes(data.view)) {
                sanitized.view = data.view;
            }

            if (typeof data.activeTab === 'string' && ['attack', 'capec', 'cwe'].includes(data.activeTab)) {
                sanitized.activeTab = data.activeTab;
            }

            return sanitized;
        }

        function importKillChain(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check file size
            if (file.size > KILLCHAIN_IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large (max ${KILLCHAIN_IMPORT_LIMITS.maxFileSize / 1024 / 1024} MB)`);
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    const data = stripAngleBracketsFromJson(rawData);

                    // Validate structure before processing
                    const validation = validateKillChainImport(data);
                    if (!validation.valid) {
                        throw new Error(validation.error);
                    }

                    // Sanitize all imported data
                    const sanitized = sanitizeImportedData(data);

                    // Reset assignments and load sanitized state
                    initAssignments();
                    for (const [phaseKey, phaseData] of Object.entries(sanitized.assignments)) {
                        if (state.assignments[phaseKey]) {
                            state.assignments[phaseKey] = phaseData;
                        }
                    }

                    ensureAssignmentShape(state.assignments);
                    ensureLibraryFallbacks(state.assignments);

                    // Restore sanitized view state
                    if (sanitized.layers) state.layers = sanitized.layers;
                    if (sanitized.hideEmpty !== undefined) state.hideEmpty = sanitized.hideEmpty;
                    if (sanitized.activeTab) state.activeTab = sanitized.activeTab;

                    // Apply UI state
                    document.getElementById('layer-attack').checked = !!state.layers.attack;
                    document.getElementById('layer-capec').checked = !!state.layers.capec;
                    document.getElementById('layer-cwe').checked = !!state.layers.cwe;
                    document.getElementById('btn-hide-empty').classList.toggle('active', !!state.hideEmpty);

                    if (sanitized.view) {
                        setView(sanitized.view);
                    } else {
                        renderKillChain();
                    }

                    switchTab(state.activeTab);
                    renderAll();
                    showToast('Imported kill chain');
                } catch (err) {
                    showToast('Import failed: ' + InputSecurity.escapeHtml(err.message));
                }
            };

            reader.readAsText(file);
            event.target.value = '';
        }

        function exportCSV() {
            // Build CSV with phases as header columns
            // Format: Entity Type, Entity ID, Entity Name, Score, Confidence, CVE, Comments, Phase1, Phase2, ...
            
            const headers = ['Type', 'ID', 'Name', 'Score', 'Confidence', 'CVE', 'Comments', ...ALL_PHASES.map(p => formatPhaseName(p.split(':')[1]))];
            const rows = [headers];
            
            // Collect all unique entities with their metadata
            const allTechs = new Map();  // id -> { phases: Set, metadata }
            const allCapecs = new Map();
            const allCwes = new Map();
            
            for (const [phaseKey, phase] of Object.entries(state.assignments)) {
                const techs = getAllPhaseItemsByType(phase, 'attack');
                const capecs = getAllPhaseItemsByType(phase, 'capec');
                const cwes = getAllPhaseItemsByType(phase, 'cwe');

                techs.forEach(t => {
                    const id = getAssignmentId(t);
                    if (!allTechs.has(id)) {
                        allTechs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(t) });
                    }
                    allTechs.get(id).phases.add(phaseKey);
                });
                capecs.forEach(c => {
                    const id = getAssignmentId(c);
                    if (!allCapecs.has(id)) {
                        allCapecs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(c) });
                    }
                    allCapecs.get(id).phases.add(phaseKey);
                });
                cwes.forEach(w => {
                    const id = getAssignmentId(w);
                    if (!allCwes.has(id)) {
                        allCwes.set(id, { phases: new Set(), metadata: getAssignmentMetadata(w) });
                    }
                    allCwes.get(id).phases.add(phaseKey);
                });
            }
            
            // Helper to format confidence for CSV
            const formatConfidence = (meta) => {
                if (meta.confidence === null || meta.confidence === undefined) return '';
                return `${meta.confidence}% (${getConfidenceLabel(meta.confidence)})`;
            };
            
            // Add technique rows
            for (const [techId, data] of allTechs) {
                const tech = state.library.techniques[techId];
                const meta = data.metadata;
                const row = [
                    'ATT&CK', 
                    techId, 
                    tech?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    meta.cveId || '',
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CAPEC rows
            for (const [capecId, data] of allCapecs) {
                const capec = state.library.capecs[capecId];
                const meta = data.metadata;
                const row = [
                    'CAPEC', 
                    capecId, 
                    capec?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    meta.cveId || '',
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CWE rows
            for (const [cweId, data] of allCwes) {
                const cwe = state.library.cwes[cweId];
                const meta = data.metadata;
                const row = [
                    'CWE', 
                    cweId, 
                    cwe?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    meta.cveId || '',
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Convert to CSV string
            // KCE-SEC-004: Prefix cells starting with formula characters to prevent injection
            const sanitizeForCsv = (value) => {
                const str = String(value);
                // Prefix with single quote if starts with formula characters
                if (/^[=+\-@\t\r]/.test(str)) {
                    return "'" + str;
                }
                return str;
            };
            
            const csvContent = rows.map(row => 
                row.map(cell => {
                    // Sanitize for formula injection, then escape quotes
                    const sanitized = sanitizeForCsv(cell);
                    const escaped = sanitized.replace(/"/g, '""');
                    return escaped.includes(',') || escaped.includes('"') || escaped.includes('\n') 
                        ? `"${escaped}"` 
                        : escaped;
                }).join(',')
            ).join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'attack-chain-export.csv';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported CSV');
        }

        // ============================================================
        // DROPDOWN UTILS
        // ============================================================
        function toggleDropdown(id) {
            const dropdown = document.getElementById(id);
            const isOpen = dropdown.classList.contains('open');
            closeDropdowns();
            if (!isOpen) {
                dropdown.classList.add('open');
            }
        }

        function closeDropdowns() {
            document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                closeDropdowns();
            }
        });

        // ============================================================
        // METADATA EDITOR
        // ============================================================
        let currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };

        function openMetadataEditor(type, id, phaseKey, instanceId) {
            currentMetadataEdit = { type, id, phaseKey, instanceId };
            
            // Find the assignment
            const assignment = findAssignment(phaseKey, type, id, instanceId);
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            
            // Populate form
            document.getElementById('metadata-entity-id').textContent = id;
            
            // Score selector (renamed from confidence)
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === (metadata.score || 'unclassified'));
                opt.onclick = () => selectScore(opt.dataset.value);
            });
            
            // Confidence slider (new percentage field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = metadata.confidence || 0;
            confidenceSlider.value = confidenceValue;
            updateConfidenceLabel(confidenceValue);
            confidenceSlider.oninput = (e) => updateConfidenceLabel(parseInt(e.target.value));
            
            // CVE and CVSS
            document.getElementById('meta-cve-id').value = metadata.cveId || '';
            document.getElementById('meta-cve-id-error').textContent = '';
            document.getElementById('meta-cvss-vector').value = metadata.cvssVector || '';
            document.getElementById('meta-cvss-vector-error').textContent = '';
            
            // Comments
            document.getElementById('meta-comments').value = metadata.comments || '';
            
            // Hyperlinks
            const hyperlinkList = document.getElementById('hyperlink-list');
            hyperlinkList.innerHTML = '';
            (metadata.hyperlinks || []).forEach((link, i) => {
                addHyperlinkRow(link.label, link.url);
            });
            
            // Observables
            const observableList = document.getElementById('observable-list');
            observableList.innerHTML = '';
            (metadata.observables || []).forEach((obs, i) => {
                addObservableRow(obs.type, obs.value);
            });
            
            // Show modal
            document.getElementById('metadata-editor-modal').classList.add('visible');
        }

        function closeMetadataEditor(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('metadata-editor-modal').classList.remove('visible');
            currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };
        }

        function selectScore(value) {
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === value);
            });
        }

        function updateConfidenceLabel(value) {
            const label = document.getElementById('confidence-label');
            const labelText = getConfidenceLabel(value);
            const labelClass = getConfidenceClass(value);
            label.textContent = value === 0 ? 'Unknown' : `${value}% (${labelText})`;
            label.className = `confidence-label ${labelClass}`;
        }

        function addHyperlinkRow(label = '', url = '') {
            const list = document.getElementById('hyperlink-list');
            const row = document.createElement('div');
            row.className = 'hyperlink-item';
            const labelInput = document.createElement('input');
            labelInput.type = 'text';
            labelInput.className = 'metadata-input';
            labelInput.placeholder = 'Label';
            labelInput.value = label || '';

            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.className = 'metadata-input';
            urlInput.placeholder = 'https://...';
            urlInput.value = url || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(labelInput);
            row.appendChild(urlInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function addObservableRow(type = 'ipv4-addr', value = '') {
            const list = document.getElementById('observable-list');
            const row = document.createElement('div');
            row.className = 'observable-item';
            const select = document.createElement('select');
            select.className = 'metadata-select';
            OBSERVABLE_TYPES.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.label;
                if (t.value === type) opt.selected = true;
                select.appendChild(opt);
            });

            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.className = 'metadata-input';
            valueInput.placeholder = 'Value';
            valueInput.value = value || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(select);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function saveMetadata() {
            const { type, id, phaseKey, instanceId } = currentMetadataEdit;
            if (!type || !id || !phaseKey) return;
            
            // Get score (renamed from confidence)
            const selectedScore = document.querySelector('#score-selector .score-option.selected');
            const score = selectedScore ? selectedScore.dataset.value : 'unclassified';
            
            // Get confidence percentage (new field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = parseInt(confidenceSlider.value) || 0;
            const confidence = confidenceValue === 0 ? null : confidenceValue;
            
            // Get CVE (with validation)
            const cveInput = document.getElementById('meta-cve-id');
            const cveValue = sanitizeForStorage(cveInput.value, 50);
            const cveError = document.getElementById('meta-cve-id-error');
            if (cveValue && !InputSecurity.validators.cveId(cveValue).valid) {
                cveError.textContent = 'Invalid CVE format (CVE-YYYY-NNNNN)';
                cveInput.classList.add('invalid');
                return;
            }
            cveError.textContent = '';
            cveInput.classList.remove('invalid');
            
            // Get CVSS (with validation)
            const cvssInput = document.getElementById('meta-cvss-vector');
            const cvssValue = sanitizeForStorage(cvssInput.value, 100);
            const cvssError = document.getElementById('meta-cvss-vector-error');
            if (cvssValue && !InputSecurity.validators.cvssVector(cvssValue).valid) {
                cvssError.textContent = 'Invalid CVSS 3.x vector';
                cvssInput.classList.add('invalid');
                return;
            }
            cvssError.textContent = '';
            cvssInput.classList.remove('invalid');
            
            // Get comments
            const comments = sanitizeForStorage(document.getElementById('meta-comments').value, 2000);
            
            // Get hyperlinks (with validation)
            const hyperlinks = [];
            document.querySelectorAll('#hyperlink-list .hyperlink-item').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const label = sanitizeForStorage(inputs[0].value, 100);
                const url = sanitizeForStorage(inputs[1].value, 500);
                if (label && url) {
                    if (InputSecurity.validators.url(url).valid) {
                        hyperlinks.push({ label, url });
                    }
                }
            });
            
            // Get observables (with validation)
            const observables = [];
            let hasInvalidObservable = false;
            document.querySelectorAll('#observable-list .observable-item').forEach(row => {
                const select = row.querySelector('select');
                const input = row.querySelector('input');
                const obsType = select.value;
                const obsValue = sanitizeForStorage(input.value, 500);
                
                if (obsValue) {
                    const validation = InputSecurity.validateObservable(obsType, obsValue);
                    if (validation.valid) {
                        observables.push({ type: obsType, value: obsValue });
                        input.classList.remove('invalid');
                    } else {
                        input.classList.add('invalid');
                        hasInvalidObservable = true;
                    }
                }
            });
            
            if (hasInvalidObservable) {
                showToast('Fix invalid observable values');
                return;
            }
            
            // Build new metadata
            const newMetadata = {
                score,
                confidence,
                cveId: cveValue,
                cvssVector: cvssValue,
                comments,
                hyperlinks,
                observables
            };
            
            // Update the assignment
            updateAssignmentMetadata(phaseKey, type, id, newMetadata, instanceId);
            
            // Close and re-render
            closeMetadataEditor();
            renderKillChain();
            showToast('Metadata saved');
        }

        // ============================================================
        // USAGE GUIDE
        // ============================================================
        function showUsageGuide() {
            document.getElementById('usage-guide-modal').classList.add('visible');
        }

        function closeUsageGuide(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('usage-guide-modal').classList.remove('visible');
        }

        // ============================================================
        // CHANGELOG MODAL
        // ============================================================
        async function showChangelog() {
            const modal = document.getElementById('changelog-modal');
            const content = document.getElementById('changelog-content');
            modal.classList.add('visible');
            
            try {
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                content.textContent = text;
            } catch (e) {
                content.textContent = 'Error loading changelog: ' + e.message;
            }
        }

        function closeChangelog(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('changelog-modal').classList.remove('visible');
        }

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeUsageGuide();
                closeChangelog();
                closeEntityModal();
                closeMetadataEditor();
            }
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderAll() {
            filterEntities('attack');
            filterEntities('capec');
            filterEntities('cwe');
            renderKillChain();
        }

        // ============================================================
        // LEAVE SITE CONFIRMATION
        // ============================================================
        function enableLeaveSiteConfirmation() {
            window.addEventListener('beforeunload', (e) => {
                e.preventDefault();
                e.returnValue = '';
                return '';
            });
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        initThemeControls();
        window.addEventListener('storage', (e) => {
            if (e.key === THEME_STORAGE_KEYS.mode) {
                syncThemeFromStorage();
            }
        });
        if (typeof CONFIG !== 'undefined') {
            if (CONFIG.navigation?.confirmOnLeave !== false) {
                enableLeaveSiteConfirmation();
            }
        } else {
            enableLeaveSiteConfirmation();
        }
        initAssignments();
        applyInputGuards();
        loadVersion();
        loadData();
    </script>
</body>
</html>
