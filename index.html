<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AttackFlow - Kill Chain Editor</title>
    <script src="config.js"></script>
    <script src="stix-config.js"></script>
    <style>
        :root {
            --phase-in: #10b981;
            --phase-through: #06b6d4;
            --phase-out: #ef4444;
            --bg-dark: #1a1a1a;
            --bg-card: #242424;
            --bg-phase: #2d2d2d;
            --text-primary: #e5e5e5;
            --text-secondary: #a3a3a3;
            --border-color: #404040;
            --accent: #71717a;
            --capec-color: #8b5cf6;
            --cwe-color: #f59e0b;
            --attack-color: #3b82f6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
            flex-wrap: wrap;
        }

        .header-title {
            font-size: 1rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-logo {
            display: inline;
            vertical-align: middle;
            width: 1.5rem;
            height: 1.5rem;
        }

        .header-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
        }

        .version-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 2px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            transition: all 0.15s;
        }

        .version-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .help-link {
            color: var(--text-secondary);
            text-decoration: none;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-phase);
            border-radius: 50%;
            font-weight: 600;
            transition: all 0.15s;
        }

        .help-link:hover {
            color: var(--text-primary);
            background: var(--accent);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 4px;
            background: var(--bg-phase);
            border-radius: 4px;
            padding: 2px;
        }

        .view-tab-group {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px;
            border-radius: 3px;
        }

        .view-tab-group.active {
            background: rgba(113, 113, 122, 0.25);
        }

        .view-btn {
            padding: 5px 12px;
            border: none;
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .view-btn.active {
            background: var(--accent);
            color: var(--text-primary);
        }

        .view-breadcrumb {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .breadcrumb-sep {
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .view-btn.view-btn-crumb {
            padding: 3px 8px;
            font-size: 0.7rem;
            border: 1px solid transparent;
        }

        .view-btn.view-btn-crumb.active {
            background: rgba(113, 113, 122, 0.35);
            color: var(--text-primary);
            border-color: var(--border-color);
        }

        /* Layer Toggles */
        .layer-toggles {
            display: flex;
            gap: 12px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .layer-toggle input {
            display: none;
        }

        .layer-toggle .checkbox {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .layer-toggle input:checked + .checkbox {
            background: var(--accent);
            border-color: var(--accent);
        }

        .layer-toggle input:checked + .checkbox::after {
            content: 'âœ“';
            font-size: 10px;
            color: white;
        }

        .layer-toggle.attack .checkbox { border-color: var(--attack-color); }
        .layer-toggle.attack input:checked + .checkbox { background: var(--attack-color); border-color: var(--attack-color); }
        .layer-toggle.capec .checkbox { border-color: var(--capec-color); }
        .layer-toggle.capec input:checked + .checkbox { background: var(--capec-color); border-color: var(--capec-color); }
        .layer-toggle.cwe .checkbox { border-color: var(--cwe-color); }
        .layer-toggle.cwe input:checked + .checkbox { background: var(--cwe-color); border-color: var(--cwe-color); }

        /* Buttons */
        .btn {
            padding: 5px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover { background: #3a3a3a; }
        .btn.active { background: var(--accent); border-color: var(--accent); }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Dropdown */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 100px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .dropdown.open .dropdown-content { display: block; }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 0.7rem;
            text-align: left;
            cursor: pointer;
            transition: background 0.15s;
        }

        .dropdown-item:hover { background: var(--bg-phase); }
        .dropdown-item.active { background: var(--bg-phase); color: var(--text-primary); }
        .dropdown-item:first-child { border-radius: 4px 4px 0 0; }
        .dropdown-item:last-child { border-radius: 0 0 4px 4px; }

        /* Main Layout */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .explorer-container {
            flex: 1;
            display: none;
            background: var(--bg-dark);
        }

        .explorer-frame {
            width: 100%;
            height: 100%;
            border: none;
        }

        .app.explorer-view .sidebar,
        .app.explorer-view .content {
            display: none;
        }

        .app.explorer-view .header-controls {
            display: none;
        }

        .app.explorer-view .explorer-container {
            display: block;
        }

        .app.sidebar-collapsed .sidebar {
            width: 44px;
        }

        .app.sidebar-collapsed .sidebar-tabs,
        .app.sidebar-collapsed .sidebar-content {
            display: none;
        }

        /* Sidebar */
        .sidebar {
            width: 340px;
            background: var(--bg-card);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.2s ease;
        }

        .sidebar-toggle {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sidebar-toggle:hover {
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .sidebar-toggle-icon {
            font-size: 0.7rem;
            transition: transform 0.2s;
            display: inline-block;
        }

        .sidebar-toggle-icon svg {
            width: 14px;
            height: 14px;
            display: block;
            fill: currentColor;
        }

        .app.sidebar-collapsed .sidebar-toggle-icon { transform: rotate(180deg); }

        .content-title-wrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-tab {
            flex: 1;
            padding: 10px 8px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
        }

        .sidebar-tab:hover { color: var(--text-primary); }
        .sidebar-tab.active { color: var(--text-primary); border-bottom-color: var(--accent); }
        .sidebar-tab.attack.active { border-bottom-color: var(--attack-color); }
        .sidebar-tab.capec.active { border-bottom-color: var(--capec-color); }
        .sidebar-tab.cwe.active { border-bottom-color: var(--cwe-color); }
        .sidebar-tab.custom.active { border-bottom-color: var(--custom-color); }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .tab-panel.active { display: flex; }

        /* Search & Filters */
        .search-bar {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .search-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .search-input:focus { outline: none; border-color: var(--accent); }

        .filter-row {
            display: flex;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 3px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .filter-btn.active { background: var(--accent); border-color: var(--accent); color: var(--text-primary); }

        /* Entity List */
        .entity-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .entity-item {
            display: flex;
            flex-direction: column;
            padding: 8px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .entity-item:hover { border-color: var(--accent); }
        .entity-item.selected { border-color: var(--accent); background: rgba(113, 113, 122, 0.2); }
        .entity-item.assigned { opacity: 0.5; border-style: dashed; }
        .entity-item.dragging { opacity: 0.4; transform: scale(0.95); }
        .entity-item[draggable="true"] { cursor: grab; }
        .entity-item[draggable="true"]:active { cursor: grabbing; }

        .entity-item.attack { border-left: 3px solid var(--attack-color); }
        .entity-item.capec { border-left: 3px solid var(--capec-color); }
        .entity-item.cwe { border-left: 3px solid var(--cwe-color); }

        .entity-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
        }

        .entity-id {
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .entity-item.attack .entity-id { color: var(--attack-color); }
        .entity-item.capec .entity-id { color: var(--capec-color); }
        .entity-item.cwe .entity-id { color: var(--cwe-color); }

        .entity-name {
            font-size: 0.75rem;
            color: var(--text-primary);
            margin-top: 2px;
        }

        .entity-meta {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .entity-badge {
            font-size: 0.6rem;
            padding: 1px 5px;
            border-radius: 2px;
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .entity-badge.severity-high { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .entity-badge.severity-medium { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .entity-badge.severity-low { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        .list-info {
            padding: 8px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        /* Import Section */
        .import-section {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .import-btns {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .import-btn {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--bg-phase);
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .import-btn:hover { border-color: var(--attack-color); color: var(--text-primary); }

        /* Main Content */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
        }

        .kill-chain-title-wrap {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: center;
        }

        .kill-chain-title {
            background: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            text-align: center;
            padding: 2px 8px;
            width: 100%;
            min-width: 0;
            max-width: 700px;
            outline: none;
            text-overflow: ellipsis;
        }

        .kill-chain-title::placeholder {
            color: var(--text-secondary);
            font-weight: 400;
            font-style: italic;
            opacity: 0.7;
        }

        .kill-chain-title:hover {
            border-color: var(--border-color);
        }

        .kill-chain-title:focus {
            border-color: var(--accent);
            background: var(--bg-card);
        }

        .app.compact-mode .kill-chain-title {
            font-size: 1rem;
            padding: 2px 8px;
            min-width: 0;
        }

        .view-controls {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        /* Kill Chain Description */
        .kc-desc-bar {
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
        }
        .kc-desc-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 16px;
            cursor: pointer;
            user-select: none;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-transform: uppercase;
            width: 100%;
            text-align: left;
        }
        .kc-desc-toggle:hover { color: var(--text-primary); }
        .kc-desc-toggle .kc-desc-chevron {
            display: inline-block;
            width: 10px;
            height: 10px;
            transition: transform 0.2s ease;
            transform: rotate(-90deg);
            flex-shrink: 0;
        }
        .kc-desc-bar.open .kc-desc-toggle .kc-desc-chevron {
            transform: rotate(0deg);
        }
        .kc-desc-chevron svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .kc-desc-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            opacity: 0.5;
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 500px;
        }
        .kc-desc-bar.open .kc-desc-hint {
            display: none;
        }
        .kc-desc-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0 16px;
        }
        .kc-desc-bar.open .kc-desc-body {
            max-height: 200px;
            padding: 0 16px 8px;
        }
        .kc-desc-textarea {
            width: 100%;
            min-height: 60px;
            max-height: 160px;
            resize: vertical;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.8rem;
            line-height: 1.5;
            padding: 6px 8px;
            outline: none;
        }
        .kc-desc-textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.5;
            font-style: italic;
        }
        .kc-desc-textarea:focus {
            border-color: var(--accent);
        }
        .kc-desc-counter {
            text-align: right;
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 16px;
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
            padding: 4px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .stat-value { font-size: 1rem; font-weight: bold; }
        .stat-label { font-size: 0.6rem; color: var(--text-secondary); text-transform: uppercase; }

        /* Kill Chain View */
        .kill-chain-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }

        .app.compact-mode .kill-chain-container {
            overflow: hidden;
        }

        .app.compact-mode.compact-scroll .kill-chain-container {
            overflow: auto;
        }

        .kill-chain-container.hidden { display: none; }

        .kill-chain {
            display: flex;
            gap: 8px;
            min-height: 100%;
        }

        .super-phase {
            flex: 1;
            min-width: 240px;
            display: flex;
            flex-direction: column;
        }

        .super-phase-header {
            text-align: center;
            padding: 8px;
            border-radius: 4px 4px 0 0;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-left: 3px solid;
        }

        .super-phase.in .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-in); }
        .super-phase.through .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-through); }
        .super-phase.out .super-phase-header { background: var(--bg-card); border-left-color: var(--phase-out); }

        .super-phase-content {
            background: var(--bg-card);
            border-radius: 0 0 4px 4px;
            padding: 6px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: 1px solid var(--border-color);
            border-top: none;
        }

        .phase {
            background: var(--bg-phase);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .phase.empty { opacity: 0.4; }
        .phase.hidden { display: none; }
        .phase.drop-target { border-color: var(--accent); background: rgba(113, 113, 122, 0.15); }
        .phase.minimized .phase-content { display: none; }

        .phase-header {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
        }

        .phase-header:hover { background: rgba(255, 255, 255, 0.03); }

        .phase-title {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .phase-header-actions {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .app.compact-mode .phase-header-actions {
            gap: 4px;
        }

        .phase-name { font-weight: 500; font-size: 1rem; }

        .phase-count {
            background: var(--border-color);
            padding: 1px 5px;
            border-radius: 8px;
            font-size: 0.65rem;
            font-weight: 600;
        }

        .phase-count.zero { background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); }

        .phase-toggle {
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 2px;
            cursor: pointer;
        }

        .phase-group-btn:hover { color: var(--text-primary); border-color: var(--accent); }

        .phase.minimized .phase-toggle { transform: rotate(-90deg); }

        .phase-content {
            padding: 4px 6px 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 300px;
            overflow-y: auto;
        }

        .app.compact-mode .phase-header {
            padding: 4px 6px;
        }

        .app.compact-mode .phase-content {
            padding: 2px 4px 4px;
            gap: 3px;
            max-height: none;
            overflow: visible;
        }

        .app.compact-mode .phase-name { font-size: 0.85rem; }
        .app.compact-mode .phase-count { font-size: 0.6rem; padding: 1px 4px; }

        .app.compact-mode .phase-group-btn {
            font-size: 0.6rem;
            padding: 1px 4px;
        }

        .app.compact-mode .phase-group {
            padding: 2px;
            gap: 3px;
        }

        .app.compact-mode .phase-group-header {
            padding: 2px 4px;
        }

        .app.compact-mode .phase-group-title { font-size: 0.8rem; }
        .app.compact-mode .phase-group-count { font-size: 0.6rem; }

        .app.compact-mode .group-actions {
            opacity: 0;
            pointer-events: none;
        }

        .app.compact-mode .phase-group:hover .group-actions {
            opacity: 1;
            pointer-events: auto;
        }

        .phase-group {
            border: 1px dashed rgba(113, 113, 122, 0.35);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(17, 24, 39, 0.25);
        }

        .phase-group.collapsed .phase-group-content { display: none; }

        .phase-group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 4px;
            background: rgba(15, 23, 42, 0.4);
            cursor: pointer;
        }

        .phase-group-title { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); }
        .phase-group-count { font-size: 0.65rem; color: var(--text-secondary); }
        .phase-group-toggle {
            display: inline-block;
            font-size: 0.65rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .phase-group.collapsed .phase-group-toggle { transform: rotate(-90deg); }

        .group-header-actions {
            margin-left: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .group-actions {
            display: inline-flex;
            gap: 4px;
        }

        .group-action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: rgba(17, 24, 39, 0.2);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .group-action-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .group-action-btn:hover { border-color: var(--accent); color: var(--text-primary); }
        .group-action-btn.delete:hover { border-color: #f87171; color: #f87171; }

        .phase-group-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .app.compact-mode .phase-group-content {
            gap: 2px;
        }

        /* Technique Tag */
        .technique-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .technique-tag:hover { border-color: var(--attack-color); background: rgba(59, 130, 246, 0.25); }

        .technique-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .app.compact-mode .technique-tag .tag-header-row,
        .app.compact-mode .capec-tag .tag-header-row,
        .app.compact-mode .cwe-tag .tag-header-row,
        .app.compact-mode .custom-tag .tag-header-row {
            gap: 4px;
        }

        .technique-tag .id {
            font-family: monospace;
            font-weight: 600;
            color: #fff;
            background: rgba(59, 130, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .app.compact-mode .technique-tag .id,
        .app.compact-mode .capec-tag .id,
        .app.compact-mode .cwe-tag .id,
        .app.compact-mode .custom-tag .id {
            font-size: 0.7rem;
            padding: 1px 3px;
        }

        .technique-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .technique-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .technique-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .technique-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .technique-tag:hover .remove { opacity: 1; }

        /* CWE Tag */
        .cwe-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .cwe-tag:hover { border-color: var(--cwe-color); background: rgba(245, 158, 11, 0.2); }

        .cwe-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .cwe-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(245, 158, 11, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .cwe-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .cwe-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .cwe-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .cwe-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .cwe-tag:hover .remove { opacity: 1; }

        /* CAPEC Tag */
        .capec-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .capec-tag:hover { border-color: var(--capec-color); background: rgba(139, 92, 246, 0.2); }

        .capec-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .domain-badge {
            font-size: 0.55rem;
            padding: 1px 4px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            background: var(--bg-phase);
            letter-spacing: 0.3px;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .capec-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(139, 92, 246, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .capec-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .capec-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .capec-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            /* width: 18px;
            height: 18px; */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .capec-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .remove svg {
            fill: #ff6565f7;
        }

        .capec-tag:hover .remove { opacity: 1; }

        /* Custom/STIX Tag */
        .custom-tag {
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 4px 6px;
            background: rgba(20, 184, 166, 0.1);
            border: 1px solid rgba(20, 184, 166, 0.25);
            border-radius: 3px;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .custom-tag:hover { border-color: var(--custom-color); background: rgba(20, 184, 166, 0.2); }

        .custom-tag .tag-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            min-width: 0;
        }

        .custom-tag .id {
            font-family: monospace;
            color: #fff;
            font-weight: 600;
            background: rgba(20, 184, 166, 0.5);
            padding: 1px 4px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .custom-tag .id:hover {
            background: rgba(0, 0, 0, 0.32);
        }

        .custom-tag .name {
            color: var(--text-primary);
            max-width: 260px;
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .custom-tag .remove {
            color: #ef4444;
            font-weight: bold;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.15s;
            cursor: pointer;
        }

        .custom-tag .remove:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .custom-tag:hover .remove { opacity: 1; }

        .stix-type-badge {
            font-size: 0.55rem;
            padding: 1px 4px;
            border-radius: 999px;
            border: 1px solid rgba(20, 184, 166, 0.4);
            color: var(--custom-color);
            background: rgba(20, 184, 166, 0.1);
            letter-spacing: 0.3px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        /* Create Custom Item Modal */
        .create-custom-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .create-custom-modal.visible { display: flex; }
        .create-custom-form {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            width: min(480px, 90vw);
            max-height: 80vh;
            overflow-y: auto;
        }
        .create-custom-form h3 {
            margin: 0 0 16px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        .create-custom-form label {
            display: block;
            margin-bottom: 4px;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        .create-custom-form select,
        .create-custom-form input,
        .create-custom-form textarea {
            width: 100%;
            padding: 6px 8px;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        .create-custom-form textarea {
            resize: vertical;
            min-height: 60px;
        }
        .create-custom-form .form-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 8px;
        }
        .create-custom-form .form-actions button {
            padding: 6px 16px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .create-custom-form .form-actions .btn-create {
            background: var(--custom-color);
            color: #fff;
            border-color: var(--custom-color);
        }
        .create-custom-form .form-actions .btn-cancel {
            background: var(--bg-phase);
            color: var(--text-primary);
        }
        #custom-typename-group { display: none; }

        /* Edit STIX Item Modal */
        .edit-stix-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .edit-stix-modal.visible { display: flex; }
        .edit-stix-form {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: min(600px, 92vw);
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }
        .edit-stix-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .edit-stix-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1rem;
        }
        .edit-stix-header .stix-type-badge {
            background: var(--custom-color);
            color: #fff;
            padding: 2px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 10px;
        }
        .edit-stix-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0 4px;
            line-height: 1;
        }
        .edit-stix-close:hover { color: var(--text-primary); }
        .edit-stix-body {
            overflow-y: auto;
            padding: 16px 20px;
            flex: 1;
        }
        .edit-stix-body .stix-field-group {
            margin-bottom: 14px;
        }
        .edit-stix-body .stix-field-group label {
            display: block;
            margin-bottom: 3px;
            color: var(--text-secondary);
            font-size: 0.78rem;
        }
        .edit-stix-body .stix-field-group label .field-required {
            color: #ef4444;
            margin-left: 2px;
        }
        .edit-stix-body .stix-field-group input,
        .edit-stix-body .stix-field-group select,
        .edit-stix-body .stix-field-group textarea {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        .edit-stix-body .stix-field-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        .edit-stix-body .stix-field-group .field-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        .edit-stix-body .stix-field-group input:read-only {
            opacity: 0.6;
            cursor: default;
        }
        .edit-stix-section-title {
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 18px 0 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border-color);
        }
        .edit-stix-section-title:first-child { margin-top: 0; }
        .edit-stix-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            padding: 12px 20px;
            border-top: 1px solid var(--border-color);
        }
        .edit-stix-footer button {
            padding: 6px 18px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .edit-stix-footer .btn-stix-save {
            background: var(--custom-color);
            color: #fff;
            border-color: var(--custom-color);
        }
        .edit-stix-footer .btn-stix-cancel {
            background: var(--bg-phase);
            color: var(--text-primary);
        }
        #edit-stix-error {
            color: #ef4444;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        /* Custom item sidebar entry */
        .entity-item.custom {
            border-left-color: var(--custom-color);
        }
        .entity-item.custom .entity-id {
            color: var(--custom-color);
        }
        .entity-badge.stix-badge {
            background: rgba(20, 184, 166, 0.15);
            color: var(--custom-color);
            border: 1px solid rgba(20, 184, 166, 0.3);
        }

        /* Filter dropdown for custom tab */
        .filter-select {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-phase);
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
            max-width: 140px;
        }

        .technique-tag .name,
        .capec-tag .name,
        .cwe-tag .name,
        .custom-tag .name {
            flex: 1;
            min-width: 0;
            font-size: 0.8rem;
        }

        .tag-actions {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .app.compact-mode .tag-actions {
            opacity: 0;
            pointer-events: none;
        }

        .app.compact-mode .technique-tag:hover .tag-actions,
        .app.compact-mode .capec-tag:hover .tag-actions,
        .app.compact-mode .cwe-tag:hover .tag-actions,
        .app.compact-mode .custom-tag:hover .tag-actions {
            opacity: 1;
            pointer-events: auto;
        }

        .tag-body {
            margin-top: 4px;
        }

        .tag-footer {
            margin-top: 4px;
        }

        .app.compact-mode .technique-tag,
        .app.compact-mode .capec-tag,
        .app.compact-mode .cwe-tag,
        .app.compact-mode .custom-tag {
            padding: 3px 5px;
        }

        .app.compact-mode .tag-body {
            display: none;
        }

        .app.compact-mode .tag-footer {
            margin-top: 2px;
        }

        .tag-action-btn {
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text-secondary);
            font-size: 0.7rem;
            padding: 3px 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            line-height: 1.1;
        }

        .app.compact-mode .tag-action-btn {
            padding: 1px 3px;
        }

        .tag-action-btn:hover {
            color: var(--text-primary);
            border-color: var(--accent);
            background: rgba(113, 113, 122, 0.25);
        }

        .tag-action-btn.explore { color: #93c5fd; }
        .tag-action-btn.edit { color: #fcd34d; }

        /* ============================================================
           SCORE RIBBONS & METADATA INDICATORS
           ============================================================ */
        
        /* Score ribbon (left border only - preserves framework background colors) */
        .technique-tag[data-score="low"],
        .capec-tag[data-score="low"],
        .cwe-tag[data-score="low"] {
            border-left: 3px solid #22c55e;
        }
        
        .technique-tag[data-score="medium"],
        .capec-tag[data-score="medium"],
        .cwe-tag[data-score="medium"] {
            border-left: 3px solid #eab308;
        }
        
        .technique-tag[data-score="high"],
        .capec-tag[data-score="high"],
        .cwe-tag[data-score="high"] {
            border-left: 3px solid #f97316;
        }
        
        .technique-tag[data-score="critical"],
        .capec-tag[data-score="critical"],
        .cwe-tag[data-score="critical"] {
            border-left: 3px solid #ef4444;
        }

        /* Metadata indicators - displayed below title */
        .metadata-icons {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .app.compact-mode .metadata-icons {
            gap: 3px;
            margin-top: 2px;
        }

        .app.compact-mode .tag-header-row .metadata-icons {
            margin-top: 0;
        }
        
        .metadata-icons .meta-icon {
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--meta-default-bg);
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
            color: var(--meta-default-fg);
            white-space: nowrap;
            gap: 4px;
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .app.compact-mode .metadata-icons .meta-icon {
            min-width: 14px;
            height: 14px;
            padding: 0 3px;
            font-size: 10px;
        }

        .meta-icon svg,
        .tag-action-btn svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            stroke: currentColor;
            flex: 0 0 auto;
        }

        .tag-action-btn:hover svg {
            fill: currentColor;
            stroke: currentColor;
        }
        
        .metadata-icons .meta-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .metadata-icons .meta-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .metadata-icons .meta-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .metadata-icons .meta-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .metadata-icons .meta-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }

        /* Score Legend */
        .score-legend {
            display: flex;
            gap: 12px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .metadata-legend {
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.7rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .metadata-legend .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .legend-icon {
            width: 14px;
            height: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            background: var(--meta-default-bg);
            color: var(--meta-default-fg);
            filter: brightness(var(--meta-icon-brightness, 1));
        }

        .legend-icon svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .legend-icon.has-cve { background: var(--meta-cve-bg); color: var(--meta-cve-fg); }
        .legend-icon.has-observable { background: var(--meta-observable-bg); color: var(--meta-observable-fg); }
        .legend-icon.has-link { background: var(--meta-link-bg); color: var(--meta-link-fg); }
        .legend-icon.has-comment { background: var(--meta-comment-bg); color: var(--meta-comment-fg); }
        .legend-icon.has-confidence { background: var(--meta-confidence-bg); color: var(--meta-confidence-fg); }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            text-decoration: none;
            cursor: pointer;
            margin-left: auto;
        }

        .github-link a {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: inherit;
            text-decoration: none;
        }

        .github-link svg {
            fill: gray;
            height: 1.1rem;
            width: 1.1rem;
            flex-shrink: 0;
        }

        .github-link:hover { color: var(--text-primary); }
        
        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* ============================================================
           METADATA EDITOR MODAL
           ============================================================ */
        .metadata-editor-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }
        
        .metadata-editor-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .metadata-editor {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        
        .metadata-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .metadata-editor-title {
            font-size: 1rem;
            font-weight: 600;
        }
        
        .metadata-editor-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 4px;
        }
        
        .metadata-editor-close:hover { color: var(--text-primary); }
        
        .metadata-editor-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        
        .metadata-section {
            margin-bottom: 16px;
        }
        
        .metadata-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .metadata-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
        }
        
        .metadata-input:focus {
            outline: none;
            border-color: var(--attack-color);
        }
        
        .metadata-input.invalid {
            border-color: #ef4444;
        }
        
        .metadata-input-error {
            font-size: 0.7rem;
            color: #ef4444;
            margin-top: 4px;
        }
        
        .metadata-textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        .metadata-select {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        /* Score selector */
        .score-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .score-option {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }
        
        .score-option:hover {
            border-color: var(--text-secondary);
        }
        
        .score-option.selected {
            border-color: var(--attack-color);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .score-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        /* Confidence slider */
        .confidence-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .confidence-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            outline: none;
        }
        
        .confidence-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .confidence-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--attack-color);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .confidence-value {
            min-width: 80px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-primary);
        }
        
        .confidence-label {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .confidence-label.unknown { background: rgba(107, 114, 128, 0.3); color: #9ca3af; }
        .confidence-label.low { background: rgba(239, 68, 68, 0.3); color: #fca5a5; }
        .confidence-label.medium { background: rgba(251, 191, 36, 0.3); color: #fcd34d; }
        .confidence-label.high { background: rgba(34, 197, 94, 0.3); color: #86efac; }
        
        /* Observable list */
        .observable-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .observable-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .observable-item select {
            width: 140px;
            flex-shrink: 0;
        }
        
        .observable-item input {
            flex: 1;
        }
        
        .observable-remove {
            background: none;
            border: none;
            color: #ef4444;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
        }
        
        .add-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: var(--bg-phase);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .add-btn:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }
        
        /* Hyperlink list */
        .hyperlink-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .hyperlink-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        
        .hyperlink-item input:first-child {
            width: 120px;
            flex-shrink: 0;
        }
        
        .hyperlink-item input:nth-child(2) {
            flex: 1;
        }

        /* CVE list */
        .cve-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cve-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .cve-item input.cve-id-input {
            width: 180px;
            flex-shrink: 0;
        }

        .cve-item input.cve-score-input {
            width: 110px;
            flex-shrink: 0;
        }

        .cve-item input.cve-vector-input {
            flex: 1;
            min-width: 220px;
        }
        
        .metadata-editor-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
        }
        
        .metadata-btn {
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .metadata-btn-cancel {
            background: var(--bg-phase);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .metadata-btn-cancel:hover {
            background: var(--bg-dark);
        }
        
        .metadata-btn-save {
            background: var(--attack-color);
            border: 1px solid var(--attack-color);
            color: white;
        }
        
        .metadata-btn-save:hover {
            background: #2563eb;
        }

        /* Relationship View */
        .relationship-container {
            flex: 1;
            overflow: auto;
            padding: 16px;
            display: none;
        }

        .relationship-container.visible { display: block; }

        .relationship-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px;
            background: var(--bg-card);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .relationship-header-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .relationship-header-item .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .relationship-header-item .dot.capec { background: var(--capec-color); }
        .relationship-header-item .dot.cwe { background: var(--cwe-color); }
        .relationship-header-item .dot.attack { background: var(--attack-color); }
        .relationship-header-item .dot.phase { background: var(--accent); }

        .relationship-arrow {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .relationship-chain {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
        }

        .relationship-wrapper {
            display: flex;
            gap: 12px;
        }

        .flow-arrow {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 16px 8px;
            min-height: 100px;
        }

        .flow-arrow-line {
            width: 2px;
            flex: 1;
            background: linear-gradient(to bottom, var(--phase-in), var(--phase-through), var(--phase-out));
            border-radius: 1px;
            position: relative;
        }

        .flow-arrow-head {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 12px solid var(--phase-out);
            margin-top: -1px;
        }

        .flow-arrow-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin-bottom: 8px;
        }

        .relationship-row {
            display: flex;
            align-items: stretch;
            gap: 4px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .relationship-cell {
            flex: 1;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border-right: 1px solid var(--border-color);
            min-width: 0;
        }

        .relationship-cell:last-child { border-right: none; }

        .relationship-cell-header {
            font-size: 0.6rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .relationship-cell.capec { background: rgba(139, 92, 246, 0.05); }
        .relationship-cell.cwe { background: rgba(245, 158, 11, 0.05); }
        .relationship-cell.attack { background: rgba(59, 130, 246, 0.05); }
        .relationship-cell.phase { background: rgba(113, 113, 122, 0.05); }

        .relationship-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .relationship-item:hover { background: var(--bg-dark); }

        .relationship-item .id {
            font-family: monospace;
            font-weight: 600;
        }

        .relationship-item .id.capec { color: var(--capec-color); }
        .relationship-item .id.cwe { color: var(--cwe-color); }
        .relationship-item .id.attack { color: var(--attack-color); }
        .relationship-item .id.phase { color: var(--accent); }

        .relationship-item .name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .relationship-empty {
            padding: 30px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Detail Panel */
        .detail-panel {
            width: 320px;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .detail-panel.visible { display: flex; }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            gap: 8px;
        }

        .detail-header-content {
            flex: 1;
            min-width: 0;
        }

        .detail-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .detail-close:hover { color: var(--text-primary); }

        .detail-id {
            font-family: monospace;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .detail-id.attack { color: var(--attack-color); }
        .detail-id.capec { color: var(--capec-color); }
        .detail-id.cwe { color: var(--cwe-color); }

        .detail-name {
            font-size: 0.95rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .detail-section {
            margin-bottom: 16px;
        }

        .detail-section h4 {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .detail-section p {
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .detail-section details {
            margin-top: 4px;
        }
        .detail-section details summary {
            cursor: pointer;
            font-size: 0.75rem;
            color: var(--text-secondary);
            user-select: none;
            padding: 2px 0;
        }
        .detail-section details summary:hover {
            color: var(--text-primary);
        }
        .detail-section details[open] summary {
            margin-bottom: 6px;
        }
        .detail-section details p {
            margin: 0;
        }

        .detail-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .detail-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 8px;
            background: var(--bg-phase);
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .detail-list-item:hover { background: var(--bg-dark); }

        .detail-list-item .id { font-family: monospace; font-weight: 600; }
        .detail-list-item .id.attack { color: var(--attack-color); }
        .detail-list-item .id.capec { color: var(--capec-color); }
        .detail-list-item .id.cwe { color: var(--cwe-color); }

        /* Technique cross-reference badges (KCE-SEC-010 compliant) */
        .technique-xref-badge {
            display: inline;
            font-family: var(--mono, monospace);
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--attack-color);
            background: color-mix(in srgb, var(--attack-color) 12%, transparent);
            border: 1px solid color-mix(in srgb, var(--attack-color) 30%, transparent);
            border-radius: 3px;
            padding: 1px 5px;
            cursor: pointer;
            white-space: nowrap;
        }
        .technique-xref-badge:hover {
            background: color-mix(in srgb, var(--attack-color) 25%, transparent);
        }

        /* Legend */
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 8px 16px;
            border-top: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-color.attack { background: var(--attack-color); }
        .legend-color.capec { background: var(--capec-color); }
        .legend-color.cwe { background: var(--cwe-color); }
        .legend-color.custom { background: var(--custom-color); }
        .legend-color.in { background: var(--phase-in); }
        .legend-color.through { background: var(--phase-through); }
        .legend-color.out { background: var(--phase-out); }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 18px;
            background: var(--bg-card);
            border: 1px solid var(--accent);
            border-radius: 4px;
            font-size: 0.8rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            z-index: 1000;
            display:none;
        }

        .toast.show { opacity: 1; transform: translateY(0); display: block; }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text-primary); }

        .modal-body {
            padding: 16px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .modal-wide {
            max-width: 700px;
            max-height: 80vh;
        }

        .changelog-body {
            white-space: pre-wrap;
            font-family: var(--font-mono, 'SF Mono', Consolas, monospace);
            font-size: 0.8rem;
            background: var(--bg-dark);
            border-radius: 4px;
            padding: 16px;
            max-height: 60vh;
        }

        .guide-section {
            margin-bottom: 16px;
        }

        .guide-section h4 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .guide-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .guide-section li {
            margin-bottom: 4px;
        }

        .guide-key {
            display: inline-block;
            background: var(--bg-phase);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            margin: 0 2px;
        }

        .guide-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
            gap: 16px;
        }

        .loading.hidden { display: none; }

        .loading-text {
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
            max-width: 500px;
            line-height: 1.5;
        }

        .loading-dismiss {
            display: none;
            padding: 8px 24px;
            background: var(--accent, #3b82f6);
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .loading-dismiss:hover {
            background: #2563eb;
        }

        .loading-hint {
            display: none;
            color: var(--text-secondary, #a1a1aa);
            font-size: 0.75rem;
            text-align: center;
            max-width: 440px;
            line-height: 1.4;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">Loading data...</div>
        <button class="loading-dismiss" id="loading-dismiss" onclick="document.getElementById('loading').classList.add('hidden'); renderAll();">Continue Without Data</button>
        <div class="loading-hint" id="loading-hint">You can still import ATT&CK Navigator layers, create STIX objects, and import saved kill chains.</div>
    </div>

    <div class="app">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <div class="header-brand">
                    <img src="favicon.ico" alt="Logo" class="header-logo">
                    <div class="header-title">AttackFlow</div><br>
                    <div class="header-meta">
                        <a href="#" class="version-link" id="app-version" title="View changelog" onclick="showChangelog(); return false;">v2.4.2</a>
                        <a href="#" class="help-link" onclick="showUsageGuide(); return false;" title="Usage guide">?</a>
                    </div>
                </div>
                <div class="header-nav">
                    <div class="view-toggle">
                        <div class="view-tab-group active" id="view-editor-group">
                            <button class="view-btn active" id="view-killchain" onclick="setView('killchain')">Kill Chain Editor</button>
                            <span class="view-breadcrumb">
                                <span class="breadcrumb-sep">â€º</span>
                                <button class="view-btn view-btn-crumb" id="view-relationship" onclick="setView('relationship')">Relationships</button>
                            </span>
                        </div>
                        <div class="view-tab-group" id="view-explorer-group">
                            <button class="view-btn" id="view-explorer" onclick="setView('explorer')">Relationship Explorer</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="header-controls">
                <div class="control-group">
                    <span class="control-label">Theme</span>
                    <button class="btn" id="theme-mode-toggle" onclick="toggleThemeMode()">Dark</button>
                </div>
                <div class="control-group">
                    <span class="control-label">Layers</span>
                    <div class="layer-toggles">
                        <label class="layer-toggle attack">
                            <input type="checkbox" id="layer-attack" checked onchange="toggleLayer('attack')">
                            <span class="checkbox"></span>
                            <span>ATT&CK</span>
                        </label>
                        <label class="layer-toggle capec">
                            <input type="checkbox" id="layer-capec" checked onchange="toggleLayer('capec')">
                            <span class="checkbox"></span>
                            <span>CAPEC</span>
                        </label>
                        <label class="layer-toggle cwe">
                            <input type="checkbox" id="layer-cwe" checked onchange="toggleLayer('cwe')">
                            <span class="checkbox"></span>
                            <span>CWE</span>
                        </label>
                        <label class="layer-toggle custom">
                            <input type="checkbox" id="layer-custom" checked onchange="toggleLayer('custom')">
                            <span class="checkbox"></span>
                            <span>STIX</span>
                        </label>
                    </div>
                </div>

                <div class="control-group">
                    <button class="btn" onclick="expandAll()">Expand</button>
                    <button class="btn" onclick="collapseAll()">Collapse</button>
                    <button class="btn" onclick="clearAssignments()">Clear</button>
                    <div class="dropdown" id="export-dropdown">
                        <button class="btn" onclick="toggleDropdown('export-dropdown')">Export â–¼</button>
                        <div class="dropdown-content">
                            <button class="dropdown-item" onclick="exportJSON(); closeDropdowns()">JSON</button>
                            <button class="dropdown-item" onclick="exportCSV(); closeDropdowns()">CSV</button>
                            <button class="dropdown-item" onclick="exportSTIXBundle(); closeDropdowns()">STIX Bundle</button>
                        </div>
                    </div>
                    <button class="btn" onclick="triggerImportKillChain()">Import</button>
                    <input id="import-killchain-input" type="file" accept=".json" onchange="importKillChain(event)" style="display: none;" />
                </div>
            </div>
        </div>

        <!-- Main -->
        <div class="main">
            <!-- Sidebar -->
            <div class="sidebar">
                <div class="sidebar-tabs">
                    <button class="sidebar-tab attack active" onclick="switchTab('attack')">ATT&CK</button>
                    <button class="sidebar-tab capec" onclick="switchTab('capec')">CAPEC</button>
                    <button class="sidebar-tab cwe" onclick="switchTab('cwe')">CWE</button>
                    <button class="sidebar-tab custom" onclick="switchTab('custom')">STIX</button>
                </div>

                <div class="sidebar-content">
                    <!-- ATT&CK Tab -->
                    <div class="tab-panel active" id="tab-attack">
                        <div class="import-section">
                            <div class="import-btns">
                                <label class="import-btn" style="cursor: pointer;">
                                    Import ATT&CK Navigator Layer
                                    <input type="file" accept=".json" onchange="importNavigator(event)" style="display: none;">
                                </label>
                            </div>
                        </div>
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-attack" placeholder="Search techniques..." oninput="filterEntities('attack')">
                        </div>
                        <div class="filter-row" id="filter-attack">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('attack', 'all')">All</button>
                            <button class="filter-btn" data-filter="enterprise" onclick="setFilter('attack', 'enterprise')">Enterprise</button>
                            <button class="filter-btn" data-filter="mobile" onclick="setFilter('attack', 'mobile')">Mobile</button>
                            <button class="filter-btn" data-filter="ics" onclick="setFilter('attack', 'ics')">ICS</button>
                        </div>
                        <div class="entity-list" id="list-attack"></div>
                    </div>

                    <!-- CAPEC Tab -->
                    <div class="tab-panel" id="tab-capec">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-capec" placeholder="Search patterns..." oninput="filterEntities('capec')">
                        </div>
                        <div class="filter-row" id="filter-capec">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('capec', 'all')">All</button>
                            <button class="filter-btn" data-filter="meta" onclick="setFilter('capec', 'meta')">Meta</button>
                            <button class="filter-btn" data-filter="standard" onclick="setFilter('capec', 'standard')">Standard</button>
                            <button class="filter-btn" data-filter="detailed" onclick="setFilter('capec', 'detailed')">Detailed</button>
                        </div>
                        <div class="entity-list" id="list-capec"></div>
                    </div>

                    <!-- CWE Tab -->
                    <div class="tab-panel" id="tab-cwe">
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-cwe" placeholder="Search weaknesses..." oninput="filterEntities('cwe')">
                        </div>
                        <div class="filter-row" id="filter-cwe">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('cwe', 'all')">All</button>
                            <button class="filter-btn" data-filter="pillar" onclick="setFilter('cwe', 'pillar')">Pillar</button>
                            <button class="filter-btn" data-filter="class" onclick="setFilter('cwe', 'class')">Class</button>
                            <button class="filter-btn" data-filter="base" onclick="setFilter('cwe', 'base')">Base</button>
                        </div>
                        <div class="entity-list" id="list-cwe"></div>
                    </div>

                    <!-- STIX Tab -->
                    <div class="tab-panel" id="tab-custom">
                        <div class="import-section">
                            <div class="import-btns">
                                <button class="import-btn" onclick="openCreateCustomModal()">+ Create STIX Item</button>
                                <label class="import-btn" style="cursor: pointer;">
                                    Import STIX Bundle
                                    <input type="file" accept=".json" onchange="importStixBundle(event)" style="display: none;">
                                </label>
                                <button class="import-btn" onclick="clearStixLibrary()">Clear All Items</button>
                            </div>
                        </div>
                        <div class="search-bar">
                            <input type="text" class="search-input" id="search-custom" placeholder="Search STIX items..." oninput="filterEntities('custom')">
                        </div>
                        <div class="filter-row" id="filter-custom">
                            <button class="filter-btn active" data-filter="all" onclick="setFilter('custom', 'all')">All</button>
                            <select class="filter-select" id="filter-custom-type" onchange="setFilter('custom', this.value)">
                                <option value="all">All Types</option>
                            </select>
                        </div>
                        <div class="entity-list" id="list-custom"></div>
                    </div>
                </div>
            </div>

            <div class="explorer-container" id="explorer-container">
                <iframe class="explorer-frame" src="explorer.html" title="Relationship Explorer"></iframe>
            </div>

            <!-- Content -->
            <div class="content" id="content">
                <div class="content-header">
                    <div class="content-title-wrap">
                        <button class="sidebar-toggle" onclick="toggleSidebar()" aria-label="Toggle sidebar" title="Toggle sidebar">
                            <span class="sidebar-toggle-icon">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M169.4 297.4C156.9 309.9 156.9 330.2 169.4 342.7L361.4 534.7C373.9 547.2 394.2 547.2 406.7 534.7C419.2 522.2 419.2 501.9 406.7 489.4L237.3 320L406.6 150.6C419.1 138.1 419.1 117.8 406.6 105.3C394.1 92.8 373.8 92.8 361.3 105.3L169.3 297.3z"/></svg>                            </span>
                        </button>
                        <span style="font-size: 0.9rem; font-weight: 500;" id="content-title">Unified Kill Chain</span>
                    </div>
                    <div class="kill-chain-title-wrap">
                        <input type="text" class="kill-chain-title" id="kill-chain-title"
                               placeholder="Untitled Kill Chain"
                               maxlength="200"
                               spellcheck="false"
                               onblur="commitKillChainTitle(this)"
                               onkeydown="if(event.key==='Enter'){this.blur();}">
                    </div>
                    <div class="view-controls">
                        <button class="btn" id="btn-hide-empty" onclick="toggleHideEmpty()">Hide Empty</button>
                        <button class="btn" id="btn-compact" onclick="toggleCompactMode()">Compact</button>
                    </div>
                </div>

                <div class="kc-desc-bar" id="kc-desc-bar">
                    <button class="kc-desc-toggle" onclick="toggleDescriptionPanel()" aria-label="Toggle description">
                        <span class="kc-desc-chevron"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M310 233L118 41c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L226.7 240 72.7 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3z"/></svg></span>
                        <span>Description</span>
                        <span class="kc-desc-hint" id="kc-desc-hint"></span>
                    </button>
                    <div class="kc-desc-body">
                        <textarea class="kc-desc-textarea" id="kc-desc-textarea"
                                  placeholder="Describe this kill chain analysis..."
                                  maxlength="2000"
                                  spellcheck="true"
                                  oninput="updateDescriptionCounter()"
                                  onblur="commitKillChainDescription(this)"></textarea>
                        <div class="kc-desc-counter" id="kc-desc-counter"></div>
                    </div>
                </div>

                <div class="stats-bar" id="stats-bar"></div>
                
                <!-- Score Legend -->
                <div class="legend-row" id="legend-row">
                    <div class="score-legend" id="score-legend">
                        <span style="color: var(--text-secondary); margin-right: 8px;">Score:</span>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #6b7280;"></div>
                            <span>Unclassified</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #22c55e;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #eab308;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #f97316;"></div>
                            <span>High</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-swatch" style="background: #ef4444;"></div>
                            <span>Critical</span>
                        </div>
                    </div>
                    <div class="metadata-legend" id="metadata-legend">
                        <span style="color: var(--text-secondary); margin-right: 6px;">Metadata:</span>
                        <div class="legend-item">
                            <span class="legend-icon has-cve">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                            </span>
                            <span>CVE</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-observable">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg>
                            </span>
                            <span>Observable</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-link">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg>
                            </span>
                            <span>Link</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-comment">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg>
                            </span>
                            <span>Comment</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-icon has-confidence">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg>
                            </span>
                            <span>Confidence</span>
                        </div>
                    </div>
                </div>

                <div class="kill-chain-container" id="kill-chain-container">
                    <div class="kill-chain" id="kill-chain"></div>
                </div>

                <div class="relationship-container" id="relationship-container">
                    <div class="relationship-header">
                        <div class="relationship-header-item"><div class="dot capec"></div>CAPEC</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot cwe"></div>CWE</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot attack"></div>ATT&CK</div>
                        <span class="relationship-arrow">â†’</span>
                        <div class="relationship-header-item"><div class="dot phase"></div>Phase</div>
                    </div>
                    <div class="relationship-wrapper">
                        <div class="relationship-chain" id="relationship-chain"></div>
                        <div class="flow-arrow">
                            <div class="flow-arrow-label">Attack Flow</div>
                            <div class="flow-arrow-line"></div>
                            <div class="flow-arrow-head"></div>
                        </div>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color attack"></div><span>ATT&CK Technique</span></div>
                    <div class="legend-item"><div class="legend-color capec"></div><span>CAPEC Pattern</span></div>
                    <div class="legend-item"><div class="legend-color cwe"></div><span>CWE Weakness</span></div>
                    <div class="legend-item"><div class="legend-color custom"></div><span>STIX Object</span></div>
                    <div class="legend-item" style="margin-left: 16px; padding-left: 16px; border-left: 1px solid var(--border-color);">
                        <div class="legend-color in"></div><span>IN</span>
                    </div>
                    <div class="legend-item"><div class="legend-color through"></div><span>THROUGH</span></div>
                    <div class="legend-item"><div class="legend-color out"></div><span>OUT</span></div>
                    <div class="github-link">
                        <a title="Show on GitHub" onclick="return(confirm('Open GitHub repository in new tab?'))" href="https://github.com/pr0cella/AttackFlow" target="_blank" rel="noopener noreferrer" >
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M544 160C544 124.7 515.3 96 480 96L160 96C124.7 96 96 124.7 96 160L96 480C96 515.3 124.7 544 160 544L480 544C515.3 544 544 515.3 544 480L544 160zM361.8 471.7C361.8 469.9 361.8 465.7 361.9 460.1C362 448.7 362 431.3 362 416.4C362 400.8 356.8 390.9 350.7 385.7C387.7 381.6 426.7 376.5 426.7 312.6C426.7 294.4 420.2 285.3 409.6 273.6C411.3 269.3 417 251.6 407.9 228.6C394 224.3 362.2 246.5 362.2 246.5C335.6 239 305.6 239 279 246.5C279 246.5 247.2 224.3 233.3 228.6C224.2 251.5 229.8 269.2 231.6 273.6C221 285.3 216 294.4 216 312.6C216 376.2 253.3 381.6 290.3 385.7C285.5 390 281.2 397.4 279.7 408C270.2 412.3 245.9 419.7 231.4 394.1C222.3 378.3 205.9 377 205.9 377C189.7 376.8 204.8 387.2 204.8 387.2C215.6 392.2 223.2 411.4 223.2 411.4C232.9 441.1 279.3 431.1 279.3 431.1C279.3 440.1 279.4 452.8 279.4 461.7C279.4 466.5 279.5 470.3 279.5 471.7C279.5 476 276.5 481.2 268 479.7C202 457.6 155.8 394.8 155.8 321.4C155.8 229.6 226 159.9 317.8 159.9C409.6 159.9 484 229.6 484 321.4C484.1 394.8 439.3 457.7 373.3 479.7C364.9 481.2 361.8 476 361.8 471.7zM271.3 416.9C271.1 415.4 272.4 414.1 274.3 413.7C276.2 413.5 278 414.3 278.2 415.6C278.5 416.9 277.2 418.2 275.2 418.6C273.3 419 271.5 418.2 271.3 416.9zM262.2 420.1C260 420.3 258.5 419.2 258.5 417.7C258.5 416.4 260 415.3 262 415.3C263.9 415.1 265.7 416.2 265.7 417.7C265.7 419 264.2 420.1 262.2 420.1zM247.9 417.9C246 417.5 244.7 416 245.1 414.7C245.5 413.4 247.5 412.8 249.2 413.2C251.2 413.8 252.5 415.3 252 416.6C251.6 417.9 249.6 418.5 247.9 417.9zM235.4 410.6C233.9 409.3 233.5 407.4 234.5 406.5C235.4 405.4 237.3 405.6 238.8 407.1C240.1 408.4 240.6 410.4 239.7 411.2C238.8 412.3 236.9 412.1 235.4 410.6zM226.9 400.6C225.8 399.1 225.8 397.4 226.9 396.7C228 395.8 229.7 396.5 230.6 398C231.7 399.5 231.7 401.3 230.6 402.1C229.7 402.7 228 402.1 226.9 400.6zM220.6 391.8C219.5 390.5 219.3 389 220.2 388.3C221.1 387.4 222.6 387.9 223.7 388.9C224.8 390.2 225 391.7 224.1 392.4C223.2 393.3 221.7 392.8 220.6 391.8zM214.6 385.4C213.3 384.8 212.7 383.7 213.1 382.8C213.5 382.2 214.6 381.9 215.9 382.4C217.2 383.1 217.8 384.2 217.4 385C217 385.9 215.7 386.1 214.6 385.4z"/></svg> 
                        </a>
                    </div>
                </div>
            </div>

            <!-- Detail Panel -->
            <div class="detail-panel" id="detail-panel">
                <div class="detail-header">
                    <div class="detail-header-content">
                        <div class="detail-id" id="detail-id"></div>
                        <div class="detail-name" id="detail-name"></div>
                    </div>
                    <button class="detail-close" onclick="closeDetail()">Ã—</button>
                </div>
                <div class="detail-content" id="detail-content"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Entity Detail Modal -->
    <div class="modal-overlay" id="entity-modal" onclick="closeEntityModal(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">
                    <span id="entity-modal-id"></span>
                    <span id="entity-modal-name" style="margin-left: 8px; color: var(--text-secondary);"></span>
                </div>
                <button class="modal-close" onclick="closeEntityModal()">Ã—</button>
            </div>
            <div class="modal-body" id="entity-modal-content"></div>
        </div>
    </div>

    <!-- Create STIX Item Modal -->
    <div class="create-custom-modal" id="create-custom-modal" onclick="closeCreateCustomModal(event)">
        <div class="create-custom-form" onclick="event.stopPropagation()">
            <h3>Create STIX Item</h3>
            <label for="custom-stix-type">STIX Type</label>
            <select id="custom-stix-type" onchange="toggleCustomTypeName()"></select>
            <div id="custom-typename-group">
                <label for="custom-typename">Custom Type Name</label>
                <input type="text" id="custom-typename" placeholder="e.g. APT Group Profile" maxlength="80" spellcheck="false">
            </div>
            <label for="custom-name">Name <span style="color:#ef4444;">*</span></label>
            <input type="text" id="custom-name" placeholder="e.g. Emotet, APT29, Cobalt Strike" maxlength="200" spellcheck="false">
            <label for="custom-description">Description</label>
            <textarea id="custom-description" placeholder="Optional description..." maxlength="2000" rows="3"></textarea>
            <label for="custom-labels">Labels <span style="color:var(--text-secondary); font-weight:normal;">(comma-separated, max 20)</span></label>
            <input type="text" id="custom-labels" placeholder="e.g. trojan, botnet, ransomware" maxlength="1200" spellcheck="false">
            <div id="create-custom-error" style="color:#ef4444; font-size:0.8rem; margin-bottom:8px;"></div>
            <div class="form-actions">
                <button class="btn-cancel" onclick="closeCreateCustomModal()">Cancel</button>
                <button class="btn-create" onclick="createCustomItem()">Create</button>
            </div>
        </div>
    </div>

    <!-- Edit STIX Item Modal -->
    <div class="edit-stix-modal" id="edit-stix-modal" onclick="closeStixEditor(event)">
        <div class="edit-stix-form" onclick="event.stopPropagation()">
            <div class="edit-stix-header">
                <div style="display:flex;align-items:center;">
                    <h3>Edit STIX Object</h3>
                    <span class="stix-type-badge" id="edit-stix-type-badge"></span>
                </div>
                <button class="edit-stix-close" onclick="closeStixEditor()">&times;</button>
            </div>
            <div class="edit-stix-body" id="edit-stix-body">
                <!-- Dynamically populated by openStixEditor() -->
            </div>
            <div id="edit-stix-error"></div>
            <div class="edit-stix-footer">
                <button class="btn-stix-cancel" onclick="closeStixEditor()">Cancel</button>
                <button class="btn-stix-save" onclick="saveStixEditor()">Save</button>
            </div>
        </div>
    </div>

    <!-- Metadata Editor Modal -->
    <div class="metadata-editor-overlay" id="metadata-editor-modal" onclick="closeMetadataEditor(event)">
        <div class="metadata-editor" onclick="event.stopPropagation()">
            <div class="metadata-editor-header">
                <div class="metadata-editor-title">Edit Metadata: <span id="metadata-entity-id"></span></div>
                <button class="metadata-editor-close" onclick="closeMetadataEditor()">&times;</button>
            </div>
            <div class="metadata-editor-body">
                <!-- Score -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Score (Severity)</div>
                    <div class="score-selector" id="score-selector">
                        <label class="score-option" data-value="unclassified">
                            <span class="score-dot" style="background: #6b7280;"></span>
                            Unclassified
                        </label>
                        <label class="score-option" data-value="low">
                            <span class="score-dot" style="background: #22c55e;"></span>
                            Low
                        </label>
                        <label class="score-option" data-value="medium">
                            <span class="score-dot" style="background: #eab308;"></span>
                            Medium
                        </label>
                        <label class="score-option" data-value="high">
                            <span class="score-dot" style="background: #f97316;"></span>
                            High
                        </label>
                        <label class="score-option" data-value="critical">
                            <span class="score-dot" style="background: #ef4444;"></span>
                            Critical
                        </label>
                    </div>
                </div>
                
                <!-- Confidence -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Confidence Level</div>
                    <div class="confidence-slider-container">
                        <input type="range" class="confidence-slider" id="meta-confidence" min="0" max="100" value="0">
                        <div class="confidence-value">
                            <span class="confidence-label unknown" id="confidence-label">Unknown</span>
                        </div>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px;">
                        0 = Unknown, 1-33% = Low, 34-66% = Medium, 67-100% = High
                    </div>
                </div>
                
                <!-- CVE & CVSS -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Vulnerability References</div>
                    <div class="cve-list" id="cve-list"></div>
                    <button class="add-btn" onclick="addCveRow()">+ Add CVE</button>
                    <div class="metadata-input-error" id="meta-cve-list-error"></div>
                </div>
                
                <!-- Comments -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Comments</div>
                    <textarea class="metadata-input metadata-textarea" id="meta-comments" placeholder="Add notes about this assignment..."></textarea>
                </div>
                
                <!-- Hyperlinks -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Hyperlinks</div>
                    <div class="hyperlink-list" id="hyperlink-list"></div>
                    <button class="add-btn" onclick="addHyperlinkRow()">+ Add Link</button>
                </div>
                
                <!-- Observables -->
                <div class="metadata-section">
                    <div class="metadata-section-title">Observables</div>
                    <div class="observable-list" id="observable-list"></div>
                    <button class="add-btn" onclick="addObservableRow()">+ Add Observable</button>
                </div>
            </div>
            <div class="metadata-editor-footer">
                <button class="metadata-btn metadata-btn-cancel" onclick="closeMetadataEditor()">Cancel</button>
                <button class="metadata-btn metadata-btn-save" onclick="saveMetadata()">Save</button>
            </div>
        </div>
    </div>

    <!-- Usage Guide Modal -->
    <div class="modal-overlay" id="usage-guide-modal" onclick="closeUsageGuide(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Usage Guide</div>
                <button class="modal-close" onclick="closeUsageGuide()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="guide-section">
                    <h4>Getting Started</h4>
                    <ul>
                        <li>Browse <span class="guide-key">ATT&CK</span>, <span class="guide-key">CAPEC</span>, <span class="guide-key">CWE</span>, and <span class="guide-key">STIX</span> tabs in the left sidebar</li>
                        <li>Use the search bar to find specific techniques, patterns, weaknesses, or STIX objects</li>
                        <li>Click any entity to view detailed information in the right panel</li>
                        <li>Switch to <span class="guide-key">Relationship Explorer</span> to investigate ATT&CK â†” CAPEC â†” CWE â†” Mitigations without assigning items</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>STIX 2.1 Objects</h4>
                    <ul>
                        <li>Open the <span class="guide-key">STIX</span> tab to create or import STIX Domain Objects</li>
                        <li>Click <strong>+ Create STIX Item</strong> to manually create any of the 18 SDO types (plus custom)</li>
                        <li>Click <strong>Import STIX Bundle</strong> to load a STIX 2.1 bundle JSON â€” all SDOs are extracted with full properties</li>
                        <li>Use the type filter dropdown to browse by STIX type (Threat Actor, Malware, Indicator, etc.)</li>
                        <li>Drag STIX items onto kill chain phases just like ATT&CK/CAPEC/CWE entities</li>
                        <li>Click the <span class="guide-key">âœŽ</span> button on assigned STIX items to edit all spec-defined properties</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Drag & Drop</h4>
                    <ul>
                        <li>Drag entities from the sidebar directly onto kill chain phases</li>
                        <li>Drop zones highlight when dragging over them</li>
                        <li>Entities can be reassigned by dragging to a different phase</li>
                        <li>Click the <span class="guide-key">Ã—</span> on an assigned entity to remove it</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Metadata & Enrichment</h4>
                    <ul>
                        <li>Click assigned ATT&CK/CAPEC/CWE entities in the diagram to open the metadata editor</li>
                        <li>Add <strong>Score</strong> (severity) and <strong>Confidence</strong> (assessment certainty)</li>
                        <li>Add multiple <strong>CVE-ID(s)</strong> with optional <strong>scores</strong> and <strong>CVSS vectors</strong></li>
                        <li>Add <strong>Observables</strong>: IPs, hashes, domains, URLs, file names</li>
                        <li>Attach <strong>Hyperlinks</strong> and <strong>Comments</strong> for context</li>
                        <li>CVE badges show full IDs or <strong>CVE (N)</strong> for multiples</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Kill Chain Phases</h4>
                    <ul>
                        <li><span class="guide-color" style="background: var(--phase-in)"></span><strong>IN</strong> â€” Initial Foothold (reconnaissance â†’ C2)</li>
                        <li><span class="guide-color" style="background: var(--phase-through)"></span><strong>THROUGH</strong> â€” Network Propagation (pivoting â†’ lateral movement)</li>
                        <li><span class="guide-color" style="background: var(--phase-out)"></span><strong>OUT</strong> â€” Action on Objectives (collection â†’ impact)</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>View Controls</h4>
                    <ul>
                        <li>Toggle <span class="guide-key">ATT&CK</span> <span class="guide-key">CAPEC</span> <span class="guide-key">CWE</span> <span class="guide-key">STIX</span> layers to show/hide entity types</li>
                        <li>Use domain filters (All / Enterprise / Mobile / ICS) for techniques</li>
                        <li>Use abstraction filters for CAPECs and CWEs</li>
                        <li>Enable <span class="guide-key">Hide Empty</span> to focus on phases with assignments</li>
                        <li>Enable <span class="guide-key">Group by CAPEC</span> to nest techniques under patterns</li>
                        <li>Switch to <span class="guide-key">Relationships</span> view for CAPECâ†’CWEâ†’ATT&CK chains</li>
                        <li>Use <span class="guide-key">Relationship Explorer</span> for full entity and mitigation browsing</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Import & Export</h4>
                    <ul>
                        <li><strong>JSON Export</strong> â€” Lightweight kill chain state for sharing</li>
                        <li><strong>JSON Import</strong> â€” Restore exported kill chains</li>
                        <li><strong>CSV Export</strong> â€” Spreadsheet format with all metadata</li>
                        <li><strong>STIX Bundle Export</strong> â€” Generate a STIX 2.1 bundle with SDOs and relationship SROs</li>
                        <li><strong>STIX Bundle Import</strong> â€” Load external STIX bundles (e.g., CTI reports) into the STIX library</li>
                        <li><strong>Navigator Import</strong> â€” Load ATT&CK Navigator layer files</li>
                        <li>Use <span class="guide-key">Clear All</span> to reset the workspace</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h4>Tips</h4>
                    <ul>
                        <li>Assigned entities appear dimmed in the sidebar</li>
                        <li>Click phase headers to expand/collapse</li>
                        <li>Score colors appear as left border ribbons on items</li>
                        <li>Related CAPECs and CWEs are shown in the detail panel</li>
                        <li>Click the version number to view the changelog</li>
                        <li>The app works offline from <code>file://</code> â€” click "Continue Without Data" on the loading screen</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div class="modal-overlay" id="changelog-modal" onclick="closeChangelog(event)">
        <div class="modal modal-wide" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Changelog</div>
                <button class="modal-close" onclick="closeChangelog()">Ã—</button>
            </div>
            <div class="modal-body changelog-body" id="changelog-content">
                <div class="loading-text">Loading changelog...</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // VERSION - Loaded dynamically from changelog
        // ============================================================
        let APP_VERSION = '2.4.2';  // Fallback version
        
        async function loadVersion() {
            try {
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                const match = text.match(/^## \[([\d.]+)\]/m);
                if (match) {
                    APP_VERSION = match[1];
                    const versionEl = document.getElementById('app-version');
                    if (versionEl) versionEl.textContent = 'v' + APP_VERSION;
                }
            } catch (e) {
                console.warn('Could not load version from changelog:', e);
            }
        }

        // ============================================================
        // INPUT SECURITY - Validation, Sanitization, Escaping
        // ============================================================
        const InputSecurity = {
            // HTML escape to prevent XSS
            escapeHtml(str) {
                if (str === null || str === undefined) return '';
                const div = document.createElement('div');
                div.textContent = String(str);
                return div.innerHTML;
            },

            // Encode HTML entities (including quotes and backticks)
            encodeHtmlEntities(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/`/g, '&#96;');
            },

            // Normalize input: remove control chars, strip script tags, trim, limit length
            normalize(str, maxLength = 1000) {
                if (str === null || str === undefined) return '';
                // NOTE: Do NOT add .trim() here â€” normalize() is called on every
                // keystroke by the live input sanitizer.  Trimming here strips
                // trailing spaces as the user types, making it impossible to
                // enter spaces between words.  Trim at commit/storage time only
                // (see sanitize() and sanitizeForStorage()).  KCE-SEC-010.
                return String(str)
                    .replace(/[\x00-\x1F\x7F]/g, '')  // Remove control chars
                    .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Remove script tags
                    .slice(0, maxLength);
            },
            
            // Sanitize: remove control chars, strip disallowed chars, trim, limit length, encode entities
            sanitize(str, maxLength = 1000) {
                let value = this.normalize(str, maxLength).trim();
                // Remove disallowed bracket/quote/semicolon characters and SQL comment markers
                value = value.replace(/[\[\]\{\};"'`]/g, '');
                value = value.replace(/--+/g, '');
                return this.encodeHtmlEntities(value);
            },
            
            // Sanitize for use in HTML attributes
            sanitizeAttr(str, maxLength = 200) {
                return this.encodeHtmlEntities(this.sanitize(str, maxLength));
            },
            
            // Validators - return { valid: boolean, message?: string }
            validators: {
                ipv4(v) {
                    const valid = /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv4 address' };
                },
                ipv6(v) {
                    const valid = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::$|^(?:[0-9a-fA-F]{1,4}:){1,7}:$|^(?:[0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid IPv6 address' };
                },
                md5(v) {
                    const valid = /^[a-fA-F0-9]{32}$/.test(v);
                    return { valid, message: valid ? null : 'MD5 must be 32 hex characters' };
                },
                sha1(v) {
                    const valid = /^[a-fA-F0-9]{40}$/.test(v);
                    return { valid, message: valid ? null : 'SHA1 must be 40 hex characters' };
                },
                sha256(v) {
                    const valid = /^[a-fA-F0-9]{64}$/.test(v);
                    return { valid, message: valid ? null : 'SHA256 must be 64 hex characters' };
                },
                domain(v) {
                    const valid = /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/.test(v);
                    return { valid, message: valid ? null : 'Invalid domain name' };
                },
                url(v) {
                    const valid = /^https?:\/\/[^\s<>"{}|\\^`\[\]]+$/.test(v);
                    return { valid, message: valid ? null : 'Invalid URL (must start with http:// or https://)' };
                },
                cveId(v) {
                    const valid = /^CVE-\d{4}-\d{4,}$/.test(v);
                    return { valid, message: valid ? null : 'CVE format: CVE-YYYY-NNNNN' };
                },
                cvssVector(v) {
                    const valid = /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(v);
                    return { valid, message: valid ? null : 'Invalid CVSS 3.x vector string' };
                },
                filename(v) {
                    const valid = /^[^<>:"/\\|?*\x00-\x1F]+$/.test(v) && v.length <= 255;
                    return { valid, message: valid ? null : 'Invalid filename' };
                },
                text(v, maxLen = 1000) {
                    const valid = v.length <= maxLen;
                    return { valid, message: valid ? null : `Text exceeds ${maxLen} characters` };
                }
            },
            
            // Validate observable based on type
            validateObservable(type, value) {
                const v = this.normalize(value, 500);
                switch (type) {
                    case 'ipv4-addr': return this.validators.ipv4(v);
                    case 'ipv6-addr': return this.validators.ipv6(v);
                    case 'file-hash-md5': return this.validators.md5(v);
                    case 'file-hash-sha1': return this.validators.sha1(v);
                    case 'file-hash-sha256': return this.validators.sha256(v);
                    case 'domain-name': return this.validators.domain(v);
                    case 'url': return this.validators.url(v);
                    case 'file-name': return this.validators.filename(v);
                    case 'threat-actor':
                    case 'malware':
                        return this.validators.text(v, 100);
                    default:
                        return { valid: true };
                }
            }
        };

        // KCE-SEC-001: Shorthand for escaping HTML in template strings
        const esc = (str) => InputSecurity.escapeHtml(str);
        const escAttr = (str) => InputSecurity.sanitizeAttr(str);

        const BLOCKED_INPUT_CHARS = new Set(['<', '>', '[', ']', '{', '}', '"', "'", '`', ';']);

        function isTextInputElement(el) {
            return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA');
        }

        function sanitizeUserInputText(text) {
            let value = InputSecurity.normalize(text, 10000);
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function sanitizeForStorage(text, maxLength = 1000) {
            let value = InputSecurity.normalize(text, maxLength).trim();
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            value = value.replace(/--+/g, '');
            return value;
        }

        function truncateAtBoundary(text, maxLen = 500) {
            if (!text) return '';
            if (text.length <= maxLen) return text;
            const slice = text.slice(0, maxLen);
            const sentenceMatch = slice.match(/([\s\S]*?[.!?])\s[^.!?]*$/);
            let cut = sentenceMatch ? sentenceMatch[1].trimEnd() : '';
            if (!cut || cut.length < maxLen * 0.6) {
                const wsIndex = slice.lastIndexOf(' ');
                cut = wsIndex > 0 ? slice.slice(0, wsIndex).trimEnd() : slice.trimEnd();
            }
            return `${cut}â€¦`;
        }

        function applyInputGuards() {
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                const key = e.key;
                if (BLOCKED_INPUT_CHARS.has(key)) {
                    e.preventDefault();
                    return;
                }

                if (key === '-') {
                    const value = target.value || '';
                    const start = target.selectionStart ?? 0;
                    const end = target.selectionEnd ?? start;
                    const prev = start > 0 ? value[start - 1] : '';
                    const next = end < value.length ? value[end] : '';
                    if (prev === '-' || next === '-') {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('beforeinput', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                if (e.inputType === 'insertText' && e.data) {
                    if ([...e.data].some(ch => BLOCKED_INPUT_CHARS.has(ch))) {
                        e.preventDefault();
                    }
                    if (e.data.includes('--')) {
                        e.preventDefault();
                    }
                }
            });

            document.addEventListener('paste', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = (e.clipboardData || window.clipboardData)?.getData('text');
                if (!data) return;
                const sanitized = sanitizeUserInputText(data);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('drop', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const data = e.dataTransfer?.getData('text');
                if (!data) return;
                const sanitized = sanitizeUserInputText(data);
                if (sanitized !== data) {
                    e.preventDefault();
                    const value = target.value || '';
                    const start = target.selectionStart ?? value.length;
                    const end = target.selectionEnd ?? value.length;
                    const nextValue = value.slice(0, start) + sanitized + value.slice(end);
                    target.value = nextValue;
                    const cursor = start + sanitized.length;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(cursor, cursor);
                    }
                }
            });

            document.addEventListener('input', (e) => {
                const target = e.target;
                if (!isTextInputElement(target)) return;
                const value = target.value || '';
                const sanitized = sanitizeUserInputText(value);
                if (sanitized !== value) {
                    const pos = target.selectionStart ?? sanitized.length;
                    target.value = sanitized;
                    if (target.setSelectionRange) {
                        target.setSelectionRange(pos, pos);
                    }
                }
            });
        }

        // Encode < and > in any JSON-loaded strings
        function stripAngleBracketsFromJson(value) {
            if (typeof value === 'string') {
                return value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }
            if (Array.isArray(value)) {
                return value.map(stripAngleBracketsFromJson);
            }
            if (value && typeof value === 'object') {
                const cleaned = {};
                for (const [key, val] of Object.entries(value)) {
                    cleaned[key] = stripAngleBracketsFromJson(val);
                }
                return cleaned;
            }
            return value;
        }

        // ============================================================
        // METADATA HELPERS
        // ============================================================
        // Default metadata structure
        function createDefaultMetadata() {
            return {
                score: 'unclassified',     // Color-coded severity: unclassified|low|medium|high|critical
                confidence: null,           // Percentage: null (Unknown) or 1-100
                comments: '',
                cveEntries: [],
                cveId: '',
                cveIds: [],
                hyperlinks: [],    // [{ label, url }]
                observables: []    // [{ type, value }]
            };
        }

        function getCveEntries(metadata) {
            const entries = [];
            if (Array.isArray(metadata?.cveEntries)) {
                metadata.cveEntries.forEach(entry => {
                    const id = (entry?.id || entry?.cveId || '').toString().trim().toUpperCase();
                    const vector = (entry?.vector || entry?.cvssVector || '').toString().trim();
                    const scoreRaw = entry?.score;
                    const score = typeof scoreRaw === 'number' ? scoreRaw : (scoreRaw ? parseFloat(scoreRaw) : null);
                    if (id) {
                        entries.push({ id, score: Number.isFinite(score) ? score : null, vector: vector || '' });
                    }
                });
            }

            if (!entries.length) {
                const rawIds = Array.isArray(metadata?.cveIds)
                    ? metadata.cveIds
                    : (metadata?.cveId ? [metadata.cveId] : []);
                const normalized = rawIds
                    .map(value => (value || '').trim().toUpperCase())
                    .filter(Boolean);
                normalized.forEach(id => {
                    entries.push({ id, score: null, vector: (metadata?.cvssVector || '').trim() });
                });
            }

            return entries;
        }

        function getCveList(metadata) {
            const entries = getCveEntries(metadata);
            const ids = entries.map(entry => entry.id).filter(Boolean);
            return [...new Set(ids)];
        }

        function normalizeCveMetadata(metadata) {
            if (!metadata || typeof metadata !== 'object') return createDefaultMetadata();
            const entries = getCveEntries(metadata);
            metadata.cveEntries = entries;
            metadata.cveIds = entries.map(entry => entry.id);
            metadata.cveId = metadata.cveIds[0] || '';
            return metadata;
        }

        // Get confidence label from percentage value
        function getConfidenceLabel(value) {
            if (value === null || value === undefined || value === 0) return 'Unknown';
            if (value <= 33) return 'Low';
            if (value <= 66) return 'Medium';
            return 'High';
        }

        // Get confidence CSS class
        function getConfidenceClass(value) {
            if (value === null || value === undefined || value === 0) return 'unknown';
            if (value <= 33) return 'low';
            if (value <= 66) return 'medium';
            return 'high';
        }

        let assignmentInstanceCounter = 0;

        function createAssignmentInstanceId() {
            assignmentInstanceCounter += 1;
            return `itm-${Date.now().toString(36)}-${assignmentInstanceCounter}`;
        }

        // Migrate old ID-only format to new object format
        function migrateAssignment(idOrObj) {
            if (typeof idOrObj === 'string') {
                return { id: idOrObj, metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
            }
            // Ensure metadata exists
            if (!idOrObj.metadata) {
                idOrObj.metadata = createDefaultMetadata();
            }
            idOrObj.metadata = normalizeCveMetadata(idOrObj.metadata);
            if (!idOrObj.instanceId) {
                idOrObj.instanceId = createAssignmentInstanceId();
            }
            return idOrObj;
        }

        // Get ID from assignment (handles both old and new format)
        function getAssignmentId(assignment) {
            return typeof assignment === 'string' ? assignment : assignment.id;
        }

        // Get metadata from assignment
        function getAssignmentMetadata(assignment) {
            if (typeof assignment === 'string') return createDefaultMetadata();
            return normalizeCveMetadata(assignment.metadata || createDefaultMetadata());
        }

        function getAssignmentInstanceId(assignment) {
            return typeof assignment === 'string' ? null : assignment.instanceId;
        }

        // ============================================================
        // TYPE MAPPING CONSTANTS
        // ============================================================
        // Canonical mapping from entity type string to assignment array key
        const TYPE_KEYS = {
            attack:  'techniques',
            capec:   'capecs',
            cwe:     'cwes',
            custom:  'customItems'
        };

        // CSS class mapping for entity tags
        const TAG_CLASSES = {
            attack:  'technique-tag',
            capec:   'capec-tag',
            cwe:     'cwe-tag',
            custom:  'custom-tag'
        };

        // Entity type labels for display
        const TYPE_LABELS = {
            attack: 'ATT&CK',
            capec: 'CAPEC',
            cwe: 'CWE',
            custom: 'STIX'
        };

        // All entity type keys for iteration
        const ALL_ENTITY_TYPES = Object.keys(TYPE_KEYS);

        // STIX 2.1 ID format: {type}--{uuid}
        const STIX_ID_PATTERN = /^[a-z][a-z0-9-]*--[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;

        // Valid STIX SDO type values
        const VALID_STIX_TYPES = new Set((typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).map(t => t.value));

        // STIX relationship type defaults by source SDO type
        const STIX_RELATIONSHIP_MAP = {
            'malware': 'uses',
            'tool': 'uses',
            'threat-actor': 'uses',
            'campaign': 'uses',
            'intrusion-set': 'uses',
            'indicator': 'indicates',
            'course-of-action': 'mitigates',
            'infrastructure': 'supports',
            'malware-analysis': 'analysis-of',
            'identity': 'related-to',
            'location': 'related-to',
            'note': 'related-to',
            'observed-data': 'related-to',
            'opinion': 'related-to',
            'report': 'related-to',
            'attack-pattern': 'related-to',
            'grouping': 'related-to',
            'vulnerability': 'related-to',
            'x-custom': 'related-to'
        };

        // Generate a UUIDv4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // Generate a STIX 2.1 compliant ID
        function generateStixId(stixType) {
            return `${stixType}--${generateUUID()}`;
        }

        // Deterministic UUIDv5 from namespace + name (RFC 4122 Â§4.3)
        // Uses SHA-1 truncated to 128 bits with version/variant bits set
        const MITIGATION_NS_UUID = 'af7e2c13-3b4d-4e5f-8a9b-0c1d2e3f4a5b';
        const TECHNIQUE_NS_UUID = 'bf8f3d24-4c5e-5f60-9bac-1d2e3f405b6c';

        function uuidv5(namespace, name) {
            const nsHex = namespace.replace(/-/g, '');
            const nsBytes = new Uint8Array(16);
            for (let i = 0; i < 16; i++) nsBytes[i] = parseInt(nsHex.substr(i * 2, 2), 16);
            const nameBytes = new TextEncoder().encode(name);
            const data = new Uint8Array(nsBytes.length + nameBytes.length);
            data.set(nsBytes); data.set(nameBytes, nsBytes.length);
            const hash = sha1Bytes(data);
            hash[6] = (hash[6] & 0x0f) | 0x50;
            hash[8] = (hash[8] & 0x3f) | 0x80;
            const hex = Array.from(hash.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20,32)}`;
        }

        // Minimal SHA-1 (FIPS 180-4) â€” pure JS, no dependencies
        function sha1Bytes(msgBytes) {
            const msg = Array.from(msgBytes);
            const bitLen = msg.length * 8;
            msg.push(0x80);
            while (msg.length % 64 !== 56) msg.push(0);
            msg.push(0, 0, 0, 0);
            msg.push((bitLen >>> 24) & 0xff, (bitLen >>> 16) & 0xff, (bitLen >>> 8) & 0xff, bitLen & 0xff);
            let h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE, h3 = 0x10325476, h4 = 0xC3D2E1F0;
            for (let off = 0; off < msg.length; off += 64) {
                const w = new Array(80);
                for (let i = 0; i < 16; i++) w[i] = (msg[off+i*4]<<24)|(msg[off+i*4+1]<<16)|(msg[off+i*4+2]<<8)|msg[off+i*4+3];
                for (let i = 16; i < 80; i++) { const t = w[i-3]^w[i-8]^w[i-14]^w[i-16]; w[i] = (t<<1)|(t>>>31); }
                let a=h0, b=h1, c=h2, d=h3, e=h4;
                for (let i = 0; i < 80; i++) {
                    let f, k;
                    if (i<20)      { f=(b&c)|((~b)&d); k=0x5A827999; }
                    else if (i<40) { f=b^c^d;           k=0x6ED9EBA1; }
                    else if (i<60) { f=(b&c)|(b&d)|(c&d); k=0x8F1BBCDC; }
                    else           { f=b^c^d;           k=0xCA62C1D6; }
                    const tmp = ((a<<5)|(a>>>27)) + f + e + k + w[i];
                    e=d; d=c; c=(b<<30)|(b>>>2); b=a; a=tmp|0;
                }
                h0=(h0+a)|0; h1=(h1+b)|0; h2=(h2+c)|0; h3=(h3+d)|0; h4=(h4+e)|0;
            }
            const result = new Uint8Array(20);
            [h0,h1,h2,h3,h4].forEach((h, i) => {
                result[i*4]=(h>>>24)&0xff; result[i*4+1]=(h>>>16)&0xff; result[i*4+2]=(h>>>8)&0xff; result[i*4+3]=h&0xff;
            });
            return result;
        }

        function mitigationStixId(mitreId) {
            return `course-of-action--${uuidv5(MITIGATION_NS_UUID, mitreId)}`;
        }

        function techniqueStixId(techId) {
            return `attack-pattern--${uuidv5(TECHNIQUE_NS_UUID, techId)}`;
        }

        function getPhaseUngroupedItems(phaseData, type) {
            const key = TYPE_KEYS[type];
            if (!key) return [];
            return phaseData?.[key] || [];
        }

        function getPhaseGroupedItems(phaseData, type) {
            const groups = Array.isArray(phaseData?.groups) ? phaseData.groups : [];
            return groups.flatMap(group => (group.items || []).filter(item => item.type === type));
        }

        function getAllPhaseItemsByType(phaseData, type) {
            return [...getPhaseUngroupedItems(phaseData, type), ...getPhaseGroupedItems(phaseData, type)];
        }

        function ensurePhaseLayout(phaseKey, phaseData) {
            if (!phaseData.layout || !Array.isArray(phaseData.layout)) {
                phaseData.layout = [];
            }

            const existingItemIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'item').map(entry => entry.instanceId)
            );
            const existingGroupIds = new Set(
                phaseData.layout.filter(entry => entry.kind === 'group').map(entry => entry.groupId)
            );

            for (const type of ALL_ENTITY_TYPES) {
                const items = getPhaseUngroupedItems(phaseData, type);
                items.forEach(item => {
                    const instanceId = getAssignmentInstanceId(item);
                    if (instanceId && !existingItemIds.has(instanceId)) {
                        phaseData.layout.push({ kind: 'item', type, instanceId });
                        existingItemIds.add(instanceId);
                    }
                });
            }

            (phaseData.groups || []).forEach(group => {
                if (group?.groupId && !existingGroupIds.has(group.groupId)) {
                    phaseData.layout.push({ kind: 'group', groupId: group.groupId });
                    existingGroupIds.add(group.groupId);
                }
            });

            phaseData.layout = phaseData.layout.filter(entry => {
                if (entry.kind === 'item') {
                    const type = entry.type;
                    return getPhaseUngroupedItems(phaseData, type)
                        .some(item => getAssignmentInstanceId(item) === entry.instanceId);
                }
                if (entry.kind === 'group') {
                    return (phaseData.groups || []).some(group => group.groupId === entry.groupId);
                }
                return false;
            });
        }

        function generateGroupId() {
            return `grp-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;
        }

        function createGroup(phaseKey) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = {
                groupId: generateGroupId(),
                label: 'New Group',
                collapsed: false,
                items: []
            };
            phaseData.groups = phaseData.groups || [];
            phaseData.groups.push(group);
            ensurePhaseLayout(phaseKey, phaseData);
            renderKillChain();
            startRenameGroup(phaseKey, group.groupId);
        }

        function toggleGroupCollapse(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.collapsed = !group.collapsed;
            const escapedId = window.CSS && CSS.escape ? CSS.escape(groupId) : groupId.replace(/"/g, '\\"');
            const groupEl = document.querySelector(`.phase-group[data-group-id="${escapedId}"]`);
            if (groupEl) {
                groupEl.classList.toggle('collapsed', group.collapsed);
            } else {
                renderKillChain();
            }
        }

        function startRenameGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = true;
            renderKillChain();
            setTimeout(() => {
                const input = document.getElementById(`group-rename-${groupId}`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 0);
        }

        function commitRenameGroup(phaseKey, groupId, value, cancel = false) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;
            group.editing = false;
            if (!cancel) {
                const sanitized = sanitizeForStorage(value || '', 80).trim();
                group.label = sanitized || 'New Group';
            }
            renderKillChain();
        }

        function removeGroup(phaseKey, groupId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const groupIdx = (phaseData.groups || []).findIndex(g => g.groupId === groupId);
            if (groupIdx === -1) return;

            const group = phaseData.groups[groupIdx];
            if (!window.confirm('Delete this group and move its items back to the phase?')) return;

            const items = group.items || [];
            items.forEach(item => {
                const key = item.type === 'attack' ? 'techniques' : item.type === 'capec' ? 'capecs' : 'cwes';
                phaseData[key].push(item);
                phaseData.layout.push({ kind: 'item', type: item.type, instanceId: getAssignmentInstanceId(item) });
            });

            phaseData.groups.splice(groupIdx, 1);
            phaseData.layout = (phaseData.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function extractAssignmentInstance(phaseKey, type, instanceId) {
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return null;
            const key = TYPE_KEYS[type];
            if (!key) return null;

            const list = phaseData[key];
            const idx = list.findIndex(a => getAssignmentInstanceId(a) === instanceId);
            if (idx !== -1) {
                const [removed] = list.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                return removed;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => getAssignmentInstanceId(a) === instanceId);
                if (gIdx !== -1) {
                    const [removed] = group.items.splice(gIdx, 1);
                    return removed;
                }
            }

            return null;
        }

        function moveGroupBetweenPhases(fromPhase, toPhase, groupId) {
            if (!fromPhase || !toPhase || fromPhase === toPhase) return;
            const source = state.assignments[fromPhase];
            const target = state.assignments[toPhase];
            if (!source || !target) return;

            const idx = (source.groups || []).findIndex(g => g.groupId === groupId);
            if (idx === -1) return;
            const [group] = source.groups.splice(idx, 1);
            target.groups = target.groups || [];
            target.groups.push(group);

            source.layout = (source.layout || []).filter(entry => !(entry.kind === 'group' && entry.groupId === groupId));
            ensurePhaseLayout(toPhase, target);
        }

        // Find assignment object by ID in a phase
        function findAssignment(phaseKey, entityType, id, instanceId = null) {
            const key = TYPE_KEYS[entityType];
            if (!key) return null;
            const phaseData = state.assignments[phaseKey];
            const assignments = phaseData?.[key] || [];
            if (instanceId) {
                const match = assignments.find(a => getAssignmentInstanceId(a) === instanceId);
                if (match) return match;
                for (const group of phaseData?.groups || []) {
                    const groupMatch = (group.items || []).find(a => getAssignmentInstanceId(a) === instanceId);
                    if (groupMatch) return groupMatch;
                }
                return null;
            }

            const match = assignments.find(a => getAssignmentId(a) === id);
            if (match) return match;
            for (const group of phaseData?.groups || []) {
                const groupMatch = (group.items || []).find(a => getAssignmentId(a) === id && a.type === entityType);
                if (groupMatch) return groupMatch;
            }
            return null;
        }

        // Update metadata for an assignment
        function updateAssignmentMetadata(phaseKey, entityType, id, newMetadata, instanceId = null) {
            const key = TYPE_KEYS[entityType];
            if (!key) return;
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const assignments = phaseData[key] || [];

            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                if (typeof assignments[idx] === 'string') {
                    assignments[idx] = { id: assignments[idx], metadata: createDefaultMetadata(), instanceId: createAssignmentInstanceId() };
                }
                assignments[idx].metadata = { ...assignments[idx].metadata, ...newMetadata };
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(a => instanceId
                    ? getAssignmentInstanceId(a) === instanceId
                    : (getAssignmentId(a) === id && a.type === entityType)
                );
                if (gIdx !== -1) {
                    group.items[gIdx].metadata = { ...group.items[gIdx].metadata, ...newMetadata };
                    return;
                }
            }
        }

        // Score level config (color-coded severity)
        const SCORE_LEVELS = {
            unclassified: { label: 'Unclassified', color: null, bgColor: null },
            low: { label: 'Low', color: '#22c55e', bgColor: 'rgba(34, 197, 94, 0.1)' },
            medium: { label: 'Medium', color: '#eab308', bgColor: 'rgba(234, 179, 8, 0.1)' },
            high: { label: 'High', color: '#f97316', bgColor: 'rgba(249, 115, 22, 0.1)' },
            critical: { label: 'Critical', color: '#ef4444', bgColor: 'rgba(239, 68, 68, 0.15)' }
        };

        // Observable types
        const OBSERVABLE_TYPES = [
            { value: 'ipv4-addr', label: 'IPv4 Address' },
            { value: 'ipv6-addr', label: 'IPv6 Address' },
            { value: 'file-hash-md5', label: 'Hash (MD5)' },
            { value: 'file-hash-sha1', label: 'Hash (SHA1)' },
            { value: 'file-hash-sha256', label: 'Hash (SHA256)' },
            { value: 'domain-name', label: 'Domain Name' },
            { value: 'url', label: 'URL' },
            { value: 'file-name', label: 'File Name' },
            { value: 'malware', label: 'Malware Name' },
            { value: 'threat-actor', label: 'Threat Actor' }
        ];

        // ============================================================
        // STATE
        // ============================================================
        const state = {
            view: 'killchain',  // 'killchain' | 'relationship'
            layers: { attack: true, capec: true, cwe: true, custom: true },
            hideEmpty: false,
            compactMode: false,
            activeTab: 'attack',
            filters: { attack: 'all', capec: 'all', cwe: 'all', custom: 'all' },
            
            // Full data libraries (loaded from JSON)
            library: {
                techniques: {},  // T1566 -> { id, name, domain }
                capecs: {},      // CAPEC-98 -> { id, name, severity, ... }
                cwes: {},        // CWE-89 -> { id, name, ... }
                custom: {}       // malware--uuid -> { id, stixType, name, description, labels, created, modified }
            },
            
            // Mappings
            techniqueToCapec: {},
            cweToCapec: {},
            capecToTechnique: {},
            
            // Kill chain title & description
            title: '',
            description: '',

            // Assigned entities (by phase)
            assignments: {},
            
            // Current selection
            selection: { type: null, id: null }
        };

        // Kill chain structure
        const KILL_CHAIN = {
            'IN': {
                name: 'Initial Foothold',
                phases: ['reconnaissance', 'resource-development', 'delivery', 'social-engineering', 'exploitation', 'persistence', 'defense-evasion', 'command-control']
            },
            'THROUGH': {
                name: 'Network Propagation',
                phases: ['pivoting', 'discovery', 'privilege-escalation', 'execution', 'credential-access', 'lateral-movement']
            },
            'OUT': {
                name: 'Action on Objectives',
                phases: ['collection', 'exfiltration', 'impact', 'objectives']
            }
        };

        // All phases in order
        const ALL_PHASES = [];
        for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
            for (const phase of data.phases) {
                ALL_PHASES.push(`${superPhase}:${phase}`);
            }
        }

        // Phase name formatter
        function formatPhaseName(id) {
            return id.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // Initialize all phase assignments
        function initAssignments() {
            for (const [superPhase, data] of Object.entries(KILL_CHAIN)) {
                for (const phase of data.phases) {
                    const key = `${superPhase}:${phase}`;
                    state.assignments[key] = { techniques: [], capecs: [], cwes: [], customItems: [], groups: [], layout: [] };
                }
            }
            // Restore full technique library from base data
            if (state._baseTechniques) {
                state.library.techniques = { ...state._baseTechniques };
            }
            state.title = '';
            state.description = '';
            syncTitleToDOM();
            syncDescriptionToDOM();
        }

        // Kill-chain title helpers
        function commitKillChainTitle(el) {
            const maxLen = CONFIG.display?.maxTitleLength || 200;
            const raw = el.value;
            const clean = sanitizeForStorage(raw, maxLen);
            state.title = clean;
            el.value = clean;
        }

        function syncTitleToDOM() {
            const el = document.getElementById('kill-chain-title');
            if (el) el.value = state.title || '';
        }

        // Kill-chain description helpers
        function commitKillChainDescription(el) {
            const maxLen = CONFIG.display?.maxKillChainDescLength || 2000;
            const raw = el.value;
            const clean = sanitizeForStorage(raw, maxLen);
            state.description = clean;
            el.value = clean;
            updateDescriptionHint();
            updateDescriptionCounter();
        }

        function syncDescriptionToDOM() {
            const el = document.getElementById('kc-desc-textarea');
            if (el) el.value = state.description || '';
            updateDescriptionHint();
            updateDescriptionCounter();
            // Collapse panel on sync
            const bar = document.getElementById('kc-desc-bar');
            if (bar) bar.classList.remove('open');
        }

        function toggleDescriptionPanel() {
            const bar = document.getElementById('kc-desc-bar');
            if (bar) bar.classList.toggle('open');
        }

        function updateDescriptionHint() {
            const hint = document.getElementById('kc-desc-hint');
            if (!hint) return;
            const desc = state.description || '';
            if (desc) {
                const preview = desc.length > 80 ? desc.substring(0, 80) + '\u2026' : desc;
                hint.textContent = '\u2014 ' + preview;
            } else {
                hint.textContent = '\u2014 none';
            }
        }

        function updateDescriptionCounter() {
            const el = document.getElementById('kc-desc-counter');
            const ta = document.getElementById('kc-desc-textarea');
            if (!el || !ta) return;
            const maxLen = CONFIG.display?.maxKillChainDescLength || 2000;
            el.textContent = ta.value.length + ' / ' + maxLen;
        }

        // ============================================================
        // DATA LOADING
        // ============================================================
        async function loadData() {
            try {
                // Load ATT&CK techniques data
                const attackRes = await fetch('resources/attack-techniques.json');
                state.library.techniques = stripAngleBracketsFromJson(await attackRes.json());
                
                // Load CAPEC data
                const capecRes = await fetch('resources/capec-full.json');
                const capecData = stripAngleBracketsFromJson(await capecRes.json());
                state.library.capecs = capecData.patterns;
                
                // Load CWE data
                const cweRes = await fetch('resources/cwe-full.json');
                const cweData = stripAngleBracketsFromJson(await cweRes.json());
                state.library.cwes = cweData.weaknesses;
                
                // Load mappings
                const t2cRes = await fetch('resources/technique-to-capec.json');
                state.techniqueToCapec = stripAngleBracketsFromJson(await t2cRes.json());
                
                const c2tRes = await fetch('resources/capec-to-technique.json');
                state.capecToTechnique = stripAngleBracketsFromJson(await c2tRes.json());
                
                const c2cRes = await fetch('resources/cwe-to-capec.json');
                state.cweToCapec = stripAngleBracketsFromJson(await c2cRes.json());
                
                console.log(`Loaded: ${Object.keys(state.library.techniques).length} techniques, ${Object.keys(state.library.capecs).length} CAPECs, ${Object.keys(state.library.cwes).length} CWEs`);
                
                // Preserve full technique library for Navigator import enrichment
                state._baseTechniques = { ...state.library.techniques };
                
                document.getElementById('loading').classList.add('hidden');
                renderAll();
            } catch (err) {
                console.error('Failed to load data:', err);
                // KCE-SEC-009: Use textContent instead of innerHTML for error messages
                const loadingEl = document.getElementById('loading');
                const loadingText = loadingEl.querySelector('.loading-text');
                loadingText.textContent = 'Error loading data: ' + err.message;
                // Show dismiss button and hint so user can still use the app
                document.getElementById('loading-dismiss').style.display = 'inline-block';
                document.getElementById('loading-hint').style.display = 'block';
            }
        }

        // Load Navigator layer (replaces technique library; preserves mappings & CAPEC/CWE)
        async function loadNavigator(domain) {
            try {
                const res = await fetch(`resources/Nav_Layer_${domain.toUpperCase()}.json`);
                const layer = stripAngleBracketsFromJson(await res.json());
                
                // Replace technique library (mappings & CAPEC/CWE stay intact)
                // Enrich from base library when available for full metadata
                const base = state._baseTechniques || {};
                const newTechniques = {};
                let count = 0;
                for (const tech of layer.techniques || []) {
                    if (tech.enabled === false) continue;
                    const id = tech.techniqueID;
                    if (!id) continue;
                    newTechniques[id] = base[id] || {
                        id,
                        name: `Technique ${id}`,
                        domain: detectDomain(id)
                    };
                    count++;
                }
                state.library.techniques = newTechniques;
                
                showToast(`Loaded ${count} techniques (library replaced)`);
                filterEntities('attack');
            } catch (err) {
                showToast('Error: ' + err.message);
            }
        }

        // KCE-SEC-003: Navigator import validation constants
        const IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024 * 5,  // 25MB
            maxTechniques: 5000,
            maxStringLength: 500,
            techniqueIdPattern: /^T\d{4}(\.\d{3})?$/  // T1234 or T1234.001
        };

        function importNavigator(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // KCE-SEC-003: Validate file size
            if (file.size > IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max 25MB)`);
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const layer = stripAngleBracketsFromJson(JSON.parse(e.target.result));
                    
                    // KCE-SEC-003: Validate it's an object (basic schema check)
                    if (typeof layer !== 'object' || layer === null || Array.isArray(layer)) {
                        throw new Error('Invalid layer format: expected object');
                    }
                    
                    // KCE-SEC-003: Validate techniques array exists and has reasonable size
                    const techniques = layer.techniques;
                    if (!Array.isArray(techniques)) {
                        throw new Error('Invalid layer format: techniques array required');
                    }
                    
                    if (techniques.length > IMPORT_LIMITS.maxTechniques) {
                        throw new Error(`Too many techniques: ${techniques.length} (max ${IMPORT_LIMITS.maxTechniques})`);
                    }
                    
                    let count = 0, skipped = 0;
                    
                    // Replace technique library (mappings & CAPEC/CWE stay intact)
                    // Enrich from base library when available for full metadata
                    const base = state._baseTechniques || {};
                    const newTechniques = {};
                    
                    for (const tech of techniques) {
                        if (tech.enabled === false) continue;
                        
                        // KCE-SEC-003: Validate technique ID format
                        const id = tech.techniqueID;
                        if (!id || typeof id !== 'string') {
                            skipped++;
                            continue;
                        }
                        
                        // Validate ID matches expected pattern (T1234 or T1234.001)
                        if (!IMPORT_LIMITS.techniqueIdPattern.test(id)) {
                            skipped++;
                            continue;
                        }
                        
                        newTechniques[id] = base[id] || {
                            id,
                            name: `Technique ${id}`,
                            domain: detectDomain(id)
                        };
                        count++;
                    }
                    
                    state.library.techniques = newTechniques;
                    
                    let msg = `Loaded ${count} techniques (library replaced)`;
                    if (skipped > 0) msg += `, ${skipped} skipped (invalid ID)`;
                    showToast(msg);
                    filterEntities('attack');
                } catch (err) {
                    showToast('Invalid JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';  // Reset input
        }

        // Domain detection
        function detectDomain(techId) {
            if (techId.startsWith('T0')) return 'ics';
            const num = parseInt(techId.replace(/^T/, '').split('.')[0], 10);
            if (num >= 1398 && num <= 1665) return 'mobile';
            return 'enterprise';
        }

        // Technique name lookup
        function getTechniqueName(techId) {
            // Check active library, then base library
            if (state.library.techniques[techId]) {
                return state.library.techniques[techId].name;
            }
            if (state._baseTechniques?.[techId]) {
                return state._baseTechniques[techId].name;
            }
            return `Technique ${techId}`;
        }

        // ============================================================
        // VIEW & LAYER CONTROLS
        // ============================================================
        const THEME_STORAGE_KEYS = {
            mode: 'af-theme-mode'
        };
        const COMPACT_STORAGE_KEY = 'af-compact-mode';
        let currentTheme = {
            mode: CONFIG?.themeDefaults?.mode || 'light',
            scheme: 'default'
        };

        function getPreferredThemeMode() {
            const configured = CONFIG?.themeMode || CONFIG?.themeDefaults?.mode || 'light';
            if (configured !== 'auto') return configured;
            if (typeof window === 'undefined') return CONFIG?.themeDefaults?.mode || 'light';
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                return 'light';
            }
            return 'dark';
        }

        function normalizeThemeMode(mode) {
            return mode === 'light' || mode === 'dark' ? mode : (CONFIG?.themeDefaults?.mode || 'light');
        }

        function normalizeThemeScheme(mode, scheme) {
            const schemes = CONFIG?.themes?.[mode] || {};
            if (scheme && schemes[scheme]) return scheme;
            if (schemes.default) return 'default';
            const first = Object.keys(schemes)[0];
            return first || 'default';
        }

        function applyTheme(mode, scheme, persist = true) {
            const resolvedMode = normalizeThemeMode(mode);
            const resolvedScheme = normalizeThemeScheme(resolvedMode, scheme);
            const theme = typeof resolveTheme === 'function'
                ? resolveTheme(resolvedMode, resolvedScheme)
                : null;
            if (typeof applyConfigColors === 'function') {
                applyConfigColors(theme || undefined);
            }
            document.documentElement.dataset.theme = resolvedMode;
            currentTheme = { mode: resolvedMode, scheme: resolvedScheme };
            updateThemeControls();
            if (persist) {
                try {
                    localStorage.setItem(THEME_STORAGE_KEYS.mode, resolvedMode);
                } catch (e) {
                    console.warn('Theme preference could not be saved:', e);
                }
            }
        }

        function updateThemeControls() {
            const modeBtn = document.getElementById('theme-mode-toggle');
            if (modeBtn) {
                modeBtn.textContent = currentTheme.mode === 'dark' ? 'Dark' : 'Light';
            }
        }

        function toggleThemeMode() {
            const nextMode = currentTheme.mode === 'dark' ? 'light' : 'dark';
            const nextScheme = normalizeThemeScheme(nextMode, currentTheme.scheme);
            applyTheme(nextMode, nextScheme);
        }

        function initThemeControls() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                console.warn('Theme preference could not be read:', e);
            }

            const mode = normalizeThemeMode(storedMode || getPreferredThemeMode());
            applyTheme(mode, 'default', false);
        }

        function syncThemeFromStorage() {
            let storedMode = null;
            try {
                storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode);
            } catch (e) {
                return;
            }

            const mode = normalizeThemeMode(storedMode || currentTheme.mode);
            if (mode !== currentTheme.mode) {
                applyTheme(mode, 'default', false);
            }
        }

        function setView(view) {
            state.view = view;
            const isExplorer = view === 'explorer';
            const isRelationship = view === 'relationship';
            document.getElementById('view-killchain').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-relationship').classList.toggle('active', isRelationship);
            document.getElementById('view-explorer').classList.toggle('active', isExplorer);
            document.getElementById('view-editor-group').classList.toggle('active', view === 'killchain' || isRelationship);
            document.getElementById('view-explorer-group').classList.toggle('active', isExplorer);
            document.getElementById('kill-chain-container').classList.toggle('hidden', isExplorer || isRelationship);
            document.getElementById('relationship-container').classList.toggle('visible', isRelationship);
            document.getElementById('content-title').textContent = isRelationship ? 'Kill Chain Relationships' : 'Unified Kill Chain';
            document.getElementById('btn-hide-empty').style.display = !isExplorer && !isRelationship ? 'inline-block' : 'none';
            document.getElementById('btn-compact').style.display = !isExplorer && !isRelationship ? 'inline-block' : 'none';
            document.getElementById('stats-bar').style.display = isExplorer ? 'none' : 'flex';
            document.getElementById('legend-row').style.display = isExplorer ? 'none' : 'flex';
            document.querySelector('.app').classList.toggle('explorer-view', isExplorer);
            if (isRelationship) {
                renderRelationshipView();
            }
            updateHideEmptyControl();
            updateCompactControls();
            applyCompactLayout();
        }

        function toggleSidebar() {
            const app = document.querySelector('.app');
            if (!app) return;
            app.classList.toggle('sidebar-collapsed');
            applyCompactLayout();
        }

        function toggleLayer(layer) {
            state.layers[layer] = document.getElementById(`layer-${layer}`).checked;
            renderKillChain();
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function updateHideEmptyControl() {
            const btn = document.getElementById('btn-hide-empty');
            if (!btn) return;
            btn.classList.toggle('active', state.hideEmpty);
            btn.disabled = state.compactMode;
        }

        function updateCompactControls() {
            const btn = document.getElementById('btn-compact');
            if (!btn) return;
            btn.classList.toggle('active', state.compactMode);
            btn.textContent = state.compactMode ? 'Compact On' : 'Compact';
        }

        function setCompactMode(enabled, persist = true) {
            state.compactMode = !!enabled;
            const app = document.querySelector('.app');
            if (app) {
                app.classList.toggle('compact-mode', state.compactMode);
                app.classList.remove('compact-scroll');
            }

            if (state.compactMode) {
                state.hideEmpty = true;
            } else {
                state.hideEmpty = false;
            }

            updateHideEmptyControl();
            updateCompactControls();

            if (persist) {
                try {
                    localStorage.setItem(COMPACT_STORAGE_KEY, state.compactMode ? 'true' : 'false');
                } catch (e) {
                    console.warn('Compact mode preference could not be saved:', e);
                }
            }

            renderKillChain();
        }

        function toggleCompactMode() {
            setCompactMode(!state.compactMode);
        }

        function initCompactMode() {
            let stored = null;
            try {
                stored = localStorage.getItem(COMPACT_STORAGE_KEY);
            } catch (e) {
                console.warn('Compact mode preference could not be read:', e);
            }
            const enabled = stored === 'true';
            state.compactMode = enabled;
            const app = document.querySelector('.app');
            if (app) {
                app.classList.toggle('compact-mode', state.compactMode);
            }
            state.hideEmpty = state.compactMode ? true : false;
            updateHideEmptyControl();
            updateCompactControls();
        }

        function applyCompactLayout() {
            const container = document.getElementById('kill-chain-container');
            if (!container) return;
            const app = document.querySelector('.app');
            if (!state.compactMode || state.view !== 'killchain') {
                if (app) app.classList.remove('compact-scroll');
                container.style.removeProperty('overflow');
                return;
            }
            const killChain = document.getElementById('kill-chain');
            if (!killChain) return;
            const allowScroll = killChain.scrollHeight > container.clientHeight + 4;
            if (app) app.classList.toggle('compact-scroll', allowScroll);
        }

        function toggleHideEmpty() {
            if (state.compactMode) {
                showToast('Disable compact mode to change Hide Empty');
                return;
            }
            state.hideEmpty = !state.hideEmpty;
            updateHideEmptyControl();
            renderKillChain();
        }

        function openMitigationExplorer(mitigationId) {
            if (!mitigationId) return;

            // Validate mitigationId to ensure it matches the expected ID format
            const mitigationIdPattern = /^[A-Za-z0-9_-]+$/;
            if (!mitigationIdPattern.test(mitigationId)) {
                console.error('Invalid mitigationId provided to openMitigationExplorer:', mitigationId);
                return;
            }
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?mitigation=${encodeURIComponent(mitigationId)}`;
            }
            setView('explorer');
        }

        function openEntityExplorer(type, id) {
            if (!type || !id) return;
            const allowed = new Set(['attack', 'capec', 'cwe']);
            if (!allowed.has(type)) return;
            const frame = document.querySelector('.explorer-frame');
            if (frame) {
                frame.src = `explorer.html?entity=${encodeURIComponent(`${type}:${id}`)}`;
            }
            setView('explorer');
        }

        // ============================================================
        // TAB & FILTER CONTROLS
        // ============================================================
        function switchTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.sidebar-tab.${tab}`).classList.add('active');
            document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
        }

        function setFilter(type, filter) {
            state.filters[type] = filter;
            document.querySelectorAll(`#filter-${type} .filter-btn`).forEach(b => {
                b.classList.toggle('active', b.dataset.filter === filter);
            });
            filterEntities(type);
        }

        // ============================================================
        // ENTITY LIST RENDERING
        // ============================================================
        function filterEntities(type) {
            const searchTerm = document.getElementById(`search-${type}`).value.toLowerCase();
            const filter = state.filters[type];
            const listEl = document.getElementById(`list-${type}`);
            
            let entities = [];
            
            if (type === 'attack') {
                entities = Object.values(state.library.techniques).filter(t => {
                    if (searchTerm && !t.id.toLowerCase().includes(searchTerm) && !t.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && t.domain !== filter) return false;
                    return true;
                });
            } else if (type === 'capec') {
                entities = Object.values(state.library.capecs).filter(c => {
                    if (searchTerm && !c.id.toLowerCase().includes(searchTerm) && !c.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && c.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            } else if (type === 'cwe') {
                entities = Object.values(state.library.cwes).filter(w => {
                    if (searchTerm && !w.id.toLowerCase().includes(searchTerm) && !w.name.toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && w.abstraction?.toLowerCase() !== filter) return false;
                    return true;
                });
            } else if (type === 'custom') {
                entities = Object.values(state.library.custom).filter(c => {
                    if (searchTerm && !c.name.toLowerCase().includes(searchTerm) && !c.id.toLowerCase().includes(searchTerm)
                        && !(c.description || '').toLowerCase().includes(searchTerm)) return false;
                    if (filter !== 'all' && c.stixType !== filter) return false;
                    return true;
                });
            }
            
            // Limit display for performance
            const maxDisplay = 100;
            const total = entities.length;
            entities = entities.slice(0, maxDisplay);
            
            let html = '';
            
            for (const entity of entities) {
                const isSelected = state.selection.type === type && state.selection.id === entity.id;
                
                if (type === 'attack') {
                    const subIndicator = entity.isSubtechnique ? 'â†³ ' : '';
                    const tacticBadge = entity.tactics?.length ? `<span class="entity-badge">${esc(entity.tactics[0])}</span>` : '';
                    html += `
                        <div class="entity-item attack ${isSelected ? 'selected' : ''}" 
                             onclick="selectEntity('attack', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'attack', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)"
                             title="${escAttr(entity.description ? entity.description.substring(0, 200) + '...' : '')}">
                            <div class="entity-header">
                                <span class="entity-id">${subIndicator}${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.domain?.toUpperCase() || 'ENT')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                ${tacticBadge}
                                ${entity.platforms?.length ? `<span class="entity-badge">${esc(entity.platforms.slice(0,2).join(', '))}</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'capec') {
                    const severityClass = entity.severity?.toLowerCase().includes('high') ? 'severity-high' : 
                                         entity.severity?.toLowerCase().includes('medium') ? 'severity-medium' : 'severity-low';
                    html += `
                        <div class="entity-item capec ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('capec', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'capec', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge ${severityClass}">${esc(entity.severity || 'Unknown')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            <div class="entity-meta">
                                <span class="entity-badge">${esc(entity.abstraction || 'Standard')}</span>
                                ${entity.techniques?.length ? `<span class="entity-badge">${entity.techniques.length} techniques</span>` : ''}
                            </div>
                        </div>
                    `;
                } else if (type === 'cwe') {
                    html += `
                        <div class="entity-item cwe ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('cwe', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'cwe', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)">
                            <div class="entity-header">
                                <span class="entity-id">${esc(entity.id)}</span>
                                <span class="entity-badge">${esc(entity.abstraction || 'Base')}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                        </div>
                    `;
                } else if (type === 'custom') {
                    const stixLabel = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).find(t => t.value === entity.stixType)?.label || entity.stixType;
                    const customTypeName = entity.stixType === 'x-custom' && entity.customTypeName ? ` (${esc(entity.customTypeName)})` : '';
                    const shortId = entity.id.length > 20 ? entity.id.substring(0, 18) + '...' : entity.id;
                    html += `
                        <div class="entity-item custom ${isSelected ? 'selected' : ''}"
                             onclick="selectEntity('custom', '${esc(entity.id)}')"
                             draggable="true"
                             ondragstart="handleDragStart(event, 'custom', '${esc(entity.id)}')"
                             ondragend="handleDragEnd(event)"
                             title="${escAttr(entity.description ? entity.description.substring(0, 200) : '')}">
                            <div class="entity-header">
                                <span class="entity-id">${esc(shortId)}</span>
                                <span class="entity-badge stix-badge">${esc(stixLabel)}${customTypeName}</span>
                            </div>
                            <div class="entity-name">${esc(entity.name)}</div>
                            ${entity.labels?.length ? `<div class="entity-meta">${entity.labels.slice(0,3).map(l => `<span class="entity-badge">${esc(l)}</span>`).join('')}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            if (total > maxDisplay) {
                html += `<div class="list-info">Showing ${maxDisplay} of ${total}. Refine your search.</div>`;
            } else if (entities.length === 0) {
                const typeLabels = { attack: 'techniques', capec: 'patterns', cwe: 'weaknesses', custom: 'STIX items' };
                html += `<div class="list-info">No ${typeLabels[type] || 'items'} found</div>`;
            }
            
            listEl.innerHTML = html;
        }

        function isEntityAssigned(type, id) {
            for (const phase of Object.values(state.assignments)) {
                const items = getAllPhaseItemsByType(phase, type);
                if (items.some(a => getAssignmentId(a) === id)) return true;
            }
            return false;
        }

        // ============================================================
        // CUSTOM ITEM MANAGEMENT (STIX 2.1)
        // ============================================================

        // --- STIX Bundle Import ---
        const STIX_BUNDLE_IMPORT_LIMITS = {
            maxFileSize: 25 * 1024 * 1024,  // 25 MB
            maxObjects: 5000,
            maxStringLength: 5000,
            maxListItems: 100,
            maxNameLength: 200,
            maxDescLength: 10000
        };

        function importStixBundle(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > STIX_BUNDLE_IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB (max ${STIX_BUNDLE_IMPORT_LIMITS.maxFileSize / 1024 / 1024}MB)`);
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    const data = stripAngleBracketsFromJson(rawData);

                    // Validate top-level bundle structure
                    if (typeof data !== 'object' || data === null || Array.isArray(data)) {
                        throw new Error('Invalid STIX bundle: expected JSON object');
                    }
                    if (data.type !== 'bundle') {
                        throw new Error('Invalid STIX bundle: top-level type must be "bundle"');
                    }
                    if (!Array.isArray(data.objects)) {
                        throw new Error('Invalid STIX bundle: missing objects array');
                    }
                    if (data.objects.length > STIX_BUNDLE_IMPORT_LIMITS.maxObjects) {
                        throw new Error(`Too many objects: ${data.objects.length} (max ${STIX_BUNDLE_IMPORT_LIMITS.maxObjects})`);
                    }

                    let imported = 0, skipped = 0, duplicates = 0;

                    // Auto-clear existing STIX data if configured
                    if (CONFIG.imports?.clearStixOnBundleImport) {
                        for (const [phaseKey, pd] of Object.entries(state.assignments)) {
                            if (!pd) continue;
                            if (pd.customItems) pd.customItems = [];
                            for (const group of pd.groups || []) {
                                group.items = (group.items || []).filter(item => item.type !== 'custom');
                            }
                            ensurePhaseLayout(phaseKey, pd);
                        }
                        state.library.custom = {};
                    }

                    for (const obj of data.objects) {
                        // Basic object validation
                        if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
                            skipped++;
                            continue;
                        }

                        const objType = obj.type;
                        if (typeof objType !== 'string') { skipped++; continue; }

                        // Skip relationships to catch and SROs â€” only import SDOs
                        if (objType === 'relationship' || objType === 'sighting' || objType === 'marking-definition') {
                            continue;
                        }

                        // Validate type is in our supported SDO list
                        if (!VALID_STIX_TYPES.has(objType)) {
                            skipped++;
                            continue;
                        }

                        // Validate STIX ID format
                        const objId = obj.id;
                        if (typeof objId !== 'string' || !STIX_ID_PATTERN.test(objId)) {
                            skipped++;
                            continue;
                        }

                        // Verify ID prefix matches declared type
                        if (objId.split('--')[0] !== objType) {
                            skipped++;
                            continue;
                        }

                        // Skip if already exists in library
                        if (state.library.custom[objId]) {
                            duplicates++;
                            continue;
                        }

                        // Validate name exists (most SDOs require it)
                        const rawName = obj.name;
                        if (typeof rawName !== 'string' || rawName.trim().length === 0) {
                            // Some SDOs (observed-data, opinion, note) may lack name â€” synthesize one
                            if (!['observed-data', 'opinion', 'note', 'report'].includes(objType)) {
                                skipped++;
                                continue;
                            }
                        }

                        // Build sanitized library entry
                        const entry = sanitizeStixBundleObject(obj, objType, objId);
                        if (!entry) { skipped++; continue; }

                        state.library.custom[objId] = entry;
                        imported++;
                    }

                    // Build result message
                    let msg = `Imported ${imported} STIX object${imported !== 1 ? 's' : ''}`;
                    if (duplicates > 0) msg += `, ${duplicates} duplicate${duplicates !== 1 ? 's' : ''} skipped`;
                    if (skipped > 0) msg += `, ${skipped} invalid skipped`;

                    switchTab('custom');
                    filterEntities('custom');
                    if (CONFIG.imports?.clearStixOnBundleImport) renderAll();
                    showToast(msg);
                } catch (err) {
                    showToast('STIX import failed: ' + InputSecurity.escapeHtml(err.message));
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearStixLibrary() {
            const count = Object.keys(state.library.custom).length;
            if (count === 0) {
                showToast('No STIX items to clear');
                return;
            }
            if (!confirm(`Clear all ${count} STIX item${count !== 1 ? 's' : ''} from the library and remove them from all kill chain phases?`)) return;

            // Remove custom items from all phase assignments (ungrouped + grouped)
            for (const [phaseKey, pd] of Object.entries(state.assignments)) {
                if (!pd) continue;
                if (pd.customItems) pd.customItems = [];
                for (const group of pd.groups || []) {
                    group.items = (group.items || []).filter(item => item.type !== 'custom');
                }
                ensurePhaseLayout(phaseKey, pd);
            }

            // Clear the library
            state.library.custom = {};

            filterEntities('custom');
            renderAll();
            showToast(`Cleared ${count} STIX item${count !== 1 ? 's' : ''}`);
        }

        function sanitizeStixBundleObject(obj, stixType, stixId) {
            const L = STIX_BUNDLE_IMPORT_LIMITS;

            // Core fields â€” sanitized as untrusted input
            const name = sanitizeImportedString(
                typeof obj.name === 'string' ? obj.name : (stixType + ' ' + stixId.split('--')[1].slice(0, 8)),
                L.maxNameLength
            );

            const description = sanitizeImportedString(
                typeof obj.description === 'string' ? obj.description : '',
                L.maxDescLength
            );

            const labels = Array.isArray(obj.labels)
                ? obj.labels
                    .slice(0, L.maxListItems)
                    .filter(l => typeof l === 'string')
                    .map(l => sanitizeImportedString(l, 100))
                : [];

            const created = typeof obj.created === 'string'
                ? obj.created.slice(0, 30)
                : new Date().toISOString();
            const modified = typeof obj.modified === 'string'
                ? obj.modified.slice(0, 30)
                : new Date().toISOString();

            const entry = {
                id: stixId,
                stixType: stixType,
                name: name,
                description: description,
                labels: labels,
                customTypeName: '',
                created: created,
                modified: modified
            };

            // Import spec-defined fields from stix-config.js
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (typeDef) {
                const coreKeys = new Set(['name', 'description', 'labels']);
                const specFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !coreKeys.has(f.key));
                for (const field of specFields) {
                    if (!(field.key in obj)) continue;
                    const raw = obj[field.key];
                    if (field.type === 'boolean') {
                        entry[field.key] = !!raw;
                    } else if (field.type === 'integer') {
                        const num = parseInt(raw, 10);
                        if (!isNaN(num)) entry[field.key] = num;
                    } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                        if (Array.isArray(raw)) {
                            entry[field.key] = raw
                                .slice(0, L.maxListItems)
                                .filter(v => typeof v === 'string')
                                .map(v => sanitizeImportedString(v, 200));
                        }
                    } else {
                        // string, text, enum, open-vocab, timestamp, identifier
                        if (typeof raw === 'string') {
                            entry[field.key] = sanitizeImportedString(raw, L.maxStringLength);
                        }
                    }
                }
            }

            return entry;
        }
        function populateStixTypeDropdown() {
            const select = document.getElementById('custom-stix-type');
            const filterSelect = document.getElementById('filter-custom-type');
            if (!select) return;
            select.innerHTML = '';
            if (filterSelect) filterSelect.innerHTML = '<option value="all">All Types</option>';
            const types = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes) || [];
            for (const t of types) {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.label;
                select.appendChild(opt);
                if (filterSelect) {
                    const fopt = document.createElement('option');
                    fopt.value = t.value;
                    fopt.textContent = t.label;
                    filterSelect.appendChild(fopt);
                }
            }
        }

        function toggleCustomTypeName() {
            const typeVal = document.getElementById('custom-stix-type').value;
            const group = document.getElementById('custom-typename-group');
            if (group) group.style.display = typeVal === 'x-custom' ? 'block' : 'none';
        }

        function openCreateCustomModal() {
            populateStixTypeDropdown();
            document.getElementById('custom-name').value = '';
            document.getElementById('custom-description').value = '';
            document.getElementById('custom-labels').value = '';
            document.getElementById('custom-typename').value = '';
            document.getElementById('create-custom-error').textContent = '';
            toggleCustomTypeName();
            document.getElementById('create-custom-modal').classList.add('visible');
        }

        function closeCreateCustomModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('create-custom-modal').classList.remove('visible');
        }

        function createCustomItem() {
            const errorEl = document.getElementById('create-custom-error');
            errorEl.textContent = '';

            const stixType = document.getElementById('custom-stix-type').value;
            const rawName = document.getElementById('custom-name').value;
            const rawDesc = document.getElementById('custom-description').value;
            const rawLabels = document.getElementById('custom-labels').value;
            const rawTypeName = document.getElementById('custom-typename').value;

            // Validate STIX type
            if (!VALID_STIX_TYPES.has(stixType)) {
                errorEl.textContent = 'Invalid STIX type selected.';
                return;
            }

            // Sanitize name
            const name = sanitizeForStorage(rawName, CONFIG.display?.maxNameLength || 200);
            if (!name || name.trim().length === 0) {
                errorEl.textContent = 'Name is required.';
                return;
            }

            // Sanitize description
            const description = sanitizeForStorage(rawDesc, CONFIG.display?.maxCustomDescLength || 2000);

            // Sanitize labels
            const maxLabels = CONFIG.display?.maxCustomLabels || 20;
            const maxLabelLen = CONFIG.display?.maxLabelLength || 50;
            const labels = rawLabels
                .split(',')
                .map(l => sanitizeForStorage(l.trim(), maxLabelLen))
                .filter(l => l.length > 0)
                .slice(0, maxLabels);

            // Sanitize custom type name (for x-custom only)
            let customTypeName = '';
            if (stixType === 'x-custom') {
                customTypeName = sanitizeForStorage(rawTypeName, 80);
            }

            // Generate STIX ID
            const id = generateStixId(stixType);
            const now = new Date().toISOString();

            // Store in library
            state.library.custom[id] = {
                id,
                stixType,
                name,
                description,
                labels,
                customTypeName,
                created: now,
                modified: now
            };

            closeCreateCustomModal();
            switchTab('custom');
            filterEntities('custom');
            showToast(`Created: ${name}`);
        }

        function deleteCustomItem(id) {
            if (!id || !state.library.custom[id]) return;
            if (!window.confirm('Delete this STIX item? It will also be removed from all phase assignments.')) return;

            // Remove from library
            delete state.library.custom[id];

            // Remove from all phase assignments
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                phaseData.customItems = (phaseData.customItems || []).filter(a => getAssignmentId(a) !== id);
                for (const group of phaseData.groups || []) {
                    group.items = (group.items || []).filter(item => !(item.type === 'custom' && getAssignmentId(item) === id));
                }
                ensurePhaseLayout(phaseKey, phaseData);
            }

            filterEntities('custom');
            renderKillChain();
            showToast('STIX item deleted');
        }

        // ============================================================
        // STIX EDITOR MODAL
        // ============================================================
        let currentStixEdit = { id: null, phaseKey: null, instanceId: null };

        function openStixEditor(id, phaseKey, instanceId) {
            const item = state.library.custom[id];
            if (!item) { showToast('Item not found', 'error'); return; }

            currentStixEdit = { id, phaseKey: phaseKey || null, instanceId: instanceId || null };
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;

            // Header
            const badgeEl = document.getElementById('edit-stix-type-badge');
            badgeEl.textContent = typeDef ? typeDef.label : stixType;

            // Build form fields
            const body = document.getElementById('edit-stix-body');
            body.innerHTML = '';
            const errorEl = document.getElementById('edit-stix-error');
            errorEl.textContent = '';

            // -- Common read-only fields --
            body.innerHTML += '<div class="edit-stix-section-title">Identity</div>';
            body.innerHTML += buildStixReadonlyField('ID', item.id);
            body.innerHTML += buildStixReadonlyField('Type', stixType);
            body.innerHTML += buildStixReadonlyField('Created', item.created || 'â€”');
            body.innerHTML += buildStixReadonlyField('Modified', item.modified || 'â€”');

            // -- Core editable fields (always present) --
            body.innerHTML += '<div class="edit-stix-section-title">Core Properties</div>';
            body.innerHTML += buildStixTextField('stix-edit-name', 'Name', item.name || '', true, 200, 'Display name');
            body.innerHTML += buildStixTextareaField('stix-edit-description', 'Description', item.description || '', false, 2000, 'Optional description...');
            body.innerHTML += buildStixTextField('stix-edit-labels', 'Labels (comma-separated)', (item.labels || []).join(', '), false, 1200, 'e.g. trojan, botnet');

            if (stixType === 'x-custom') {
                body.innerHTML += buildStixTextField('stix-edit-typename', 'Custom Type Name', item.customTypeName || '', false, 80, 'e.g. APT Group Profile');
            }

            // -- Spec-defined fields from stix-config.js --
            if (typeDef) {
                const existingKeys = new Set(['name', 'description', 'labels']);

                // Required fields
                const reqFields = (typeDef.required || []).filter(f => !existingKeys.has(f.key));
                if (reqFields.length > 0) {
                    body.innerHTML += '<div class="edit-stix-section-title">Required Fields</div>';
                    for (const field of reqFields) {
                        body.innerHTML += buildStixFieldFromSpec(field, item, true);
                    }
                }

                // Optional fields
                const optFields = (typeDef.optional || []).filter(f => !existingKeys.has(f.key));
                if (optFields.length > 0) {
                    body.innerHTML += '<div class="edit-stix-section-title">Optional Fields</div>';
                    for (const field of optFields) {
                        body.innerHTML += buildStixFieldFromSpec(field, item, false);
                    }
                }
            }

            document.getElementById('edit-stix-modal').classList.add('visible');
        }

        function closeStixEditor(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('edit-stix-modal').classList.remove('visible');
            currentStixEdit = { id: null, phaseKey: null, instanceId: null };
        }

        function saveStixEditor() {
            const { id } = currentStixEdit;
            const item = state.library.custom[id];
            if (!item) { closeStixEditor(); return; }

            const errorEl = document.getElementById('edit-stix-error');
            errorEl.textContent = '';

            // Read core fields
            const nameEl = document.getElementById('stix-edit-name');
            const descEl = document.getElementById('stix-edit-description');
            const labelsEl = document.getElementById('stix-edit-labels');
            const typeNameEl = document.getElementById('stix-edit-typename');

            const rawName = nameEl ? nameEl.value : '';
            const name = sanitizeForStorage(rawName, CONFIG.display?.maxNameLength || 200);
            if (!name || name.trim().length === 0) {
                errorEl.textContent = 'Name is required.';
                return;
            }

            item.name = name;
            item.description = sanitizeForStorage(descEl ? descEl.value : '', CONFIG.display?.maxCustomDescLength || 2000);

            const maxLabels = CONFIG.display?.maxCustomLabels || 20;
            const maxLabelLen = CONFIG.display?.maxLabelLength || 50;
            item.labels = (labelsEl ? labelsEl.value : '')
                .split(',')
                .map(l => sanitizeForStorage(l.trim(), maxLabelLen))
                .filter(l => l.length > 0)
                .slice(0, maxLabels);

            if (typeNameEl) {
                item.customTypeName = sanitizeForStorage(typeNameEl.value, 80);
            }

            // Read spec-defined fields
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (typeDef) {
                const existingKeys = new Set(['name', 'description', 'labels']);
                const allFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !existingKeys.has(f.key));
                for (const field of allFields) {
                    const fieldEl = document.getElementById('stix-edit-' + field.key);
                    if (!fieldEl) continue;
                    const rawVal = fieldEl.value || '';
                    if (field.type === 'boolean') {
                        item[field.key] = fieldEl.checked;
                    } else if (field.type === 'integer') {
                        const num = parseInt(rawVal, 10);
                        item[field.key] = isNaN(num) ? undefined : num;
                    } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                        item[field.key] = rawVal.split(',').map(s => sanitizeForStorage(s.trim(), 200)).filter(s => s.length > 0);
                    } else {
                        item[field.key] = sanitizeForStorage(rawVal, 2000);
                    }
                }
            }

            item.modified = new Date().toISOString();
            closeStixEditor();
            filterEntities('custom');
            renderKillChain();
            showToast('STIX item updated');
        }

        // -- STIX Editor field builders --
        function buildStixReadonlyField(label, value) {
            return `<div class="stix-field-group">
                <label>${esc(label)}</label>
                <input type="text" value="${esc(value)}" readonly>
            </div>`;
        }

        function buildStixTextField(id, label, value, required, maxLen, placeholder) {
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            return `<div class="stix-field-group">
                <label>${esc(label)}${reqMark}</label>
                <input type="text" id="${esc(id)}" value="${esc(value)}" maxlength="${maxLen || 200}" placeholder="${esc(placeholder || '')}" spellcheck="false">
            </div>`;
        }

        function buildStixTextareaField(id, label, value, required, maxLen, placeholder) {
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            return `<div class="stix-field-group">
                <label>${esc(label)}${reqMark}</label>
                <textarea id="${esc(id)}" maxlength="${maxLen || 2000}" rows="3" placeholder="${esc(placeholder || '')}">${esc(value)}</textarea>
            </div>`;
        }

        function buildStixFieldFromSpec(field, item, required) {
            const fieldId = 'stix-edit-' + field.key;
            const reqMark = required ? '<span class="field-required">*</span>' : '';
            const currentVal = item[field.key];
            const hint = field.description ? `<div class="field-hint">${esc(field.description)}</div>` : '';

            switch (field.type) {
                case 'string':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" maxlength="2000" placeholder="${esc(field.placeholder || '')}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'text':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <textarea id="${esc(fieldId)}" maxlength="5000" rows="3" placeholder="${esc(field.placeholder || '')}">${esc(currentVal || '')}</textarea>
                        ${hint}
                    </div>`;

                case 'enum':
                case 'open-vocab': {
                    const vocabValues = field.vocabulary ? getStixVocabulary(field.vocabulary) : [];
                    let opts = '<option value="">â€” Select â€”</option>';
                    for (const v of vocabValues) {
                        const sel = (currentVal === v) ? ' selected' : '';
                        opts += `<option value="${esc(v)}"${sel}>${esc(v)}</option>`;
                    }
                    if (field.type === 'open-vocab') {
                        // If current value is not in vocab, add it as option
                        if (currentVal && !vocabValues.includes(currentVal)) {
                            opts += `<option value="${esc(currentVal)}" selected>${esc(currentVal)} (custom)</option>`;
                        }
                    }
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <select id="${esc(fieldId)}">${opts}</select>
                        ${hint}
                    </div>`;
                }

                case 'list':
                case 'list:open-vocab': {
                    const arrVal = Array.isArray(currentVal) ? currentVal.join(', ') : (currentVal || '');
                    const vocabHint = (field.type === 'list:open-vocab' && field.vocabulary)
                        ? `<div class="field-hint">Values: ${getStixVocabulary(field.vocabulary).join(', ')}</div>`
                        : '';
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)} <span style="color:var(--text-secondary);font-weight:normal;">(comma-separated)</span>${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(arrVal)}" maxlength="2000" spellcheck="false">
                        ${hint}${vocabHint}
                    </div>`;
                }

                case 'integer':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="number" id="${esc(fieldId)}" value="${currentVal != null ? currentVal : ''}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'boolean':
                    return `<div class="stix-field-group">
                        <label style="display:inline-flex;align-items:center;gap:6px;">
                            <input type="checkbox" id="${esc(fieldId)}" ${currentVal ? 'checked' : ''} style="width:auto;">
                            ${esc(field.label)}${reqMark}
                        </label>
                        ${hint}
                    </div>`;

                case 'timestamp':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" placeholder="YYYY-MM-DDThh:mm:ss.sssZ" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'identifier':
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" placeholder="${esc(field.placeholder || 'type--uuid')}" spellcheck="false">
                        ${hint}
                    </div>`;

                case 'kill-chain-phases':
                case 'external-references':
                case 'dictionary':
                    // Complex types: render as JSON textarea for now
                    const jsonVal = currentVal ? JSON.stringify(currentVal, null, 2) : '';
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)} <span style="color:var(--text-secondary);font-weight:normal;">(JSON)</span>${reqMark}</label>
                        <textarea id="${esc(fieldId)}" rows="3" placeholder="${esc(field.description || '')}">${esc(jsonVal)}</textarea>
                        ${hint}
                    </div>`;

                default:
                    return `<div class="stix-field-group">
                        <label>${esc(field.label)}${reqMark}</label>
                        <input type="text" id="${esc(fieldId)}" value="${esc(currentVal || '')}" spellcheck="false">
                        ${hint}
                    </div>`;
            }
        }

        // Get display name for an entity by type
        function getEntityName(type, id) {
            if (type === 'attack') return state.library.techniques[id]?.name || '';
            if (type === 'capec') return state.library.capecs[id]?.name || '';
            if (type === 'cwe') return state.library.cwes[id]?.name || '';
            if (type === 'custom') return state.library.custom[id]?.name || '';
            return '';
        }

        // ============================================================
        // SELECTION & DETAIL
        // ============================================================

        // Replace ATT&CK markdown links in descriptions with clickable
        // technique-ID badges that open the integrated Explorer view.
        // Runs on already-escaped text (after esc()).  All regex captures
        // are treated as UNTRUSTED â€” the label is escaped with escAttr()
        // before any attribute insertion to prevent attribute-breakout XSS.
        // See FINDINGS.md KCE-SEC-010, TASKS.md Task 23.
        function renderDescriptionWithBadges(escapedText) {
            return escapedText.replace(
                /\[([^\]]{1,80})\]\(https?:\/\/attack\.mitre\.org\/techniques\/(T\d{4}(?:\/\d{3})?)\)/g,
                (match, label, rawId) => {
                    const id = rawId.replace('/', '.');
                    const safeTitle = escAttr(label);
                    return `<span class="technique-xref-badge" `
                         + `onclick="openEntityExplorer('attack', '${id}')" `
                         + `title="${safeTitle}">${id}</span>`;
                }
            );
        }

        function selectEntity(type, id) {
            state.selection = { type, id };
            
            // Update list selection
            filterEntities(type);
            
            // Show detail panel
            showDetail(type, id);
        }

        function isSafeHttpUrl(url) {
            if (typeof url !== 'string') return false;
            const trimmed = url.trim();
            if (!trimmed) return false;
            try {
                const parsed = new URL(trimmed);
                return parsed.protocol === 'http:' || parsed.protocol === 'https:';
            } catch (e) {
                return false;
            }
        }

        function buildEntityDetail(type, id) {
            let entity, html = '', name = 'Unknown';

            if (type === 'attack') {
                entity = state.library.techniques[id] || state._baseTechniques?.[id];
                name = entity?.name || 'Unknown';

                const relatedCapecs = state.techniqueToCapec[id] || [];
                const platforms = entity?.platforms?.join(', ') || 'N/A';
                const tactics = entity?.tactics?.map(t => t.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(', ') || 'N/A';

                const mitigations = entity?.mitigations || [];
                const mitigationsHtml = mitigations.length > 0 
                    ? mitigations.slice(0, 8).map(m => `
                        <div class="detail-list-item" style="cursor: pointer;" onclick="openMitigationExplorer('${escAttr(m.id)}')" title="${escAttr(m.description || '')}">
                            <span class="id" style="color: #10b981;">${esc(m.id)}</span>
                            <span>${esc(m.name)}</span>
                        </div>
                    `).join('') + (mitigations.length > 8 ? `<div class="list-info">+${mitigations.length - 8} more</div>` : '')
                    : '<div class="list-info">No mitigations available</div>';

                const refs = entity?.references || [];
                const refsHtml = refs.slice(0, 3).map(r => {
                    const url = r?.url || '';
                    const isSafeUrl = isSafeHttpUrl(url);
                    return isSafeUrl ? `
                    <div class="detail-list-item">
                        <a href="${escAttr(url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(r.name)} â†’
                        </a>
                    </div>
                ` : '';
                }).join('');

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${renderDescriptionWithBadges(esc(entity?.description || 'No description available.'))}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Domain:</span><span>${esc((entity?.domain || 'enterprise').toUpperCase())}</span></div>
                            <div class="detail-list-item"><span>Platforms:</span><span>${esc(platforms)}</span></div>
                            <div class="detail-list-item"><span>Tactics:</span><span>${esc(tactics)}</span></div>
                            ${entity?.isSubtechnique ? `<div class="detail-list-item"><span>Parent:</span><span onclick="selectEntity('attack', '${escAttr(entity.parentTechnique)}')" style="cursor:pointer; color: var(--attack-color);">${esc(entity.parentTechnique)}</span></div>` : ''}
                            <div class="detail-list-item"><span>Version:</span><span>${esc(entity?.version || '1.0')}</span></div>
                        </div>
                    </div>
                    ${entity?.detection ? `
                    <div class="detail-section">
                        <h4>Detection</h4>
                        <details>
                            <summary>Show / hide detection guidance</summary>
                            <p style="font-size: 0.75rem;">${renderDescriptionWithBadges(esc(entity.detection))}</p>
                        </details>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <h4>Mitigations (${mitigations.length})</h4>
                        <div class="detail-list">
                            ${mitigationsHtml}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length === 0 ? '<div class="list-info">No CAPEC mappings</div>' : ''}
                        </div>
                    </div>
                    ${refs.length > 0 ? `
                    <div class="detail-section">
                        <h4>References</h4>
                        <div class="detail-list">
                            ${refsHtml}
                        </div>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <a href="https://attack.mitre.org/techniques/${id.replace('.', '/')}" target="_blank" rel="noopener noreferrer" style="color: var(--attack-color);">View on MITRE ATT&CK â†’</a>
                    </div>
                `;
            } else if (type === 'capec') {
                entity = state.library.capecs[id];
                name = entity?.name || 'Unknown';

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${esc(entity?.description || 'No description available.')}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>Severity:</span><span>${esc(entity?.severity || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Likelihood:</span><span>${esc(entity?.likelihood || 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Abstraction:</span><span>${esc(entity?.abstraction || 'Standard')}</span></div>
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related Techniques (${entity?.techniques?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.techniques || []).map(t => `
                                <div class="detail-list-item" onclick="selectEntity('attack', '${escAttr(t)}')">
                                    <span class="id attack">${esc(t)}</span>
                                    <span>${esc(state.library.techniques[t]?.name || getTechniqueName(t))}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="detail-section">
                        <h4>Related CWEs (${entity?.cwes?.length || 0})</h4>
                        <div class="detail-list">
                            ${(entity?.cwes || []).slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('cwe', '${escAttr(c)}')">
                                    <span class="id cwe">${esc(c)}</span>
                                    <span>${esc(state.library.cwes[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${(entity?.cwes?.length || 0) > 10 ? `<div class="list-info">+${entity.cwes.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        <a href="https://capec.mitre.org/data/definitions/${esc(id.replace('CAPEC-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--capec-color);">View on MITRE CAPEC â†’</a>
                    </div>
                `;
            } else if (type === 'cwe') {
                entity = state.library.cwes[id];
                name = entity?.name || 'Unknown';
                const relatedCapecs = state.cweToCapec[id] || entity?.capecs || [];

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <details>
                            <summary>Show / hide description</summary>
                            <p>${esc(entity?.description || 'No description available.')}</p>
                        </details>
                    </div>
                    <div class="detail-section">
                        <h4>Abstraction</h4>
                        <p>${esc(entity?.abstraction || 'Base')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Related CAPEC Patterns (${relatedCapecs.length})</h4>
                        <div class="detail-list">
                            ${relatedCapecs.slice(0, 10).map(c => `
                                <div class="detail-list-item" onclick="selectEntity('capec', '${escAttr(c)}')">
                                    <span class="id capec">${esc(c)}</span>
                                    <span>${esc(state.library.capecs[c]?.name || 'Unknown')}</span>
                                </div>
                            `).join('')}
                            ${relatedCapecs.length > 10 ? `<div class="list-info">+${relatedCapecs.length - 10} more</div>` : ''}
                        </div>
                    </div>
                    <div class="detail-section">
                        <a href="https://cwe.mitre.org/data/definitions/${esc(id.replace('CWE-', ''))}.html" target="_blank" rel="noopener noreferrer" style="color: var(--cwe-color);">View on MITRE CWE â†’</a>
                    </div>
                `;
            } else if (type === 'custom') {
                entity = state.library.custom[id];
                name = entity?.name || 'Unknown';
                const stixLabel = (typeof CONFIG !== 'undefined' && CONFIG.stixTypes || []).find(t => t.value === entity?.stixType)?.label || entity?.stixType || 'Unknown';
                const customTypeName = entity?.stixType === 'x-custom' && entity?.customTypeName ? esc(entity.customTypeName) : '';
                const labelsHtml = (entity?.labels || []).map(l => `<span class="entity-badge">${esc(l)}</span>`).join(' ');

                html = `
                    <div class="detail-section">
                        <h4>Description</h4>
                        <p>${esc(entity?.description || 'No description available.')}</p>
                    </div>
                    <div class="detail-section">
                        <h4>Attributes</h4>
                        <div class="detail-list">
                            <div class="detail-list-item"><span>STIX Type:</span><span>${esc(stixLabel)}</span></div>
                            ${customTypeName ? `<div class="detail-list-item"><span>Custom Type:</span><span>${customTypeName}</span></div>` : ''}
                            <div class="detail-list-item"><span>STIX ID:</span><span style="font-family:monospace; font-size:0.7rem; word-break:break-all;">${esc(entity?.id || id)}</span></div>
                            <div class="detail-list-item"><span>Created:</span><span>${esc(entity?.created ? new Date(entity.created).toLocaleDateString() : 'Unknown')}</span></div>
                            <div class="detail-list-item"><span>Modified:</span><span>${esc(entity?.modified ? new Date(entity.modified).toLocaleDateString() : 'Unknown')}</span></div>
                        </div>
                    </div>
                    ${labelsHtml ? `
                    <div class="detail-section">
                        <h4>Labels</h4>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">${labelsHtml}</div>
                    </div>
                    ` : ''}
                    <div class="detail-section">
                        <button class="btn" style="margin-right:8px;" onclick="openStixEditor('${esc(id)}')">Edit Item</button>
                        <button class="btn" style="color: #ef4444; border-color: #ef4444;" onclick="deleteCustomItem('${esc(id)}')">Delete Item</button>
                    </div>
                `;
            }

            return { id, name, html };
        }

        function buildStixPropertySummary(id) {
            const item = state.library.custom[id];
            if (!item) return '';
            const stixType = item.stixType || 'x-custom';
            const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
            if (!typeDef) return '';

            const skipKeys = new Set(['name', 'description', 'labels', 'id', 'stixType', 'customTypeName', 'created', 'modified']);
            const allFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !skipKeys.has(f.key));

            // Collect fields that have values
            const rows = [];
            for (const field of allFields) {
                const val = item[field.key];
                if (val === undefined || val === null || val === '') continue;
                let display;
                if (field.type === 'boolean') {
                    display = val ? 'Yes' : 'No';
                } else if (Array.isArray(val)) {
                    if (val.length === 0) continue;
                    display = val.map(v => typeof v === 'object' ? JSON.stringify(v) : String(v)).join(', ');
                } else if (typeof val === 'object') {
                    display = JSON.stringify(val, null, 2);
                } else {
                    display = String(val);
                }
                rows.push({ label: field.label, value: display });
            }

            if (rows.length === 0) return '';

            return `
                <div class="detail-section">
                    <h4>STIX Properties</h4>
                    <div class="detail-list">
                        ${rows.map(r => `<div class="detail-list-item"><span>${esc(r.label)}:</span><span style="word-break:break-word;">${esc(r.value)}</span></div>`).join('')}
                    </div>
                </div>
            `;
        }

        function buildMetadataSummary(type, id, phaseKey, instanceId) {
            const assignment = phaseKey ? findAssignment(phaseKey, type, id, instanceId) : null;
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            const score = metadata.score || 'unclassified';
            const scoreLabel = SCORE_LEVELS[score]?.label || 'Unclassified';
            const confidence = metadata.confidence ? `${metadata.confidence}% (${getConfidenceLabel(metadata.confidence)})` : 'Unknown';
            const safePhase = phaseKey ? `${phaseKey.split(':')[0]} â€” ${formatPhaseName(phaseKey.split(':')[1])}` : '';
            const cveEntries = getCveEntries(metadata);
            const cveDisplay = cveEntries.length
                ? cveEntries.map(entry => {
                    const parts = [];
                    if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                    if (entry.vector) parts.push(entry.vector);
                    return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                })
                : [];

            const links = (metadata.hyperlinks || []).filter(l => l?.url && /^https?:\/\//i.test(l.url));
            const linksHtml = links.length
                ? links.map(l => `
                    <div class="detail-list-item">
                        <a href="${escAttr(l.url)}" target="_blank" rel="noopener noreferrer" style="color: var(--text-secondary); text-decoration: none;">
                            ${esc(l.label || l.url)} â†’
                        </a>
                    </div>
                `).join('')
                : '<div class="list-info">No hyperlinks</div>';

            const observables = metadata.observables || [];
            const observablesHtml = observables.length
                ? observables.map(o => `
                    <div class="detail-list-item">
                        <span>${esc(o.type)}</span>
                        <span>${esc(o.value)}</span>
                    </div>
                `).join('')
                : '<div class="list-info">No observables</div>';

            return `
                <div class="detail-section">
                    <h4>Metadata</h4>
                    <div class="detail-list">
                        <div class="detail-list-item"><span>Score:</span><span>${esc(scoreLabel)}</span></div>
                        <div class="detail-list-item"><span>Confidence:</span><span>${esc(confidence)}</span></div>
                        ${safePhase ? `<div class="detail-list-item"><span>Phase:</span><span>${esc(safePhase)}</span></div>` : ''}
                        ${cveDisplay.length ? cveDisplay.map(entry => `<div class="detail-list-item"><span>CVE:</span><span>${esc(entry)}</span></div>`).join('') : ''}
                    </div>
                </div>
                ${metadata.comments ? `
                <div class="detail-section">
                    <h4>Comments</h4>
                    <p>${esc(metadata.comments).replace(/\n/g, '<br>')}</p>
                </div>
                ` : ''}
                <div class="detail-section">
                    <h4>Hyperlinks</h4>
                    <div class="detail-list">
                        ${linksHtml}
                    </div>
                </div>
                <div class="detail-section">
                    <h4>Observables</h4>
                    <div class="detail-list">
                        ${observablesHtml}
                    </div>
                </div>
            `;
        }

        function openEntityModal(type, id, phaseKey, instanceId) {
            if (!type || !id) return;
            const detail = buildEntityDetail(type, id);
            document.getElementById('entity-modal-id').textContent = detail.id;
            document.getElementById('entity-modal-name').textContent = detail.name;
            const content = document.getElementById('entity-modal-content');
            // STIX custom objects show their own properties; ATT&CK/CAPEC/CWE show metadata summary
            const supplementary = type === 'custom'
                ? buildStixPropertySummary(id)
                : buildMetadataSummary(type, id, phaseKey, instanceId);
            content.innerHTML = type === 'custom'
                ? detail.html + supplementary
                : supplementary + detail.html;
            document.getElementById('entity-modal').classList.add('visible');
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type, id };
        }

        function closeEntityModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('entity-modal').classList.remove('visible');
        }

        function showDetail(type, id) {
            const panel = document.getElementById('detail-panel');
            const idEl = document.getElementById('detail-id');
            const nameEl = document.getElementById('detail-name');
            const contentEl = document.getElementById('detail-content');
            
            panel.classList.add('visible');
            idEl.className = `detail-id ${type}`;
            
            const detail = buildEntityDetail(type, id);
            idEl.textContent = detail.id;
            nameEl.textContent = detail.name;
            contentEl.innerHTML = detail.html;
            
            // Set current assignment in dropdown
        }

        function closeDetail() {
            document.getElementById('detail-panel').classList.remove('visible');
            state.selection = { type: null, id: null };
            filterEntities(state.activeTab);
        }

        function findEntityPhase(type, id) {
            for (const [phase, data] of Object.entries(state.assignments)) {
                const items = getAllPhaseItemsByType(data, type);
                if (items.some(a => getAssignmentId(a) === id)) return phase;
            }
            return null;
        }

        // ============================================================
        // DRAG & DROP
        // ============================================================
        let dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };

        function handleDragStart(event, type, id) {
            dragData = { kind: 'item', type, id, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);
            
            // Highlight all phases as potential drop targets
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            dragData = { kind: null, type: null, id: null, fromPhase: null, instanceId: null, groupId: null, sourceGroupId: null };
            
            // Remove drop target highlighting
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.remove('drop-target');
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            event.currentTarget.style.background = 'rgba(113, 113, 122, 0.25)';
        }

        function handleDragLeave(event) {
            event.currentTarget.style.background = '';
        }

        function handleDrop(event, phaseKey) {
            event.preventDefault();
            event.currentTarget.style.background = '';
            
            const { kind, type, id, fromPhase, instanceId, groupId, sourceGroupId } = dragData;
            if (!kind) return;

            if (kind === 'group') {
                if (!fromPhase || !groupId) return;
                moveGroupBetweenPhases(fromPhase, phaseKey, groupId);
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                return;
            }
            
            if (!type || !id) return;
            
            const key = TYPE_KEYS[type];
            if (!key) return;
            if (fromPhase && fromPhase === phaseKey && !sourceGroupId) {
                return;
            }

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }
            
            // Add to target phase with metadata (new format)
            if (state.assignments[phaseKey]) {
                const newAssignment = {
                    id: id,
                    metadata: existingMetadata || createDefaultMetadata(),
                    instanceId: instanceId || createAssignmentInstanceId()
                };
                state.assignments[phaseKey][key].push(newAssignment);
                ensurePhaseLayout(phaseKey, state.assignments[phaseKey]);
                showToast(`${id} â†’ ${formatPhaseName(phaseKey.split(':')[1])}`);
            }
            
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        function handleAssignmentDragStart(event, type, id, phaseKey, instanceId, sourceGroupId) {
            dragData = { kind: 'item', type, id, fromPhase: phaseKey, instanceId, groupId: null, sourceGroupId };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDragStart(event, phaseKey, groupId) {
            dragData = { kind: 'group', type: null, id: null, fromPhase: phaseKey, instanceId: null, groupId, sourceGroupId: null };
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `group:${groupId}`);

            document.querySelectorAll('.phase').forEach(p => {
                p.classList.add('drop-target');
            });
        }

        function handleGroupDrop(event, phaseKey, groupId) {
            event.preventDefault();
            event.stopPropagation();
            event.currentTarget.classList.remove('drop-target');
            
            const { kind, type, id, fromPhase, instanceId, sourceGroupId } = dragData;
            if (kind !== 'item' || !type || !id) return;
            if (sourceGroupId && sourceGroupId === groupId) return;

            let existingMetadata = null;
            if (fromPhase && instanceId) {
                const removed = extractAssignmentInstance(fromPhase, type, instanceId);
                if (removed) {
                    existingMetadata = getAssignmentMetadata(removed);
                }
            }

            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            const group = (phaseData.groups || []).find(g => g.groupId === groupId);
            if (!group) return;

            const assignment = {
                id,
                metadata: existingMetadata || createDefaultMetadata(),
                instanceId: instanceId || createAssignmentInstanceId(),
                type
            };
            group.items = group.items || [];
            group.items.push(assignment);
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
        }

        // ============================================================
        // KILL CHAIN RENDERING
        // ============================================================
        function renderKillChain() {
            const container = document.getElementById('kill-chain');
            let html = '';
            
            for (const [superPhaseId, superPhase] of Object.entries(KILL_CHAIN)) {
                html += `
                    <div class="super-phase ${superPhaseId.toLowerCase()}">
                        <div class="super-phase-header">${superPhaseId} - ${superPhase.name}</div>
                        <div class="super-phase-content">
                `;
                
                for (const phaseId of superPhase.phases) {
                    const phaseKey = `${superPhaseId}:${phaseId}`;
                    const phaseData = state.assignments[phaseKey] || { techniques: [], capecs: [], cwes: [], customItems: [], groups: [], layout: [] };
                    
                    const techCount = state.layers.attack ? getAllPhaseItemsByType(phaseData, 'attack').length : 0;
                    const capecCount = state.layers.capec ? getAllPhaseItemsByType(phaseData, 'capec').length : 0;
                    const cweCount = state.layers.cwe ? getAllPhaseItemsByType(phaseData, 'cwe').length : 0;
                    const customCount = state.layers.custom ? getAllPhaseItemsByType(phaseData, 'custom').length : 0;
                    const totalCount = techCount + capecCount + cweCount + customCount;
                    const isHidden = (state.hideEmpty || state.compactMode) && totalCount === 0;
                    
                    ensurePhaseLayout(phaseKey, phaseData);

                    html += `
                        <div class="phase ${totalCount === 0 ? 'empty' : ''} ${isHidden ? 'hidden' : ''}" data-phase="${phaseKey}"
                             ondragover="handleDragOver(event)"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${phaseKey}')">
                            <div class="phase-header" onclick="togglePhase(this)">
                                <div class="phase-title">
                                    <span class="phase-name">${formatPhaseName(phaseId)}</span>
                                    <span class="phase-count ${totalCount === 0 ? 'zero' : ''}">${totalCount}</span>
                                </div>
                                <div class="phase-header-actions">
                                    <button class="phase-group-btn" onclick="event.stopPropagation(); createGroup('${phaseKey}')">+ Group</button>
                                    <span class="phase-toggle">â–¼</span>
                                </div>
                            </div>
                            <div class="phase-content">
                    `;

                    for (const entry of phaseData.layout) {
                        if (entry.kind === 'item') {
                            const list = getPhaseUngroupedItems(phaseData, entry.type);
                            const assignment = list.find(a => getAssignmentInstanceId(a) === entry.instanceId);
                            if (!assignment) continue;
                            const id = getAssignmentId(assignment);
                            const meta = getAssignmentMetadata(assignment);
                            if (state.layers[entry.type]) {
                                html += renderEntityTag(entry.type, id, getEntityName(entry.type, id), meta, phaseKey, getAssignmentInstanceId(assignment), null);
                            }
                        }

                        if (entry.kind === 'group') {
                            const group = (phaseData.groups || []).find(g => g.groupId === entry.groupId);
                            if (!group) continue;
                            const collapsedClass = group.collapsed ? 'collapsed' : '';
                            const groupItems = group.items || [];
                            const safeGroupLabel = esc(group.label || 'Group');
                            const groupHeaderClick = group.editing
                                ? 'event.stopPropagation();'
                                : `toggleGroupCollapse('${phaseKey}', '${group.groupId}')`;
                            const groupDragStart = group.editing
                                ? 'event.preventDefault();'
                                : `handleGroupDragStart(event, '${phaseKey}', '${group.groupId}')`;
                            html += `
                                <div class="phase-group ${collapsedClass}" data-group-id="${escAttr(group.groupId)}" ondragover="event.stopPropagation(); handleDragOver(event)" ondragleave="event.stopPropagation(); handleDragLeave(event)" ondrop="handleGroupDrop(event, '${phaseKey}', '${group.groupId}')">
                                    <div class="phase-group-header" draggable="${group.editing ? 'false' : 'true'}" ondragstart="${groupDragStart}" ondragend="handleDragEnd(event)" onclick="${groupHeaderClick}">
                                        ${group.editing ? `
                                            <input class="metadata-input" id="group-rename-${escAttr(group.groupId)}" value="${safeGroupLabel}"
                                                onclick="event.stopPropagation()" onmousedown="event.stopPropagation()"
                                                onblur="commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value)"
                                                onkeydown="if (event.key === 'Enter') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value); } if (event.key === 'Escape') { event.preventDefault(); commitRenameGroup('${phaseKey}', '${escAttr(group.groupId)}', this.value, true); }" />
                                        ` : `<span class="phase-group-title">${safeGroupLabel}</span>`}
                                        <span class="phase-group-count">${groupItems.length}</span>
                                        <span class="group-header-actions">
                                            <span class="group-actions">
                                                <button class="group-action-btn rename" title="Rename" onclick="event.stopPropagation(); startRenameGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                                                </button>
                                                <button class="group-action-btn delete" title="Delete Group" onclick="event.stopPropagation(); removeGroup('${phaseKey}', '${group.groupId}')">
                                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"></path></svg>
                                                </button>
                                            </span>
                                            <span class="phase-group-toggle">â–¼</span>
                                        </span>
                                    </div>
                                    <div class="phase-group-content">
                                        ${groupItems.map(item => {
                                            const type = item.type;
                                            const id = getAssignmentId(item);
                                            const meta = getAssignmentMetadata(item);
                                            const instanceId = getAssignmentInstanceId(item);
                                            if (state.layers[type]) {
                                                return renderEntityTag(type, id, getEntityName(type, id), meta, phaseKey, instanceId, group.groupId);
                                            }
                                            return '';
                                        }).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    if (totalCount === 0 && !state.compactMode) {
                        html += `<div class="list-info">Empty</div>`;
                    }
                    
                    html += `</div></div>`;
                }
                
                html += `</div></div>`;
            }
            
            container.innerHTML = html;
            renderStats();
            applyCompactLayout();
        }

        // Render a single entity tag with metadata indicators
        function renderEntityTag(type, id, name, metadata, phaseKey, instanceId, sourceGroupId = null) {
            const tagClass = TAG_CLASSES[type] || 'custom-tag';
            const score = metadata.score || 'unclassified';
            const safeId = InputSecurity.escapeHtml(id);
            const displayName = truncateAtBoundary(name || '', 500);
            const safeName = InputSecurity.escapeHtml(displayName || '');
            const safeType = InputSecurity.sanitizeAttr(type, 20);
            const safeIdAttr = InputSecurity.encodeHtmlEntities(id);
            const safePhaseKey = InputSecurity.sanitizeAttr(phaseKey);
            const safeInstanceId = InputSecurity.sanitizeAttr(instanceId || '');
            const safeGroupId = InputSecurity.sanitizeAttr(sourceGroupId || '');
            const isCompact = state.compactMode && state.view === 'killchain';
            const compactTitle = isCompact ? `title="${InputSecurity.encodeHtmlEntities(`${id} â€” ${displayName}`)}"` : '';
            let domainBadge = '';
            if (type === 'attack') {
                const domain = state.library.techniques[id]?.domain || detectDomain(id);
                const label = domain === 'enterprise' ? 'ENT' : domain === 'mobile' ? 'MOB' : domain === 'ics' ? 'ICS' : '';
                if (label) {
                    domainBadge = `<span class="domain-badge">${label}</span>`;
                }
            }
            if (type === 'custom') {
                const stixType = state.library.custom[id]?.stixType || 'x-custom';
                const stixLabel = InputSecurity.escapeHtml(stixType.replace(/-/g, ' '));
                domainBadge = `<span class="stix-type-badge">${stixLabel}</span>`;
            }
            
            // Build metadata icons
            let metaIcons = '';
            const cveEntries = getCveEntries(metadata);
            const cveList = cveEntries.map(entry => entry.id);
            const hasComment = metadata.comments && metadata.comments.trim().length > 0;
            const hasLinks = metadata.hyperlinks && metadata.hyperlinks.length > 0;
            const hasObservables = metadata.observables && metadata.observables.length > 0;
            const hasCve = cveList.length > 0;
            const hasConfidence = metadata.confidence !== null && metadata.confidence !== undefined && metadata.confidence > 0;
            
            if (hasCve || hasObservables || hasLinks || hasComment || hasConfidence) {
                metaIcons = '<div class="metadata-icons">';
                if (hasCve) {
                    const cveLabel = cveList.length === 1 ? cveList[0] : `CVE (${cveList.length})`;
                    const cveTitle = cveEntries.map(entry => {
                        const parts = [];
                        if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                        if (entry.vector) parts.push(entry.vector);
                        return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                    }).join(', ');
                    metaIcons += `<span class="meta-icon has-cve" title="${esc(cveTitle)}">
                    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v7a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-7a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5Zm-3 8V7a3 3 0 1 1 6 0v3H9Zm3 3a2 2 0 0 1 1 3.732V18h-2v-1.268A2 2 0 0 1 12 13Z"/></svg>
                    <span>${esc(cveLabel)}</span>
                </span>`;
                }
                if (hasObservables) metaIcons += '<span class="meta-icon has-observable" title="Has Observables"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5c-4.5 0-8.1 2.6-10 7 1.9 4.4 5.5 7 10 7s8.1-2.6 10-7c-1.9-4.4-5.5-7-10-7Zm0 11a4 4 0 1 1 0-8 4 4 0 0 1 0 8Zm0-6a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"/></svg></span>';
                if (hasLinks) metaIcons += '<span class="meta-icon has-link" title="Has Links"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.6 13.4a1 1 0 0 0 1.4 1.4l3.5-3.5a3 3 0 1 0-4.2-4.2l-1.3 1.3a1 1 0 1 0 1.4 1.4l1.3-1.3a1 1 0 0 1 1.4 1.4l-3.5 3.5Zm2.8-2.8a1 1 0 0 0-1.4-1.4L8.5 12.7a3 3 0 1 0 4.2 4.2l1.3-1.3a1 1 0 1 0-1.4-1.4l-1.3 1.3a1 1 0 0 1-1.4-1.4l3.5-3.5Z"/></svg></span>';
                if (hasComment) metaIcons += '<span class="meta-icon has-comment" title="Has Comments"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H9l-5 4v-4H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Zm3 5h10v2H7V9Zm0-3h10v2H7V6Zm0 6h6v2H7v-2Z"/></svg></span>';
                if (hasConfidence) metaIcons += `<span class="meta-icon has-confidence" title="Confidence: ${metadata.confidence}%"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 12a9 9 0 1 1 9 9 9 9 0 0 1-9-9Zm8-5h2v6h-2V7Zm0 8h2v2h-2v-2Z"/></svg><span>${metadata.confidence}%</span></span>`;
                metaIcons += '</div>';
            }
            
            const tagBody = isCompact ? '' : `
                    <div class="tag-body">
                        <span class="name">${safeName}</span>
                    </div>`;

            const headerMetaIcons = isCompact ? metaIcons : '';
            const footerMetaIcons = isCompact ? '' : metaIcons;
            const exploreBtn = type === 'custom' ? '' : `<button class="tag-action-btn explore" onclick="event.stopPropagation(); openEntityExplorer('${safeType}', '${safeIdAttr}')" title="Explore Entity Relationships">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M256 128C256 110.3 270.3 96 288 96L352 96C369.7 96 384 110.3 384 128L384 192C384 209.7 369.7 224 352 224L344 224L344 288L464 288C503.8 288 536 320.2 536 360L536 416L544 416C561.7 416 576 430.3 576 448L576 512C576 529.7 561.7 544 544 544L480 544C462.3 544 448 529.7 448 512L448 448C448 430.3 462.3 416 480 416L488 416L488 360C488 346.7 477.3 336 464 336L344 336L344 416L352 416C369.7 416 384 430.3 384 448L384 512C384 529.7 369.7 544 352 544L288 544C270.3 544 256 529.7 256 512L256 448C256 430.3 270.3 416 288 416L296 416L296 336L176 336C162.7 336 152 346.7 152 360L152 416L160 416C177.7 416 192 430.3 192 448L192 512C192 529.7 177.7 544 160 544L96 544C78.3 544 64 529.7 64 512L64 448C64 430.3 78.3 416 96 416L104 416L104 360C104 320.2 136.2 288 176 288L296 288L296 224L288 224C270.3 224 256 209.7 256 192L256 128z"/></svg>
                            </button>`;

            const editBtnAction = type === 'custom'
                ? `event.stopPropagation(); closeEntityModal(); openStixEditor('${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')`
                : `event.stopPropagation(); closeEntityModal(); openMetadataEditor('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')`;
            const editBtnTitle = type === 'custom' ? 'Edit STIX Item' : 'Edit Metadata';

            return `
                <div class="${tagClass}" data-score="${score}" ${compactTitle}
                     draggable="true"
                     ondragstart="handleAssignmentDragStart(event, '${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}', '${safeGroupId}')"
                     ondragend="handleDragEnd(event)"
                     onclick="openEntityModal('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                    <span class="tag-header-row">
                        <span class="id" onclick="event.stopPropagation(); selectEntity('${safeType}', '${safeIdAttr}')">${safeId}</span>
                        ${domainBadge}
                        ${headerMetaIcons}
                        
                        <span class="tag-actions">
                            <span class="tag-action-btn remove" title="Remove" onclick="event.stopPropagation(); removeAssignment('${safeType}', '${safeIdAttr}', '${safePhaseKey}', '${safeInstanceId}')">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.--><path d="M576 192C576 156.7 547.3 128 512 128L205.3 128C188.3 128 172 134.7 160 146.7L9.4 297.4C3.4 303.4 0 311.5 0 320C0 328.5 3.4 336.6 9.4 342.6L160 493.3C172 505.3 188.3 512 205.3 512L512 512C547.3 512 576 483.3 576 448L576 192zM284.1 252.1C293.5 242.7 308.7 242.7 318 252.1L351.9 286L385.8 252.1C395.2 242.7 410.4 242.7 419.7 252.1C429 261.5 429.1 276.7 419.7 286L385.8 319.9L419.7 353.8C429.1 363.2 429.1 378.4 419.7 387.7C410.3 397 395.1 397.1 385.8 387.7L351.9 353.8L318 387.7C308.6 397.1 293.4 397.1 284.1 387.7C274.8 378.3 274.7 363.1 284.1 353.8L318 319.9L284.1 286C274.7 276.6 274.7 261.4 284.1 252.1z"/></svg>
                            </span>
                            ${exploreBtn}
                            <button class="tag-action-btn edit" onclick="${editBtnAction}" title="${editBtnTitle}">
                                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 17.25V21h3.75L17.8 9.95l-3.75-3.75L3 17.25Zm2.92 2.83H5v-.92l8.79-8.79.92.92-8.79 8.79ZM20.7 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
                            </button>
                        </span>
                    </span>
                    ${tagBody}
                    <div class="tag-footer">
                        ${footerMetaIcons}
                    </div>
                </div>
            `;
        }

        // ============================================================
        // RELATIONSHIP VIEW RENDERING
        // ============================================================
        function renderRelationshipView() {
            const container = document.getElementById('relationship-chain');
            
            // Build relationship chains from assigned CAPECs
            const chains = [];
            
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                // For each assigned CAPEC
                const capecAssignments = getAllPhaseItemsByType(phaseData, 'capec');
                for (const capecAssignment of capecAssignments) {
                    const capecId = getAssignmentId(capecAssignment);
                    const capec = state.library.capecs[capecId];
                    if (!capec) continue;
                    
                    // Get CWEs related to this CAPEC
                    const relatedCwes = capec.cwes || [];
                    
                    // Get techniques related to this CAPEC that are in this phase
                    const assignedTechIds = getAllPhaseItemsByType(phaseData, 'attack').map(t => getAssignmentId(t));
                    const relatedTechs = (capec.techniques || []).filter(t => 
                        assignedTechIds.includes(t) || state.library.techniques[t]
                    );
                    
                    chains.push({
                        capec: { id: capecId, name: capec.name },
                        cwes: relatedCwes.slice(0, 5).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })),
                        techniques: relatedTechs.slice(0, 5).map(id => ({ id, name: state.library.techniques[id]?.name || getTechniqueName(id) })),
                        phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                    });
                }
                
                // For assigned techniques without CAPEC, create partial chains
                const assignedCapecIds = getAllPhaseItemsByType(phaseData, 'capec').map(c => getAssignmentId(c));
                const techAssignments = getAllPhaseItemsByType(phaseData, 'attack');
                for (const techAssignment of techAssignments) {
                    const techId = getAssignmentId(techAssignment);
                    const relatedCapecs = state.techniqueToCapec[techId] || [];
                    // Only show if technique has no assigned CAPEC in this phase
                    const hasCapecInPhase = relatedCapecs.some(c => assignedCapecIds.includes(c));
                    if (!hasCapecInPhase && relatedCapecs.length > 0) {
                        const capecId = relatedCapecs[0];
                        const capec = state.library.capecs[capecId];
                        chains.push({
                            capec: capec ? { id: capecId, name: capec.name } : null,
                            cwes: capec?.cwes?.slice(0, 3).map(id => ({ id, name: state.library.cwes[id]?.name || 'Unknown' })) || [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                        });
                    } else if (relatedCapecs.length === 0) {
                        // Technique with no CAPEC
                        chains.push({
                            capec: null,
                            cwes: [],
                            techniques: [{ id: techId, name: state.library.techniques[techId]?.name || getTechniqueName(techId) }],
                            phase: { key: phaseKey, name: formatPhaseName(phaseKey.split(':')[1]) }
                        });
                    }
                }
            }
            
            if (chains.length === 0) {
                container.innerHTML = `<div class="relationship-empty">No relationships to display.<br>Assign techniques, CAPECs, or CWEs to phases first.</div>`;
                return;
            }
            
            let html = '';
            for (const chain of chains) {
                html += `
                    <div class="relationship-row">
                        <div class="relationship-cell capec">
                            <div class="relationship-cell-header">CAPEC</div>
                            ${chain.capec ? `
                                <div class="relationship-item" onclick="selectEntity('capec', '${escAttr(chain.capec.id)}')">
                                    <span class="id capec">${esc(chain.capec.id)}</span>
                                    <span class="name">${esc(chain.capec.name)}</span>
                                </div>
                            ` : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell cwe">
                            <div class="relationship-cell-header">CWE</div>
                            ${chain.cwes.length > 0 ? chain.cwes.map(cwe => `
                                <div class="relationship-item" onclick="selectEntity('cwe', '${escAttr(cwe.id)}')">
                                    <span class="id cwe">${esc(cwe.id)}</span>
                                    <span class="name">${esc(cwe.name)}</span>
                                </div>
                            `).join('') : '<div class="list-info">â€”</div>'}
                        </div>
                        <div class="relationship-cell attack">
                            <div class="relationship-cell-header">ATT&CK</div>
                            ${chain.techniques.map(tech => `
                                <div class="relationship-item" onclick="selectEntity('attack', '${escAttr(tech.id)}')">
                                    <span class="id attack">${esc(tech.id)}</span>
                                    <span class="name">${esc(tech.name)}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="relationship-cell phase">
                            <div class="relationship-cell-header">Phase</div>
                            <div class="relationship-item">
                                <span class="id phase">${esc(chain.phase.key.split(':')[0])}</span>
                                <span class="name">${esc(chain.phase.name)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function renderStats() {
            const statsEl = document.getElementById('stats-bar');
            
            let phasesUsed = 0;
            const techSet = new Set(), capecSet = new Set(), cweSet = new Set(), customSet = new Set();
            
            for (const phase of Object.values(state.assignments)) {
                const allTechs = getAllPhaseItemsByType(phase, 'attack');
                const allCapecs = getAllPhaseItemsByType(phase, 'capec');
                const allCwes = getAllPhaseItemsByType(phase, 'cwe');
                const allCustom = getAllPhaseItemsByType(phase, 'custom');
                if (allTechs.length + allCapecs.length + allCwes.length + allCustom.length > 0) phasesUsed++;
                allTechs.forEach(t => techSet.add(getAssignmentId(t)));
                allCapecs.forEach(c => capecSet.add(getAssignmentId(c)));
                allCwes.forEach(w => cweSet.add(getAssignmentId(w)));
                allCustom.forEach(x => customSet.add(getAssignmentId(x)));
            }
            
            const customStat = customSet.size > 0 ? `<div class="stat"><div class="stat-value">${customSet.size}</div><div class="stat-label">STIX Objects</div></div>` : '';
            statsEl.innerHTML = `
                <div class="stat"><div class="stat-value">${techSet.size}</div><div class="stat-label">Techniques</div></div>
                <div class="stat"><div class="stat-value">${capecSet.size}</div><div class="stat-label">CAPECs</div></div>
                <div class="stat"><div class="stat-value">${cweSet.size}</div><div class="stat-label">CWEs</div></div>
                ${customStat}
                <div class="stat"><div class="stat-value">${phasesUsed}/18</div><div class="stat-label">Phases</div></div>
            `;
        }

        function togglePhase(header) {
            header.parentElement.classList.toggle('minimized');
        }

        function removeAssignment(type, id, phaseKey, instanceId) {
            const key = TYPE_KEYS[type];
            if (!key) return;
            const phaseData = state.assignments[phaseKey];
            if (!phaseData) return;
            if (!window.confirm('Remove this item?')) return;
            const assignments = phaseData[key];
            const idx = instanceId
                ? assignments.findIndex(a => getAssignmentInstanceId(a) === instanceId)
                : assignments.findIndex(a => getAssignmentId(a) === id);
            if (idx !== -1) {
                assignments.splice(idx, 1);
                phaseData.layout = phaseData.layout.filter(entry => !(entry.kind === 'item' && entry.instanceId === instanceId));
                renderKillChain();
                filterEntities(state.activeTab);
                if (state.view === 'relationship') {
                    renderRelationshipView();
                }
                showToast('Item removed.');
                return;
            }

            for (const group of phaseData.groups || []) {
                const gIdx = (group.items || []).findIndex(item => getAssignmentInstanceId(item) === instanceId);
                if (gIdx !== -1) {
                    group.items.splice(gIdx, 1);
                    renderKillChain();
                    filterEntities(state.activeTab);
                    if (state.view === 'relationship') {
                        renderRelationshipView();
                    }
                    showToast('Item removed.');
                    return;
                }
            }
        }

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        function expandAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('minimized'));
        }

        function collapseAll() {
            document.querySelectorAll('.phase').forEach(p => p.classList.add('minimized'));
        }

        function clearAssignments() {
            if (!confirm('Clear all assignments from the kill chain? This cannot be undone.')) return;
            initAssignments();
            renderKillChain();
            filterEntities(state.activeTab);
            if (state.view === 'relationship') {
                renderRelationshipView();
            }
            showToast('Cleared all assignments');
        }

        function exportJSON() {
            const exportData = {
                version: APP_VERSION,
                schema: 'killchain-export-lite',
                exportedAt: new Date().toISOString(),
                title: state.title || '',
                description: state.description || '',
                view: state.view,
                activeTab: state.activeTab,
                filters: state.filters,
                layers: state.layers,
                hideEmpty: state.hideEmpty,
                assignments: state.assignments,
                selection: state.selection,
                customLibrary: state.library.custom
            };

            // Generate embedded STIX bundle if custom items exist
            const customIds = Object.keys(state.library.custom);
            if (customIds.length > 0) {
                exportData.stixBundle = buildSTIXBundle();
            }
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const slug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'attack-chain-export';
            a.download = slug + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported JSON');
        }

        // Build STIX 2.1 bundle from custom items + phase relationships
        function buildSTIXBundle() {
            const objects = [];
            const now = new Date().toISOString();

            // Add SDOs from custom library
            for (const [id, item] of Object.entries(state.library.custom)) {
                const sdo = {
                    type: item.stixType,
                    spec_version: '2.1',
                    id: id,
                    created: item.created || now,
                    modified: item.modified || now,
                    name: item.name || ''
                };
                if (item.description) sdo.description = item.description;
                if (item.labels && item.labels.length > 0) sdo.labels = item.labels;
                objects.push(sdo);
            }

            // Generate SROs for co-located items in same phase/group
            const relationshipSet = new Set();
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;

                // Ungrouped custom items in this phase
                const ungroupedCustom = (phaseData.customItems || []).map(a => getAssignmentId(a));
                // All other ungrouped items
                const ungroupedOther = [
                    ...(phaseData.techniques || []).map(a => ({ type: 'attack', id: getAssignmentId(a) })),
                    ...(phaseData.capecs || []).map(a => ({ type: 'capec', id: getAssignmentId(a) })),
                    ...(phaseData.cwes || []).map(a => ({ type: 'cwe', id: getAssignmentId(a) }))
                ];

                // Build phase-level relationships between customâ†”custom
                for (let i = 0; i < ungroupedCustom.length; i++) {
                    for (let j = i + 1; j < ungroupedCustom.length; j++) {
                        addRelationship(objects, relationshipSet, ungroupedCustom[i], ungroupedCustom[j], phaseKey, now);
                    }
                }

                // Grouped items
                for (const group of (phaseData.groups || [])) {
                    const groupCustom = (group.items || []).filter(it => it.type === 'custom').map(it => getAssignmentId(it));
                    const groupOther = (group.items || []).filter(it => it.type !== 'custom');

                    // Customâ†”custom within group
                    for (let i = 0; i < groupCustom.length; i++) {
                        for (let j = i + 1; j < groupCustom.length; j++) {
                            addRelationship(objects, relationshipSet, groupCustom[i], groupCustom[j], phaseKey, now);
                        }
                    }
                }
            }

            // Add attack-pattern SDOs for assigned techniques (deterministic IDs)
            const techniquePhases = new Map(); // techId â†’ Set of phase names
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;
                const techs = getAllPhaseItemsByType(phaseData, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    if (!techniquePhases.has(techId)) techniquePhases.set(techId, new Set());
                    techniquePhases.get(techId).add(phaseKey.split(':')[1]);
                }
            }
            for (const [techId, phases] of techniquePhases) {
                const entity = state.library.techniques[techId];
                objects.push({
                    type: 'attack-pattern',
                    spec_version: '2.1',
                    id: techniqueStixId(techId),
                    created: now,
                    modified: now,
                    name: entity?.name || techId,
                    ...(entity?.description ? { description: entity.description } : {}),
                    external_references: [{
                        source_name: 'mitre-attack',
                        external_id: techId,
                        url: `https://attack.mitre.org/techniques/${techId.replace('.', '/')}`
                    }],
                    kill_chain_phases: [...phases].map(p => ({
                        kill_chain_name: 'unified-kill-chain',
                        phase_name: p
                    }))
                });
            }

            // Add course-of-action SDOs from mitigations linked to assigned techniques
            const mitigationMap = new Map();
            const techMitLinks = new Map();
            for (const [phaseKey, phaseData] of Object.entries(state.assignments)) {
                if (!phaseData) continue;
                const techs = getAllPhaseItemsByType(phaseData, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    const entity = state.library.techniques[techId];
                    if (!entity?.mitigations) continue;
                    const techSid = techniqueStixId(techId);
                    for (const m of entity.mitigations) {
                        if (!mitigationMap.has(m.id)) mitigationMap.set(m.id, m);
                        if (!techMitLinks.has(techSid)) techMitLinks.set(techSid, new Set());
                        techMitLinks.get(techSid).add(mitigationStixId(m.id));
                    }
                }
            }

            for (const [mitreId, m] of mitigationMap) {
                objects.push({
                    type: 'course-of-action',
                    spec_version: '2.1',
                    id: mitigationStixId(mitreId),
                    created: now,
                    modified: now,
                    name: m.name,
                    ...(m.description ? { description: m.description } : {}),
                    external_references: [{
                        source_name: 'mitre-attack',
                        external_id: mitreId,
                        url: `https://attack.mitre.org/mitigations/${mitreId}`
                    }]
                });
            }

            // Emit mitigates SROs
            for (const [techSid, mitSids] of techMitLinks) {
                for (const mitSid of mitSids) {
                    const key = `${mitSid}|${techSid}|mitigates`;
                    if (relationshipSet.has(key)) continue;
                    relationshipSet.add(key);
                    objects.push({
                        type: 'relationship',
                        spec_version: '2.1',
                        id: `relationship--${generateUUID()}`,
                        created: now,
                        modified: now,
                        relationship_type: 'mitigates',
                        source_ref: mitSid,
                        target_ref: techSid
                    });
                }
            }

            return {
                type: 'bundle',
                id: `bundle--${generateUUID()}`,
                spec_version: '2.1',
                objects: objects
            };
        }

        function addRelationship(objects, seen, sourceId, targetId, phaseKey, timestamp) {
            const sourceType = sourceId.split('--')[0] || '';
            const targetType = targetId.split('--')[0] || '';
            if (!sourceType || !targetType) return;

            // Look up relationship type from STIX_RELATIONSHIP_MAP
            const relType = STIX_RELATIONSHIP_MAP[sourceType]?.[targetType] || 'related-to';
            const key = `${sourceId}|${targetId}|${relType}`;
            const reverseKey = `${targetId}|${sourceId}|${relType}`;
            if (seen.has(key) || seen.has(reverseKey)) return;
            seen.add(key);

            objects.push({
                type: 'relationship',
                spec_version: '2.1',
                id: `relationship--${generateUUID()}`,
                created: timestamp,
                modified: timestamp,
                relationship_type: relType,
                source_ref: sourceId,
                target_ref: targetId,
                description: `Co-located in phase ${phaseKey}`
            });
        }

        function exportSTIXBundle() {
            const hasCustom = Object.keys(state.library.custom).length > 0;
            const hasAssignments = Object.values(state.assignments).some(phase =>
                getAllPhaseItemsByType(phase, 'attack').length > 0
            );
            if (!hasCustom && !hasAssignments) {
                showToast('No STIX objects to export');
                return;
            }
            const bundle = buildSTIXBundle();
            const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const slug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'stix-bundle';
            a.download = slug + '-stix-bundle.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported STIX 2.1 Bundle');
        }

        function triggerImportKillChain() {
            const input = document.getElementById('import-killchain-input');
            if (input) input.click();
        }

        function ensureAssignmentShape(assignments) {
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseData) continue;
                phaseData.groups = Array.isArray(phaseData.groups) ? phaseData.groups : [];
                phaseData.layout = Array.isArray(phaseData.layout) ? phaseData.layout : [];

                for (const key of ['techniques', 'capecs', 'cwes', 'customItems']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    phaseData[key] = list.map(a => migrateAssignment(a));
                }

                phaseData.groups = phaseData.groups.map(group => {
                    const items = Array.isArray(group.items) ? group.items : [];
                    return {
                        groupId: group.groupId || generateGroupId(),
                        label: sanitizeImportedString(group.label || 'Group', 80),
                        collapsed: !!group.collapsed,
                        items: items.map(item => ({
                            ...migrateAssignment(item),
                            type: item.type || 'attack'
                        }))
                    };
                });

                ensurePhaseLayout(phaseKey, phaseData);
                assignments[phaseKey] = phaseData;
            }
        }

        function ensureLibraryFallbacks(assignments) {
            for (const phaseData of Object.values(assignments)) {
                const allTechs = getAllPhaseItemsByType(phaseData, 'attack');
                const allCapecs = getAllPhaseItemsByType(phaseData, 'capec');
                const allCwes = getAllPhaseItemsByType(phaseData, 'cwe');

                for (const tech of allTechs) {
                    const id = getAssignmentId(tech);
                    if (!state.library.techniques[id]) {
                        state.library.techniques[id] = {
                            id,
                            name: getTechniqueName(id),
                            domain: detectDomain(id)
                        };
                    }
                }
                for (const capec of allCapecs) {
                    const id = getAssignmentId(capec);
                    if (!state.library.capecs[id]) {
                        state.library.capecs[id] = { id, name: id };
                    }
                }
                for (const cwe of allCwes) {
                    const id = getAssignmentId(cwe);
                    if (!state.library.cwes[id]) {
                        state.library.cwes[id] = { id, name: id };
                    }
                }
                const allCustom = getAllPhaseItemsByType(phaseData, 'custom');
                for (const custom of allCustom) {
                    const id = getAssignmentId(custom);
                    if (!state.library.custom[id]) {
                        state.library.custom[id] = {
                            id,
                            stixType: id.split('--')[0] || 'x-custom',
                            name: id,
                            description: '',
                            labels: [],
                            created: new Date().toISOString(),
                            modified: new Date().toISOString()
                        };
                    }
                }
            }
        }

        // Validation and sanitization for imported kill chain data
        const KILLCHAIN_IMPORT_LIMITS = {
            maxFileSize: 5 * 1024 * 1024,  // 5 MB
            maxAssignmentsPerPhase: 500,
            maxHyperlinks: 50,
            maxObservables: 100,
            maxStringLength: 5000
        };

        function validateKillChainImport(data) {
            if (!data || typeof data !== 'object') {
                return { valid: false, error: 'Invalid export format: expected object' };
            }

            const assignments = data.assignments;
            if (!assignments || typeof assignments !== 'object') {
                return { valid: false, error: 'Missing or invalid assignments object' };
            }

            // Validate schema version if present
            if (data.schemaVersion && !/^\d+\.\d+(\.\d+)?$/.test(data.schemaVersion)) {
                return { valid: false, error: 'Invalid schema version format' };
            }

            // Validate phase keys and structure
            for (const [phaseKey, phaseData] of Object.entries(assignments)) {
                if (!phaseKey.includes(':')) {
                    return { valid: false, error: `Invalid phase key format: ${phaseKey}` };
                }
                if (!phaseData || typeof phaseData !== 'object') {
                    return { valid: false, error: `Invalid phase data for: ${phaseKey}` };
                }

                // Check assignment counts
                for (const key of ['techniques', 'capecs', 'cwes', 'customItems']) {
                    const list = phaseData[key];
                    if (list && !Array.isArray(list)) {
                        return { valid: false, error: `${key} must be an array in ${phaseKey}` };
                    }
                    if (list && list.length > KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase) {
                        return { valid: false, error: `Too many ${key} in ${phaseKey} (max ${KILLCHAIN_IMPORT_LIMITS.maxAssignmentsPerPhase})` };
                    }
                }

                if (phaseData.groups && !Array.isArray(phaseData.groups)) {
                    return { valid: false, error: `groups must be an array in ${phaseKey}` };
                }
            }

            // Validate optional title
            if (data.title !== undefined && data.title !== null) {
                if (typeof data.title !== 'string') {
                    return { valid: false, error: 'title must be a string' };
                }
                if (data.title.length > (CONFIG.display?.maxTitleLength || 200)) {
                    return { valid: false, error: 'title is too long' };
                }
            }

            return { valid: true };
        }

        function sanitizeImportedString(str, maxLength = KILLCHAIN_IMPORT_LIMITS.maxStringLength) {
            if (str === null || str === undefined) return '';
            if (typeof str !== 'string') return '';
            // Normalize, remove dangerous chars, limit length
            return String(str)
                .replace(/[\x00-\x1F\x7F]/g, '')  // Control chars
                .replace(/<script[^>]*>.*?<\/script>/gi, '')  // Script tags
                .replace(/on\w+\s*=/gi, '')  // Event handlers (onmouseover=, onerror=, etc.)
                .replace(/[\[\]\{\};"'`]/g, '')  // Blocked chars including double quotes
                .replace(/--+/g, '')  // SQL comments
                .replace(/</g, '&lt;').replace(/>/g, '&gt;')  // Encode angle brackets
                .trim()
                .slice(0, maxLength);
        }

        function sanitizeImportedAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') return null;

            // ID validation - must match expected patterns
            const id = assignment.id || assignment.entityId;
            if (typeof id !== 'string') return null;
            
            // Validate ID format (T1234, T1234.001, CAPEC-123, CWE-123)
            if (!/^(T\d{4}(\.\d{3})?|CAPEC-\d+|CWE-\d+)$/.test(id)) {
                return null;  // Reject invalid ID patterns
            }

            // Extract metadata
            const metadata = sanitizeAssignmentMetadata(assignment);

            return { id: id, metadata: metadata, instanceId: assignment.instanceId || createAssignmentInstanceId() };
        }

        function sanitizeImportedCustomAssignment(assignment) {
            if (!assignment || typeof assignment !== 'object') return null;

            const id = assignment.id || assignment.entityId;
            if (typeof id !== 'string') return null;

            // Validate STIX ID format: {type}--{uuid}
            if (!STIX_ID_PATTERN.test(id)) return null;

            // Extract and validate STIX type from ID
            const stixType = id.split('--')[0];
            if (!VALID_STIX_TYPES.has(stixType)) return null;

            // Extract metadata
            const metadata = sanitizeAssignmentMetadata(assignment);

            return { id: id, metadata: metadata, instanceId: assignment.instanceId || createAssignmentInstanceId() };
        }

        function sanitizeAssignmentMetadata(assignment) {
            const sourceMeta = assignment.metadata || assignment;
            const metadata = {
                score: 'unclassified',
                confidence: null,
                comments: '',
                cveEntries: [],
                cveId: '',
                cveIds: [],
                hyperlinks: [],
                observables: []
            };

            // Sanitize score - must be valid enum
            const validScores = ['unclassified', 'low', 'medium', 'high', 'critical'];
            if (sourceMeta.score && validScores.includes(sourceMeta.score)) {
                metadata.score = sourceMeta.score;
            }

            // Sanitize confidence - must be number 0-100
            if (typeof sourceMeta.confidence === 'number') {
                metadata.confidence = Math.max(0, Math.min(100, Math.floor(sourceMeta.confidence)));
            }

            // Sanitize CVE entries (handle cveEntries, cveIds, legacy cveId/cve + cvssVector)
            const cveEntries = [];
            if (Array.isArray(sourceMeta.cveEntries)) {
                sourceMeta.cveEntries.forEach(entry => {
                    if (!entry || typeof entry !== 'object') return;
                    const id = typeof entry.id === 'string' ? entry.id.trim().toUpperCase() : '';
                    if (!/^CVE-\d{4}-\d{4,}$/.test(id)) return;
                    let score = null;
                    if (entry.score !== null && entry.score !== undefined && entry.score !== '') {
                        const scoreValue = parseFloat(entry.score);
                        if (Number.isFinite(scoreValue) && scoreValue >= 0 && scoreValue <= 10) {
                            score = Math.round(scoreValue * 10) / 10;
                        }
                    }
                    let vector = '';
                    const vectorRaw = typeof entry.vector === 'string' ? entry.vector : (typeof entry.cvssVector === 'string' ? entry.cvssVector : '');
                    if (vectorRaw) {
                        const cvss = vectorRaw.trim();
                        if (/^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(cvss)) {
                            vector = cvss;
                        }
                    }
                    cveEntries.push({ id, score, vector });
                });
            }

            const cveValues = [];
            if (Array.isArray(sourceMeta.cveIds)) {
                cveValues.push(...sourceMeta.cveIds);
            } else if (typeof sourceMeta.cveIds === 'string') {
                cveValues.push(...sourceMeta.cveIds.split(/[\s,]+/));
            }
            const cveSource = sourceMeta.cveId || sourceMeta.cve;
            if (cveSource && typeof cveSource === 'string') {
                cveValues.push(cveSource);
            }

            const cvssSource = sourceMeta.cvssVector || sourceMeta.cvss;
            const legacyVector = (typeof cvssSource === 'string' && /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]/.test(cvssSource.trim()))
                ? cvssSource.trim()
                : '';

            const normalizedCves = [...new Set(
                cveValues
                    .map(value => (value || '').trim().toUpperCase())
                    .filter(value => /^CVE-\d{4}-\d{4,}$/.test(value))
            )];

            normalizedCves.forEach(id => {
                if (!cveEntries.some(entry => entry.id === id)) {
                    cveEntries.push({ id, score: null, vector: legacyVector });
                }
            });

            metadata.cveEntries = cveEntries;
            metadata.cveIds = cveEntries.map(entry => entry.id);
            metadata.cveId = metadata.cveIds[0] || '';

            // Sanitize comments
            if (sourceMeta.comments) {
                metadata.comments = sanitizeImportedString(sourceMeta.comments, 2000);
            }

            // Sanitize hyperlinks array
            if (Array.isArray(sourceMeta.hyperlinks)) {
                metadata.hyperlinks = sourceMeta.hyperlinks
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxHyperlinks)
                    .filter(h => h && typeof h === 'object')
                    .map(h => ({
                        label: sanitizeImportedString(h.label || '', 200),
                        url: (typeof h.url === 'string' && /^https?:\/\//.test(h.url)) 
                            ? sanitizeImportedString(h.url, 2000) 
                            : ''
                    }))
                    .filter(h => h.url);  // Keep only valid URLs
            }

            // Sanitize observables array
            if (Array.isArray(sourceMeta.observables)) {
                const validTypes = ['ipv4-addr', 'ipv6-addr', 'domain-name', 'url', 'file-hash-md5', 
                    'file-hash-sha1', 'file-hash-sha256', 'file-name', 'email-addr', 'threat-actor', 'other'];
                metadata.observables = sourceMeta.observables
                    .slice(0, KILLCHAIN_IMPORT_LIMITS.maxObservables)
                    .filter(o => o && typeof o === 'object' && validTypes.includes(o.type))
                    .map(o => ({
                        type: o.type,
                        value: sanitizeImportedString(o.value || '', 500)
                    }))
                    .filter(o => o.value);
            }

            return metadata;
        }

        function sanitizeImportedData(data) {
            const sanitized = {
                assignments: {}
            };

            // Sanitize assignments
            for (const [phaseKey, phaseData] of Object.entries(data.assignments || {})) {
                sanitized.assignments[phaseKey] = {
                    techniques: [],
                    capecs: [],
                    cwes: [],
                    customItems: [],
                    groups: [],
                    layout: Array.isArray(phaseData.layout) ? phaseData.layout : []
                };

                for (const key of ['techniques', 'capecs', 'cwes']) {
                    const list = Array.isArray(phaseData[key]) ? phaseData[key] : [];
                    sanitized.assignments[phaseKey][key] = list
                        .map(a => sanitizeImportedAssignment(a))
                        .filter(a => a !== null);
                }

                // Sanitize custom items separately (STIX ID format)
                if (Array.isArray(phaseData.customItems)) {
                    sanitized.assignments[phaseKey].customItems = phaseData.customItems
                        .map(a => sanitizeImportedCustomAssignment(a))
                        .filter(a => a !== null);
                }

                if (Array.isArray(phaseData.groups)) {
                    sanitized.assignments[phaseKey].groups = phaseData.groups
                        .filter(g => g && typeof g === 'object')
                        .map(g => {
                            const rawItems = Array.isArray(g.items) ? g.items : [];
                            const items = rawItems
                                .map(item => {
                                    if (item.type === 'custom') {
                                        const sanitizedItem = sanitizeImportedCustomAssignment(item);
                                        if (!sanitizedItem) return null;
                                        return { ...sanitizedItem, type: 'custom' };
                                    }
                                    const sanitizedItem = sanitizeImportedAssignment(item);
                                    if (!sanitizedItem) return null;
                                    const type = ['attack', 'capec', 'cwe'].includes(item.type) ? item.type : null;
                                    if (!type) return null;
                                    return { ...sanitizedItem, type };
                                })
                                .filter(item => item && item.id && item.type);

                            return {
                                groupId: typeof g.groupId === 'string' ? g.groupId : generateGroupId(),
                                label: sanitizeImportedString(g.label || 'Group', 80),
                                collapsed: !!g.collapsed,
                                items
                            };
                        });
                }
            }

            // Sanitize optional view state (booleans/strings only)
            if (data.layers && typeof data.layers === 'object') {
                sanitized.layers = {
                    attack: !!data.layers.attack,
                    capec: !!data.layers.capec,
                    cwe: !!data.layers.cwe,
                    custom: !!data.layers.custom
                };
            }

            if (typeof data.hideEmpty === 'boolean') {
                sanitized.hideEmpty = data.hideEmpty;
            }

            if (typeof data.view === 'string' && ['killchain', 'relations'].includes(data.view)) {
                sanitized.view = data.view;
            }

            if (typeof data.activeTab === 'string' && ['attack', 'capec', 'cwe', 'custom'].includes(data.activeTab)) {
                sanitized.activeTab = data.activeTab;
            }

            // Sanitize optional title
            if (typeof data.title === 'string') {
                sanitized.title = sanitizeImportedString(data.title, CONFIG.display?.maxTitleLength || 200);
            }

            // Sanitize optional description
            if (typeof data.description === 'string') {
                sanitized.description = sanitizeImportedString(data.description, CONFIG.display?.maxKillChainDescLength || 2000);
            }

            // Sanitize custom library
            if (data.customLibrary && typeof data.customLibrary === 'object') {
                sanitized.customLibrary = {};
                const maxItems = 500;
                let count = 0;
                for (const [id, item] of Object.entries(data.customLibrary)) {
                    if (count >= maxItems) break;
                    if (!STIX_ID_PATTERN.test(id)) continue;
                    if (!item || typeof item !== 'object') continue;
                    const stixType = id.split('--')[0];
                    if (!VALID_STIX_TYPES.has(stixType)) continue;

                    const entry = {
                        id: id,
                        stixType: stixType,
                        name: sanitizeImportedString(item.name || '', CONFIG.display?.maxLabelLength || 50),
                        description: sanitizeImportedString(item.description || '', CONFIG.display?.maxCustomDescLength || 2000),
                        labels: Array.isArray(item.labels)
                            ? item.labels
                                .slice(0, CONFIG.display?.maxCustomLabels || 20)
                                .filter(l => typeof l === 'string')
                                .map(l => sanitizeImportedString(l, CONFIG.display?.maxLabelLength || 50))
                            : [],
                        customTypeName: stixType === 'x-custom' && typeof item.customTypeName === 'string'
                            ? sanitizeImportedString(item.customTypeName, CONFIG.display?.maxLabelLength || 50)
                            : '',
                        created: typeof item.created === 'string' ? item.created.slice(0, 30) : new Date().toISOString(),
                        modified: typeof item.modified === 'string' ? item.modified.slice(0, 30) : new Date().toISOString()
                    };

                    // Preserve STIX spec-defined properties from stix-config.js
                    const typeDef = (typeof STIX_OBJECTS !== 'undefined') ? STIX_OBJECTS[stixType] : null;
                    if (typeDef) {
                        const coreKeys = new Set(['name', 'description', 'labels']);
                        const specFields = [...(typeDef.required || []), ...(typeDef.optional || [])].filter(f => !coreKeys.has(f.key));
                        for (const field of specFields) {
                            if (!(field.key in item)) continue;
                            const raw = item[field.key];
                            if (field.type === 'boolean') {
                                entry[field.key] = !!raw;
                            } else if (field.type === 'integer') {
                                const num = parseInt(raw, 10);
                                if (!isNaN(num)) entry[field.key] = num;
                            } else if (field.type === 'list' || field.type === 'list:open-vocab') {
                                if (Array.isArray(raw)) {
                                    entry[field.key] = raw
                                        .slice(0, 50)
                                        .filter(v => typeof v === 'string')
                                        .map(v => sanitizeImportedString(v, 200));
                                }
                            } else {
                                // string, enum, open-vocab, timestamp
                                if (typeof raw === 'string') {
                                    entry[field.key] = sanitizeImportedString(raw, 2000);
                                }
                            }
                        }
                    }

                    sanitized.customLibrary[id] = entry;
                    count++;
                }
            }

            return sanitized;
        }

        function importKillChain(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check file size
            if (file.size > KILLCHAIN_IMPORT_LIMITS.maxFileSize) {
                showToast(`File too large (max ${KILLCHAIN_IMPORT_LIMITS.maxFileSize / 1024 / 1024} MB)`);
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = JSON.parse(e.target.result);
                    const data = stripAngleBracketsFromJson(rawData);

                    // Validate structure before processing
                    const validation = validateKillChainImport(data);
                    if (!validation.valid) {
                        throw new Error(validation.error);
                    }

                    // Sanitize all imported data
                    const sanitized = sanitizeImportedData(data);

                    // Reset assignments and load sanitized state
                    initAssignments();
                    for (const [phaseKey, phaseData] of Object.entries(sanitized.assignments)) {
                        if (state.assignments[phaseKey]) {
                            state.assignments[phaseKey] = phaseData;
                        }
                    }

                    ensureAssignmentShape(state.assignments);
                    ensureLibraryFallbacks(state.assignments);

                    // Restore custom library from sanitized data
                    if (CONFIG.imports?.clearStixOnKillChainImport) {
                        state.library.custom = {};
                    }
                    if (sanitized.customLibrary) {
                        for (const [id, item] of Object.entries(sanitized.customLibrary)) {
                            state.library.custom[id] = item;
                        }
                    }

                    // Restore sanitized view state
                    if (typeof sanitized.title === 'string') {
                        state.title = sanitizeForStorage(sanitized.title, CONFIG.display?.maxTitleLength || 200);
                    }
                    if (typeof sanitized.description === 'string') {
                        state.description = sanitizeForStorage(sanitized.description, CONFIG.display?.maxKillChainDescLength || 2000);
                    }
                    syncTitleToDOM();
                    syncDescriptionToDOM();
                    if (sanitized.layers) state.layers = sanitized.layers;
                    if (sanitized.hideEmpty !== undefined) state.hideEmpty = sanitized.hideEmpty;
                    if (sanitized.activeTab) state.activeTab = sanitized.activeTab;
                    if (state.compactMode) state.hideEmpty = true;

                    // Apply UI state
                    document.getElementById('layer-attack').checked = !!state.layers.attack;
                    document.getElementById('layer-capec').checked = !!state.layers.capec;
                    document.getElementById('layer-cwe').checked = !!state.layers.cwe;
                    document.getElementById('layer-custom').checked = !!state.layers.custom;
                    updateHideEmptyControl();

                    if (sanitized.view) {
                        setView(sanitized.view);
                    } else {
                        renderKillChain();
                    }

                    switchTab(state.activeTab);
                    renderAll();
                    showToast('Imported kill chain');
                } catch (err) {
                    showToast('Import failed: ' + InputSecurity.escapeHtml(err.message));
                }
            };

            reader.readAsText(file);
            event.target.value = '';
        }

        function exportCSV() {
            // Build CSV with phases as header columns
            // Format: Entity Type, Entity ID, Entity Name, Score, Confidence, CVE, Comments, Phase1, Phase2, ...
            
            // Title metadata row
            const titleRow = ['Title', state.title || 'Untitled Kill Chain'];

            const headers = ['Type', 'ID', 'Name', 'Score', 'Confidence', 'CVE(s)', 'Comments', ...ALL_PHASES.map(p => formatPhaseName(p.split(':')[1]))];
            const rows = [titleRow, headers];
            
            // Collect all unique entities with their metadata
            const allTechs = new Map();  // id -> { phases: Set, metadata }
            const allCapecs = new Map();
            const allCwes = new Map();
            const allCustom = new Map();
            
            for (const [phaseKey, phase] of Object.entries(state.assignments)) {
                const techs = getAllPhaseItemsByType(phase, 'attack');
                const capecs = getAllPhaseItemsByType(phase, 'capec');
                const cwes = getAllPhaseItemsByType(phase, 'cwe');
                const customs = getAllPhaseItemsByType(phase, 'custom');

                techs.forEach(t => {
                    const id = getAssignmentId(t);
                    if (!allTechs.has(id)) {
                        allTechs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(t) });
                    }
                    allTechs.get(id).phases.add(phaseKey);
                });
                capecs.forEach(c => {
                    const id = getAssignmentId(c);
                    if (!allCapecs.has(id)) {
                        allCapecs.set(id, { phases: new Set(), metadata: getAssignmentMetadata(c) });
                    }
                    allCapecs.get(id).phases.add(phaseKey);
                });
                cwes.forEach(w => {
                    const id = getAssignmentId(w);
                    if (!allCwes.has(id)) {
                        allCwes.set(id, { phases: new Set(), metadata: getAssignmentMetadata(w) });
                    }
                    allCwes.get(id).phases.add(phaseKey);
                });
                customs.forEach(x => {
                    const id = getAssignmentId(x);
                    if (!allCustom.has(id)) {
                        allCustom.set(id, { phases: new Set(), metadata: getAssignmentMetadata(x) });
                    }
                    allCustom.get(id).phases.add(phaseKey);
                });
            }
            
            // Helper to format confidence for CSV
            const formatConfidence = (meta) => {
                if (meta.confidence === null || meta.confidence === undefined) return '';
                return `${meta.confidence}% (${getConfidenceLabel(meta.confidence)})`;
            };

            const formatCveList = (meta) => {
                const cveEntries = getCveEntries(meta);
                if (!cveEntries.length) return '';
                return cveEntries.map(entry => {
                    const parts = [];
                    if (entry.score !== null && entry.score !== undefined) parts.push(`Score ${entry.score}`);
                    if (entry.vector) parts.push(entry.vector);
                    return parts.length ? `${entry.id} (${parts.join(', ')})` : entry.id;
                }).join('; ');
            };
            
            // Add technique rows
            for (const [techId, data] of allTechs) {
                const tech = state.library.techniques[techId];
                const meta = data.metadata;
                const row = [
                    'ATT&CK', 
                    techId, 
                    tech?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CAPEC rows
            for (const [capecId, data] of allCapecs) {
                const capec = state.library.capecs[capecId];
                const meta = data.metadata;
                const row = [
                    'CAPEC', 
                    capecId, 
                    capec?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Add CWE rows
            for (const [cweId, data] of allCwes) {
                const cwe = state.library.cwes[cweId];
                const meta = data.metadata;
                const row = [
                    'CWE', 
                    cweId, 
                    cwe?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }

            // Add Custom STIX rows
            for (const [customId, data] of allCustom) {
                const item = state.library.custom[customId];
                const meta = data.metadata;
                const stixLabel = (item?.stixType || 'x-custom').replace(/-/g, ' ');
                const row = [
                    'STIX: ' + stixLabel,
                    customId,
                    item?.name || 'Unknown',
                    meta.score || '',
                    formatConfidence(meta),
                    formatCveList(meta),
                    (meta.comments || '').slice(0, 100).replace(/\n/g, ' ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }

            // Add Mitigation rows (derived from assigned techniques)
            const allMitigations = new Map(); // M-id â†’ { name, phases: Set, techniqueIds: Set }
            for (const [phaseKey, phase] of Object.entries(state.assignments)) {
                const techs = getAllPhaseItemsByType(phase, 'attack');
                for (const t of techs) {
                    const techId = getAssignmentId(t);
                    const entity = state.library.techniques[techId];
                    if (!entity?.mitigations) continue;
                    for (const m of entity.mitigations) {
                        if (!allMitigations.has(m.id)) {
                            allMitigations.set(m.id, { name: m.name, phases: new Set(), techniqueIds: new Set() });
                        }
                        allMitigations.get(m.id).phases.add(phaseKey);
                        allMitigations.get(m.id).techniqueIds.add(techId);
                    }
                }
            }
            for (const [mitId, data] of allMitigations) {
                const row = [
                    'Mitigation',
                    mitId,
                    data.name,
                    '',
                    '',
                    '',
                    'Mitigates: ' + [...data.techniqueIds].sort().join(', ')
                ];
                for (const phaseKey of ALL_PHASES) {
                    row.push(data.phases.has(phaseKey) ? 'X' : '');
                }
                rows.push(row);
            }
            
            // Convert to CSV string
            // KCE-SEC-004: Prefix cells starting with formula characters to prevent injection
            const sanitizeForCsv = (value) => {
                const str = String(value);
                // Prefix with single quote if starts with formula characters
                if (/^[=+\-@\t\r]/.test(str)) {
                    return "'" + str;
                }
                return str;
            };
            
            const csvContent = rows.map(row => 
                row.map(cell => {
                    // Sanitize for formula injection, then escape quotes
                    const sanitized = sanitizeForCsv(cell);
                    const escaped = sanitized.replace(/"/g, '""');
                    return escaped.includes(',') || escaped.includes('"') || escaped.includes('\n') 
                        ? `"${escaped}"` 
                        : escaped;
                }).join(',')
            ).join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const csvSlug = state.title ? state.title.replace(/[^a-zA-Z0-9_-]+/g, '-').replace(/-+$/,'').substring(0, 60) : 'attack-chain-export';
            a.download = csvSlug + '.csv';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Exported CSV');
        }

        // ============================================================
        // DROPDOWN UTILS
        // ============================================================
        function toggleDropdown(id) {
            const dropdown = document.getElementById(id);
            const isOpen = dropdown.classList.contains('open');
            closeDropdowns();
            if (!isOpen) {
                dropdown.classList.add('open');
            }
        }

        function closeDropdowns() {
            document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown')) {
                closeDropdowns();
            }
        });

        // ============================================================
        // METADATA EDITOR
        // ============================================================
        let currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };

        function openMetadataEditor(type, id, phaseKey, instanceId) {
            currentMetadataEdit = { type, id, phaseKey, instanceId };
            
            // Find the assignment
            const assignment = findAssignment(phaseKey, type, id, instanceId);
            const metadata = assignment ? getAssignmentMetadata(assignment) : createDefaultMetadata();
            
            // Populate form
            document.getElementById('metadata-entity-id').textContent = id;
            
            // Score selector (renamed from confidence)
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === (metadata.score || 'unclassified'));
                opt.onclick = () => selectScore(opt.dataset.value);
            });
            
            // Confidence slider (new percentage field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = metadata.confidence || 0;
            confidenceSlider.value = confidenceValue;
            updateConfidenceLabel(confidenceValue);
            confidenceSlider.oninput = (e) => updateConfidenceLabel(parseInt(e.target.value));
            
            // CVE entries
            const cveListEl = document.getElementById('cve-list');
            cveListEl.innerHTML = '';
            const cveEntries = getCveEntries(metadata);
            if (cveEntries.length) {
                cveEntries.forEach(entry => addCveRow(entry.id, entry.score, entry.vector));
            }
            document.getElementById('meta-cve-list-error').textContent = '';
            
            // Comments
            document.getElementById('meta-comments').value = metadata.comments || '';
            
            // Hyperlinks
            const hyperlinkList = document.getElementById('hyperlink-list');
            hyperlinkList.innerHTML = '';
            (metadata.hyperlinks || []).forEach((link, i) => {
                addHyperlinkRow(link.label, link.url);
            });
            
            // Observables
            const observableList = document.getElementById('observable-list');
            observableList.innerHTML = '';
            (metadata.observables || []).forEach((obs, i) => {
                addObservableRow(obs.type, obs.value);
            });
            
            // Show modal
            document.getElementById('metadata-editor-modal').classList.add('visible');
        }

        function closeMetadataEditor(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('metadata-editor-modal').classList.remove('visible');
            currentMetadataEdit = { type: null, id: null, phaseKey: null, instanceId: null };
        }

        function selectScore(value) {
            document.querySelectorAll('#score-selector .score-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.value === value);
            });
        }

        function updateConfidenceLabel(value) {
            const label = document.getElementById('confidence-label');
            const labelText = getConfidenceLabel(value);
            const labelClass = getConfidenceClass(value);
            label.textContent = value === 0 ? 'Unknown' : `${value}% (${labelText})`;
            label.className = `confidence-label ${labelClass}`;
        }

        function addCveRow(id = '', score = '', vector = '') {
            const list = document.getElementById('cve-list');
            const row = document.createElement('div');
            row.className = 'cve-item';

            const idInput = document.createElement('input');
            idInput.type = 'text';
            idInput.className = 'metadata-input cve-id-input';
            idInput.placeholder = 'CVE-2024-12345';
            idInput.value = id || '';

            const scoreInput = document.createElement('input');
            scoreInput.type = 'text';
            scoreInput.className = 'metadata-input cve-score-input';
            scoreInput.placeholder = 'Score (0-10)';
            scoreInput.value = (score === null || score === undefined) ? '' : String(score);

            const vectorInput = document.createElement('input');
            vectorInput.type = 'text';
            vectorInput.className = 'metadata-input cve-vector-input';
            vectorInput.placeholder = 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H';
            vectorInput.value = vector || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(idInput);
            row.appendChild(scoreInput);
            row.appendChild(vectorInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function addHyperlinkRow(label = '', url = '') {
            const list = document.getElementById('hyperlink-list');
            const row = document.createElement('div');
            row.className = 'hyperlink-item';
            const labelInput = document.createElement('input');
            labelInput.type = 'text';
            labelInput.className = 'metadata-input';
            labelInput.placeholder = 'Label';
            labelInput.value = label || '';

            const urlInput = document.createElement('input');
            urlInput.type = 'text';
            urlInput.className = 'metadata-input';
            urlInput.placeholder = 'https://...';
            urlInput.value = url || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(labelInput);
            row.appendChild(urlInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function addObservableRow(type = 'ipv4-addr', value = '') {
            const list = document.getElementById('observable-list');
            const row = document.createElement('div');
            row.className = 'observable-item';
            const select = document.createElement('select');
            select.className = 'metadata-select';
            OBSERVABLE_TYPES.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.value;
                opt.textContent = t.label;
                if (t.value === type) opt.selected = true;
                select.appendChild(opt);
            });

            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.className = 'metadata-input';
            valueInput.placeholder = 'Value';
            valueInput.value = value || '';

            const removeBtn = document.createElement('button');
            removeBtn.className = 'observable-remove';
            removeBtn.innerHTML = '&times;';
            removeBtn.onclick = () => row.remove();

            row.appendChild(select);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            list.appendChild(row);
        }

        function saveMetadata() {
            const { type, id, phaseKey, instanceId } = currentMetadataEdit;
            if (!type || !id || !phaseKey) return;
            
            // Get score (renamed from confidence)
            const selectedScore = document.querySelector('#score-selector .score-option.selected');
            const score = selectedScore ? selectedScore.dataset.value : 'unclassified';
            
            // Get confidence percentage (new field)
            const confidenceSlider = document.getElementById('meta-confidence');
            const confidenceValue = parseInt(confidenceSlider.value) || 0;
            const confidence = confidenceValue === 0 ? null : confidenceValue;
            
            // Get CVE entries (with validation)
            const cveError = document.getElementById('meta-cve-list-error');
            cveError.textContent = '';
            const cveEntries = [];
            const cveEntryMap = new Map();
            let hasInvalidCve = false;
            document.querySelectorAll('#cve-list .cve-item').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const idRaw = sanitizeForStorage(inputs[0].value, 50).toUpperCase();
                const scoreRaw = sanitizeForStorage(inputs[1].value, 10);
                const vectorRaw = sanitizeForStorage(inputs[2].value, 200);

                inputs.forEach(input => input.classList.remove('invalid'));

                if (!idRaw && !scoreRaw && !vectorRaw) {
                    return;
                }

                if (!idRaw || !InputSecurity.validators.cveId(idRaw).valid) {
                    inputs[0].classList.add('invalid');
                    hasInvalidCve = true;
                    return;
                }

                let score = null;
                if (scoreRaw) {
                    const scoreValue = parseFloat(scoreRaw);
                    if (!Number.isFinite(scoreValue) || scoreValue < 0 || scoreValue > 10) {
                        inputs[1].classList.add('invalid');
                        hasInvalidCve = true;
                        return;
                    }
                    score = Math.round(scoreValue * 10) / 10;
                }

                let vector = '';
                if (vectorRaw) {
                    if (!InputSecurity.validators.cvssVector(vectorRaw).valid) {
                        inputs[2].classList.add('invalid');
                        hasInvalidCve = true;
                        return;
                    }
                    vector = vectorRaw;
                }

                if (!cveEntryMap.has(idRaw)) {
                    const entry = { id: idRaw, score, vector };
                    cveEntryMap.set(idRaw, entry);
                    cveEntries.push(entry);
                } else {
                    const existing = cveEntryMap.get(idRaw);
                    if (existing.score === null && score !== null) existing.score = score;
                    if (!existing.vector && vector) existing.vector = vector;
                }
            });

            if (hasInvalidCve) {
                cveError.textContent = 'Fix invalid CVE entries (format, score 0-10, or CVSS vector).';
                return;
            }
            
            // Get comments
            const comments = sanitizeForStorage(document.getElementById('meta-comments').value, 2000);
            
            // Get hyperlinks (with validation)
            const hyperlinks = [];
            document.querySelectorAll('#hyperlink-list .hyperlink-item').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const label = sanitizeForStorage(inputs[0].value, 100);
                const url = sanitizeForStorage(inputs[1].value, 500);
                if (label && url) {
                    if (InputSecurity.validators.url(url).valid) {
                        hyperlinks.push({ label, url });
                    }
                }
            });
            
            // Get observables (with validation)
            const observables = [];
            let hasInvalidObservable = false;
            document.querySelectorAll('#observable-list .observable-item').forEach(row => {
                const select = row.querySelector('select');
                const input = row.querySelector('input');
                const obsType = select.value;
                const obsValue = sanitizeForStorage(input.value, 500);
                
                if (obsValue) {
                    const validation = InputSecurity.validateObservable(obsType, obsValue);
                    if (validation.valid) {
                        observables.push({ type: obsType, value: obsValue });
                        input.classList.remove('invalid');
                    } else {
                        input.classList.add('invalid');
                        hasInvalidObservable = true;
                    }
                }
            });
            
            if (hasInvalidObservable) {
                showToast('Fix invalid observable values');
                return;
            }
            
            // Build new metadata
            const cveIds = cveEntries.map(entry => entry.id);
            const newMetadata = {
                score,
                confidence,
                cveEntries,
                cveId: cveIds[0] || '',
                cveIds,
                comments,
                hyperlinks,
                observables
            };
            
            // Update the assignment
            updateAssignmentMetadata(phaseKey, type, id, newMetadata, instanceId);
            
            // Close and re-render
            closeMetadataEditor();
            renderKillChain();
            showToast('Metadata saved');
        }

        // ============================================================
        // USAGE GUIDE
        // ============================================================
        function showUsageGuide() {
            document.getElementById('usage-guide-modal').classList.add('visible');
        }

        function closeUsageGuide(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('usage-guide-modal').classList.remove('visible');
        }

        // ============================================================
        // CHANGELOG MODAL
        // ============================================================
        async function showChangelog() {
            const modal = document.getElementById('changelog-modal');
            const content = document.getElementById('changelog-content');
            modal.classList.add('visible');
            
            try {
                const res = await fetch('CHANGELOG.md');
                const text = await res.text();
                content.textContent = text;
            } catch (e) {
                content.textContent = 'Error loading changelog: ' + e.message;
            }
        }

        function closeChangelog(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('changelog-modal').classList.remove('visible');
        }

        // Close modals on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeUsageGuide();
                closeChangelog();
                closeEntityModal();
                closeMetadataEditor();
            }
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        function renderAll() {
            filterEntities('attack');
            filterEntities('capec');
            filterEntities('cwe');
            filterEntities('custom');
            renderKillChain();
            syncTitleToDOM();
            syncDescriptionToDOM();
        }

        // ============================================================
        // LEAVE SITE CONFIRMATION
        // ============================================================
        function enableLeaveSiteConfirmation() {
            window.addEventListener('beforeunload', (e) => {
                e.preventDefault();
                e.returnValue = '';
                return '';
            });
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        initThemeControls();
        window.addEventListener('storage', (e) => {
            if (e.key === THEME_STORAGE_KEYS.mode) {
                syncThemeFromStorage();
            }
        });
        if (typeof CONFIG !== 'undefined') {
            if (CONFIG.navigation?.confirmOnLeave !== false) {
                enableLeaveSiteConfirmation();
            }
        } else {
            enableLeaveSiteConfirmation();
        }
        initAssignments();
        initCompactMode();
        window.addEventListener('resize', () => {
            if (state.compactMode) {
                applyCompactLayout();
            }
        });
        applyInputGuards();
        populateStixTypeDropdown();
        loadVersion();
        loadData();
    </script>
</body>
</html>
