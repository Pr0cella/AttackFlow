<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        img-src 'self' data:;
        connect-src 'self';
        frame-src 'self' blob:;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
        frame-ancestors 'self';
    ">
    <title>AttackFlow - STIX Composer</title>
    <script src="config.js"></script>
    <script>
        (function syncThemeHelpersFromParent() {
            try {
                const allowParentCoupling = (
                    typeof window !== 'undefined' &&
                    window.location &&
                    window.location.protocol === 'file:' &&
                    (typeof CONFIG === 'undefined' || CONFIG.ConfigIframeIPC?.enableLocalIframeIPC !== false)
                );
                if (allowParentCoupling && window.parent && window.parent !== window && window.parent.CONFIG) {
                    window.CONFIG = window.parent.CONFIG;
                }
            } catch (e) {
                // Keep local config/theme helpers when parent access is unavailable
            }
        })();
    </script>
    <script src="stix-builder.config.js"></script>
    <script>
        (function configureStixVisualizerAvailability() {
            const enabled = (typeof CONFIG === 'undefined') || (CONFIG.visualizer?.enabled !== false);
            window.AF_STIX_VISUALIZER_ENABLED = enabled;
            if (!enabled) return;

            const head = document.head || document.getElementsByTagName('head')[0];

            const visualizerCss = document.createElement('link');
            visualizerCss.rel = 'stylesheet';
            visualizerCss.href = 'stix-visualization/stix_visualizer/application.css';
            head.appendChild(visualizerCss);

            const visualizerScript = document.createElement('script');
            visualizerScript.src = 'stix-visualization/stix_visualizer/require.js';
            visualizerScript.setAttribute('data-main', 'stix-visualization/stix_visualizer/application');
            head.appendChild(visualizerScript);
        })();
    </script>
    <style>
        :root {
            --bg-dark: #f8fafc;
            --bg-card: #ffffff;
            --bg-panel: #f1f5f9;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --border-color: #e2e8f0;
            --accent: #94a3b8;
            --success: #22c55e;
            --danger: #ef4444;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            gap: 16px;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .header-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .header-subtitle {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .theme-toggle {
            width: 24px;
            height: 24px;
            border-radius: 24px;
            border: 1px solid var(--border-color);
            background: var(--bg-panel);
            color: var(--text-primary);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
            overflow: hidden;
        }

        .theme-toggle:hover {
            border-color: var(--accent);
        }

        .theme-icon {
            width: 16px;
            height: 16px;
            position: absolute;
            opacity: 0;
            transform: scale(0.8) rotate(-15deg);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .theme-toggle[data-mode="dark"] .theme-icon.theme-dark,
        .theme-toggle[data-mode="light"] .theme-icon.theme-light {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }

        .theme-icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
            display: block;
        }

        .btn {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-panel);
            color: var(--text-secondary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover { color: var(--text-primary); border-color: var(--accent); }
        .btn.primary { border-color: var(--accent); color: var(--text-primary); }
        .btn.danger:hover { border-color: var(--danger); color: var(--danger); }
        .btn.success { border-color: var(--success); color: var(--success); }

        .main {
            display: grid;
            grid-template-columns: 320px 1fr 360px;
            gap: 12px;
            padding: 12px;
            height: calc(100vh - 56px);
        }

        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .panel-header {
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-body {
            padding: 10px;
            overflow: auto;
            flex: 1;
        }

        #right-pane-body.no-scroll {
            overflow: hidden;
        }

        .tabs {
            display: flex;
            gap: 6px;
            padding: 10px 12px 0;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        #type-tabs {
            justify-content: flex-start;
            gap: 7px;
        }

        #type-tabs > .tab {
            padding: 3px 6px;
        }

        .tab {
            padding: 6px 10px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .tab:hover { border-color: var(--accent); }

        .tab.active {
            color: var(--text-primary);
            border-color: var(--accent);
            background: rgba(113, 113, 122, 0.15);
        }

        .search {
            padding: 10px 12px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .search input {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .object-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .object-item {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-panel);
            cursor: pointer;
        }

        .object-item:hover { border-color: var(--accent); }
        .object-item.selected { 
            border-color: var(--custom-color);
            background: rgba(113, 113, 122, 0.2); 
        }

        .object-id {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-weight: 600;
            font-size: 0.72rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .object-name {
            font-size: 0.8rem;
            margin-top: 4px;
        }

        .form-section {
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .field {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px dashed var(--border-color);
        }

        .field:last-child { border-bottom: none; }

        .field-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .req {
            color: var(--danger);
            font-weight: 600;
            font-size: 0.7rem;
        }

        .field-input input,
        .field-input select,
        .field-input textarea {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .field-input input[type="checkbox"] {
            width: auto;
        }

        .field-input textarea { min-height: 70px; resize: vertical; }

        .inline-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .mini-btn {
            padding: 4px 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-panel);
            color: var(--text-secondary);
            font-size: 0.65rem;
            cursor: pointer;
        }

        .mini-btn:hover { color: var(--text-primary); border-color: var(--accent); }
        .mini-btn.danger:hover { color: var(--danger); border-color: var(--danger); }

        .center-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .center-toggle .btn.active {
            border-color: var(--accent);
        }

        #visualize-bundle,
        #add-object {
            background: var(--bg-panel);
            color: var(--text-secondary);
            border-color: var(--border-color);
        }

        #visualize-bundle:disabled,
        #add-object:disabled {
            cursor: default;
            pointer-events: none;
        }

        #visualize-bundle:not(:disabled):hover,
        #add-object:not(:disabled):hover {
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .list-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 6px;
            margin-bottom: 6px;
        }

        .list-item:last-child { margin-bottom: 0; }

        .list-item input,
        .list-item select {
            width: 100%;
        }

        .list-info {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .badge {
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(113, 113, 122, 0.2);
            color: var(--text-secondary);
            font-size: 0.65rem;
            margin-left: 6px;
        }

        .status-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .status-row.clickable {
            cursor: pointer;
        }

        .status-row.clickable:hover {
            color: var(--text-primary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
        }

        .status-dot.ok { background: var(--success); }
        .status-dot.bad { background: var(--danger); }

        .json-preview {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.72rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            padding: 8px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .empty {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .toast {
            position: fixed;
            right: 16px;
            bottom: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            color: var(--text-primary);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s;
            pointer-events: none;
        }

        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            max-width: 640px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text-primary); }

        .modal-body {
            padding: 16px;
            overflow-y: auto;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .issue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .issue-item {
            padding: 8px 10px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .center-pane {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .center-pane.hidden { display: none; }

        .visualizer-pane {
            display: none;
            height: 100%;
        }

        .visualizer-pane.active { display: block; }

        .visualizer-pane,
        .visualizer-pane * {
            color: var(--text-primary);
            background-color: transparent;
        }

        .visualizer-pane .sidebar,
        .right-visualizer .sidebar {
            background: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .visualizer-pane .selected-object-prop-name,
        .right-visualizer .selected-object-prop-name { color: var(--accent); }

        .visualizer-pane .selected-object-text-value,
        .right-visualizer .selected-object-text-value { color: var(--text-primary); }

        .visualizer-pane .selected-object-text-value-ref,
        .right-visualizer .selected-object-text-value-ref { color: var(--accent); }

        .visualizer-pane .selected-object-text-value-ref-dangling,
        .right-visualizer .selected-object-text-value-ref-dangling { color: var(--danger); }

        .visualizer-pane .selected-object-nontext-value,
        .right-visualizer .selected-object-nontext-value { color: var(--text-secondary); }

        .visualizer-pane #legend-content .typeHidden {
            color: var(--text-secondary);
        }

        .visualizer-pane .vis-network .vis-node.vis-selected,
        .visualizer-pane .vis-network .vis-node.vis-selected img,
        .visualizer-pane .vis-network .vis-node.vis-selected canvas {
            box-shadow: 0 0 0 3px var(--accent), 0 0 18px rgba(148, 163, 184, 0.5);
            border-radius: 6px;
        }

        .visualizer-pane .vis-network .vis-label {
            color: var(--text-primary);
        }

        .visualizer-pane .vis-network .vis-node.vis-selected .vis-label {
            background: rgba(148, 163, 184, 0.25);
            color: var(--text-primary);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .visualizer-pane #uploader,
        .visualizer-pane #top-header-bar,
        .visualizer-pane #chosen-files,
        .visualizer-pane #paste-area-stix-json,
        .visualizer-pane #paste-area-custom-config,
        .visualizer-pane #paste-parser,
        .visualizer-pane #files {
            display: none;
        }

        .visualizer-pane #canvas {
            border: 1px solid var(--border-color);
            background: var(--bg-panel);
            height: 520px;
        }

        .visualizer-pane #canvas-wrapper {
            margin: 0;
            width: 100%;
            /* margin-right: 1rem; */
        }

        .visualizer-pane .sidebar {
            background: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .visualizer-pane .selected-object-prop-name { color: var(--accent); }
        .visualizer-pane .selected-object-text-value { color: var(--text-primary); }
        .visualizer-pane .selected-object-text-value-ref { color: var(--accent); }
        .visualizer-pane .selected-object-text-value-ref-dangling { color: var(--danger); }

        .right-visualizer {
            display: none;
            height: 100%;
            overflow: hidden;
            gap: 10px;
            flex-direction: column;
        }

        .right-visualizer.active { display: flex; }

        .right-visualizer .sidebar {
            width: 100%;
            margin: 0;
            overflow: hidden;
            max-height: calc(50% - 6px);
            overflow-y: scroll;
        }

        .right-visualizer .selected-object-text-value,
        .right-visualizer .selected-object-text-value-ref,
        .right-visualizer .selected-object-text-value-ref-dangling,
        .right-visualizer .selected-object-prop-name,
        .right-visualizer .selected-object-nontext-value {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .right-visualizer .selected-object-list {
            max-height: 120px;
            overflow: hidden;
        }

        @media (max-width: 1100px) {
            .main {
                grid-template-columns: 1fr;
                height: auto;
            }
            .panel { min-height: 220px; }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="header">
            <div class="header-left">
                <!--<div class="header-title">STIX 2.1 Composer</div>
                <div class="header-subtitle">Create, Edit & Visualize STIX 2.1 Bundles</div>-->
                <div class="header-controls">
                    <div class="control-group">
                        <span class="control-label">Add</span>
                        <select id="add-type" class="btn"></select>
                        <button class="btn primary" id="add-object">Add Object</button>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <span class="control-label">Bundle</span>
                <button class="btn danger" id="clear-bundle">Clear Bundle</button>
                <span width="1px" style="border-left:1px solid var(--border-color); height: 16px; display: inline-block;"></span>
                <button class="btn" id="validate-bundle">Validate</button>
                <button class="btn" id="export-bundle">Export</button>
                <button class="btn" id="import-bundle">Import</button>
            </div>
        </div>

        <div class="main">
            <div class="panel">
                <div class="tabs" id="type-tabs"></div>
                <div class="search">
                    <input id="search-input" type="text" placeholder="Search by ID or name">
                </div>
                <div class="panel-body" id="left-pane-body">
                    <div class="object-list" id="object-list"></div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <div class="center-controls">
                        <button class="mini-btn" id="copy-json">Copy Item as JSON</button>
                        <button class="mini-btn danger" id="delete-object">Delete Item</button>
                    </div>
                    <div class="center-toggle">
                        <button class="btn" id="mode-editor">Editor</button>
                        <button class="btn" id="mode-visualizer">Visualizer</button>
                    </div>
                    <button class="btn" id="visualize-bundle">Render Bundle</button>
                </div>
                <div class="panel-body center-pane" id="center-pane">
                    <div id="editor-panel"></div>
                    <div class="visualizer-pane" id="visualizer-pane">
                        <div id="top-header-bar">
                            <span id="header"></span>
                            <span class="chosen-file" id="chosen-files"></span>
                        </div>
                        <div id="uploader">
                            <input type="file" id="files" name="files">
                            <textarea id="paste-area-stix-json"></textarea>
                            <button id="paste-parser">Parse</button>
                            <textarea id="paste-area-custom-config"></textarea>
                        </div>
                        <div id="canvas-container" class="hidden">
                            <div class="canvas-loading hidden" id="canvas-loading" aria-live="polite" aria-busy="true">
                                <div class="canvas-loading-inner">
                                    <div class="canvas-spinner" aria-hidden="true"></div>
                                    <div class="canvas-loading-text">Rendering graph...</div>
                                </div>
                            </div>
                            <div id="canvas-wrapper">
                                <div id="canvas"></div>
                                <div id="timelineControls">
                                    <label for="timeline">Timeline</label>
                                    <label for="timelineCheckbox">&nbsp; | Cumulative Timeline</label>
                                    <input type="checkbox" id="timelineCheckbox" name="cumulative" checked disabled>
                                    <input type="range" id="timeline" name="timeline" min="0" max="0" step="1" disabled>
                                </div>
                                <div id="legend">
                                    <table id="legend-content">
                                        <caption><h5>Legend</h5></caption>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <span>Bundle</span>
                    <div class="status-row" id="bundle-status" role="button" tabindex="0" aria-label="View validation issues">
                        <span class="status-dot" id="status-dot"></span>
                        <span id="status-text">Not validated</span>
                    </div>
                </div>
                <div class="panel-body" id="right-pane-body">
                    <div id="bundle-pane">
                        <div class="form-section">
                            <div class="section-title">Summary</div>
                            <div id="bundle-summary" class="hint"></div>
                        </div>
                        <div class="form-section">
                            <div class="section-title">JSON Preview</div>
                            <div class="json-preview" id="bundle-preview"></div>
                        </div>
                    </div>
                    <div class="right-visualizer" id="visualizer-side-pane">
                        <div id="selected" class="sidebar">
                            <h5>Selected Node</h5>
                            <div id="selection"></div>
                        </div>
                        <div id="connections" class="sidebar">
                            <h5>Linked Nodes</h5>
                            <h6>Incoming Edges:</h6>
                            <div id="connections-incoming"></div>
                            <h6>Outgoing Edges:</h6>
                            <div id="connections-outgoing"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="bundle-file" accept=".json" style="display:none">
    <div class="toast" id="toast"></div>

    <div class="modal-overlay" id="bundle-issues-modal" onclick="closeBundleIssues(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">Bundle Validation Issues</div>
                <button class="modal-close" onclick="closeBundleIssues()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="issue-list" id="bundle-issues-list"></div>
            </div>
        </div>
    </div>

    <script>
        const INPUT_LIMITS = {
            maxFileSize: 50 * 1024 * 1024,
            maxObjects: 5000,
            maxStringLength: 5000,
            maxListItems: 100
        };

        const LIST_LIMITS = {
            maxAllResults: 500
        };

        const THEME_STORAGE_KEYS = {
            mode: 'af-theme-mode'
        };

        let currentTheme = {
            mode: CONFIG?.themeDefaults?.mode || 'light',
            scheme: 'default'
        };

        const VISUALIZER_ENABLED = window.AF_STIX_VISUALIZER_ENABLED !== false;

        const InputSecurity = {
            escapeHtml(str) {
                if (str === null || str === undefined) return '';
                const div = document.createElement('div');
                div.textContent = String(str);
                return div.innerHTML;
            },
            encodeHtmlEntities(str) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/\\/g, '&#92;')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;')
                    .replace(/`/g, '&#96;');
            },
            normalize(str, maxLength = 10000) {
                if (str === null || str === undefined) return '';
                return String(str)
                    .replace(/[\x00-\x1F\x7F]/g, '')
                    .slice(0, maxLength);
            },
            sanitize(str, maxLength = 10000) {
                let value = this.normalize(str, maxLength).trim();
                value = value.replace(/[\[\]\{\};"'`]/g, '');
                return this.encodeHtmlEntities(value);
            },
            sanitizeAttr(str, maxLength = 200) {
                return this.encodeHtmlEntities(this.sanitize(str, maxLength));
            }
        };

        const esc = (str) => InputSecurity.escapeHtml(str);
        const escAttr = (str) => InputSecurity.sanitizeAttr(str);

        const BLOCKED_INPUT_CHARS = new Set(['<', '>', '[', ']', '{', '}', '"', "'", '`', ';']);

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), 2200);
        }

        function getPreferredThemeMode() {
            const configured = CONFIG?.themeMode || CONFIG?.themeDefaults?.mode || 'light';
            if (configured !== 'auto') return configured;
            if (typeof window === 'undefined') return CONFIG?.themeDefaults?.mode || 'light';
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) return 'light';
            return 'dark';
        }

        function normalizeThemeMode(mode) {
            return mode === 'light' || mode === 'dark' ? mode : (CONFIG?.themeDefaults?.mode || 'light');
        }

        function normalizeThemeScheme(mode, scheme) {
            const schemes = CONFIG?.themes?.[mode] || {};
            if (scheme && schemes[scheme]) return scheme;
            if (schemes.default) return 'default';
            const first = Object.keys(schemes)[0];
            return first || 'default';
        }

        function applyTheme(mode, scheme, persist = true) {
            const resolvedMode = normalizeThemeMode(mode);
            const resolvedScheme = normalizeThemeScheme(resolvedMode, scheme);
            const theme = typeof resolveTheme === 'function'
                ? resolveTheme(resolvedMode, resolvedScheme)
                : null;
            if (typeof applyConfigColors === 'function') applyConfigColors(theme);
            document.documentElement.dataset.theme = resolvedMode;
            currentTheme = { mode: resolvedMode, scheme: resolvedScheme };
            updateThemeControls();
            window.AttackFlowStixViz?.applyTheme?.();
            if (persist) {
                try { localStorage.setItem(THEME_STORAGE_KEYS.mode, resolvedMode); } catch (e) {}
            }
        }

        function updateThemeControls() {
            const modeBtn = document.getElementById('theme-mode-toggle');
            if (modeBtn) {
                modeBtn.setAttribute('data-mode', currentTheme.mode);
                modeBtn.setAttribute('aria-label', currentTheme.mode === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
                modeBtn.setAttribute('title', currentTheme.mode === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
            }
        }

        function toggleThemeMode() {
            const nextMode = currentTheme.mode === 'dark' ? 'light' : 'dark';
            const nextScheme = normalizeThemeScheme(nextMode, currentTheme.scheme);
            applyTheme(nextMode, nextScheme);
        }

        function initThemeControls() {
            let storedMode = null;
            try { storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode); } catch (e) {}
            const mode = normalizeThemeMode(storedMode || getPreferredThemeMode());
            applyTheme(mode, 'default', false);
        }

        function syncThemeFromStorage() {
            let storedMode = null;
            try { storedMode = localStorage.getItem(THEME_STORAGE_KEYS.mode); } catch (e) { return; }
            const mode = normalizeThemeMode(storedMode || currentTheme.mode);
            if (mode !== currentTheme.mode) {
                applyTheme(mode, 'default', false);
            }
        }

        function isLocalIframeIPCEnabled() {
            if (!(typeof window !== 'undefined' && window.location && window.location.protocol === 'file:')) return false;
            return typeof CONFIG === 'undefined' || CONFIG.ConfigIframeIPC?.enableLocalIframeIPC !== false;
        }

        function isLocalIframeIPCTraceEnabled() {
            return typeof CONFIG !== 'undefined' && CONFIG.debugging?.traceLocalIframeIPCLogs === true;
        }

        const IPC_PORT_INBOUND_MESSAGE_TYPES = new Set(['AF_THEME_SYNC']);
        const IPC_PORT_INBOUND_MESSAGE_KEYS = {
            AF_THEME_SYNC: new Set(['type', 'mode', 'scheme', 'nonce'])
        };
        const IPC_BOOTSTRAP_MESSAGE_KEYS = new Set(['type', 'channel', 'nonce']);
        const IPC_CHANNEL_BOOTSTRAP_TYPE = 'AF_IPC_PORT_INIT';
        const IPC_BOOTSTRAP_WAIT_DEFAULTS = {
            timeoutMs: 1200,
            maxRetries: 3,
            retryBaseDelayMs: 250,
            retryBackoffMultiplier: 2,
            maxRetryDelayMs: 2000,
            graceMs: 300
        };

        function logLocalIframeIPCSplash(context) {
            const protocol = (typeof window !== 'undefined' && window.location && window.location.protocol) ? window.location.protocol : 'unknown';
            const configured = typeof CONFIG === 'undefined' ? 'unset' : (CONFIG.ConfigIframeIPC?.enableLocalIframeIPC !== false);
            const active = isLocalIframeIPCEnabled();
            console.info(`[AF IPC][${context}] local iframe IPC status`, {
                protocol,
                configured,
                active,
                trace: isLocalIframeIPCTraceEnabled()
            });
        }

        function logLocalIframeIPCTrace(context, message, details) {
            if (!isLocalIframeIPCTraceEnabled()) return;
            if (typeof details === 'undefined') {
                console.log(`[AF IPC][${context}] ${message}`);
                return;
            }
            console.log(`[AF IPC][${context}] ${message}`, details);
        }

        function isPlainObject(value) {
            return !!value && typeof value === 'object' && !Array.isArray(value);
        }

        function hasOnlyAllowedKeys(value, allowedKeys, contextLabel) {
            if (!isPlainObject(value)) {
                logLocalIframeIPCTrace('stix-builder', `${contextLabel} rejected: payload is not object`);
                return false;
            }
            const keys = Object.keys(value);
            for (const key of keys) {
                if (!allowedKeys.has(key)) {
                    logLocalIframeIPCTrace('stix-builder', `${contextLabel} rejected: unknown key`, { key });
                    return false;
                }
            }
            return true;
        }

        let parentIpcPort = null;
        let parentIpcNonce = '';
        let parentIPCBootstrapReceived = false;
        let parentIPCWaitTimerId = null;
        let parentIPCWarningShown = false;

        function hasActiveParentIPCChannel() {
            return !!parentIpcPort && !!parentIpcNonce;
        }

        function setParentIPCChannel(port, nonce) {
            if (parentIpcPort) {
                try {
                    parentIpcPort.onmessage = null;
                    parentIpcPort.close();
                } catch (e) {
                    // ignore close errors
                }
            }
            parentIpcPort = port;
            parentIpcNonce = nonce;
        }

        function clearParentIPCWaitTimer() {
            if (!parentIPCWaitTimerId) return;
            clearTimeout(parentIPCWaitTimerId);
            parentIPCWaitTimerId = null;
        }

        function getLocalIframeIPCBootstrapConfig() {
            const cfg = (typeof CONFIG !== 'undefined' && CONFIG.debugging?.localIframeIPCBootstrap)
                ? CONFIG.debugging.localIframeIPCBootstrap
                : {};
            const timeoutMs = Number.isFinite(cfg.timeoutMs) && cfg.timeoutMs >= 200
                ? Math.floor(cfg.timeoutMs)
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.timeoutMs;
            const maxRetries = Number.isFinite(cfg.maxRetries) && cfg.maxRetries >= 1
                ? Math.floor(cfg.maxRetries)
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.maxRetries;
            const retryBaseDelayMs = Number.isFinite(cfg.retryBaseDelayMs) && cfg.retryBaseDelayMs >= 0
                ? Math.floor(cfg.retryBaseDelayMs)
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.retryBaseDelayMs;
            const retryBackoffMultiplier = Number.isFinite(cfg.retryBackoffMultiplier) && cfg.retryBackoffMultiplier >= 1
                ? cfg.retryBackoffMultiplier
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.retryBackoffMultiplier;
            const maxRetryDelayMs = Number.isFinite(cfg.maxRetryDelayMs) && cfg.maxRetryDelayMs >= retryBaseDelayMs
                ? Math.floor(cfg.maxRetryDelayMs)
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.maxRetryDelayMs;
            const graceMs = Number.isFinite(cfg.graceMs) && cfg.graceMs >= 0
                ? Math.floor(cfg.graceMs)
                : IPC_BOOTSTRAP_WAIT_DEFAULTS.graceMs;
            return {
                timeoutMs,
                maxRetries,
                retryBaseDelayMs,
                retryBackoffMultiplier,
                maxRetryDelayMs,
                graceMs
            };
        }

        function estimateBootstrapFailureWindowMs() {
            const cfg = getLocalIframeIPCBootstrapConfig();
            let delayTotal = 0;
            for (let attempt = 2; attempt <= cfg.maxRetries; attempt += 1) {
                const exponent = Math.max(0, attempt - 2);
                const computedDelay = cfg.retryBaseDelayMs * Math.pow(cfg.retryBackoffMultiplier, exponent);
                delayTotal += Math.min(cfg.maxRetryDelayMs, computedDelay);
            }
            return (cfg.timeoutMs * cfg.maxRetries) + delayTotal + cfg.graceMs;
        }

        function scheduleParentIPCBootstrapFailureWatch() {
            if (!isLocalIframeIPCEnabled()) return;
            if (parentIPCBootstrapReceived || hasActiveParentIPCChannel()) return;
            clearParentIPCWaitTimer();
            const waitMs = estimateBootstrapFailureWindowMs();
            parentIPCWaitTimerId = window.setTimeout(() => {
                if (parentIPCBootstrapReceived || hasActiveParentIPCChannel() || parentIPCWarningShown) return;
                parentIPCWarningShown = true;
                logLocalIframeIPCTrace('stix-builder', 'parent channel bootstrap failed after retries', { waitMs });
                showToast('Parent IPC unavailable; using local theme defaults');
            }, waitMs);
        }

        function requestParentTheme() {
            if (!isLocalIframeIPCEnabled()) {
                logLocalIframeIPCTrace('stix-builder', 'parent theme request skipped: IPC disabled');
                return;
            }

            if (hasActiveParentIPCChannel()) {
                try {
                    parentIpcPort.postMessage({ type: 'AF_REQUEST_THEME', nonce: parentIpcNonce });
                    logLocalIframeIPCTrace('stix-builder', 'parent theme request sent via channel', { type: 'AF_REQUEST_THEME' });
                    return;
                } catch (e) {
                    logLocalIframeIPCTrace('stix-builder', 'parent theme channel request failed', { error: String(e && e.message ? e.message : e) });
                }
            }

            logLocalIframeIPCTrace('stix-builder', 'parent theme request skipped: channel unavailable');
        }

        function initParentThemeBridge() {
            if (!isLocalIframeIPCEnabled()) {
                logLocalIframeIPCTrace('stix-builder', 'theme bridge skipped: IPC disabled');
                return;
            }
            logLocalIframeIPCTrace('stix-builder', 'theme bridge initialized');

            const handleChannelMessage = (event) => {
                const message = event.data;
                if (!message || typeof message !== 'object') return;
                if (!IPC_PORT_INBOUND_MESSAGE_TYPES.has(message.type)) {
                    logLocalIframeIPCTrace('stix-builder', 'channel message rejected: unknown type', { type: message.type || null });
                    return;
                }
                const allowedMessageKeys = IPC_PORT_INBOUND_MESSAGE_KEYS[message.type];
                if (!hasOnlyAllowedKeys(message, allowedMessageKeys, `Channel ${message.type}`)) {
                    return;
                }
                if (message.nonce !== parentIpcNonce) {
                    logLocalIframeIPCTrace('stix-builder', 'channel message rejected: nonce mismatch', { type: message.type || null });
                    return;
                }
                logLocalIframeIPCTrace('stix-builder', 'theme sync message received');
                const mode = normalizeThemeMode(message.mode || currentTheme.mode);
                const scheme = normalizeThemeScheme(mode, message.scheme || 'default');
                applyTheme(mode, scheme, false);
                logLocalIframeIPCTrace('stix-builder', 'theme applied from parent', { mode, scheme });
            };

            window.addEventListener('message', (event) => {
                const message = event.data;
                if (!message || typeof message !== 'object') return;
                if (event.source !== window.parent) {
                    logLocalIframeIPCTrace('stix-builder', 'message rejected: unknown source window');
                    return;
                }

                if (message.type === IPC_CHANNEL_BOOTSTRAP_TYPE) {
                    if (!hasOnlyAllowedKeys(message, IPC_BOOTSTRAP_MESSAGE_KEYS, 'IPC bootstrap')) {
                        return;
                    }
                    if (message.channel !== 'stix-builder') {
                        logLocalIframeIPCTrace('stix-builder', 'bootstrap rejected: unexpected channel', { channel: message.channel || null });
                        return;
                    }
                    if (typeof message.nonce !== 'string' || !message.nonce) {
                        logLocalIframeIPCTrace('stix-builder', 'bootstrap rejected: invalid nonce');
                        return;
                    }
                    const transferredPort = event.ports && event.ports[0];
                    if (!transferredPort || typeof transferredPort.postMessage !== 'function') {
                        logLocalIframeIPCTrace('stix-builder', 'bootstrap rejected: missing message port');
                        return;
                    }
                    setParentIPCChannel(transferredPort, message.nonce);
                    parentIPCBootstrapReceived = true;
                    clearParentIPCWaitTimer();
                    parentIpcPort.onmessage = handleChannelMessage;
                    if (typeof parentIpcPort.start === 'function') parentIpcPort.start();
                    logLocalIframeIPCTrace('stix-builder', 'channel bootstrap accepted');
                    requestParentTheme();
                    return;
                }

                logLocalIframeIPCTrace('stix-builder', 'window message rejected: channel-only mode', { type: message.type || null });
            });

            scheduleParentIPCBootstrapFailureWatch();
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        const DANGEROUS_OBJECT_KEYS = new Set(['__proto__', 'prototype', 'constructor']);

        function isDangerousObjectKey(key) {
            return typeof key === 'string' && DANGEROUS_OBJECT_KEYS.has(key);
        }

        function createSafeObject() {
            return Object.create(null);
        }

        function hasOwn(obj, key) {
            return !!obj && Object.prototype.hasOwnProperty.call(obj, key);
        }

        function parseJsonSafe(text) {
            return JSON.parse(text, (key, value) => {
                if (isDangerousObjectKey(key)) return undefined;
                return value;
            });
        }

        function stripAngleBracketsFromJson(obj) {
            if (Array.isArray(obj)) return obj.map(stripAngleBracketsFromJson);
            if (obj && typeof obj === 'object') {
                const out = createSafeObject();
                Object.entries(obj).forEach(([k, v]) => {
                    if (isDangerousObjectKey(k)) return;
                    out[k] = stripAngleBracketsFromJson(v);
                });
                return out;
            }
            if (typeof obj === 'string') return obj.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return obj;
        }

        function sanitizeUserInputText(text) {
            let value = InputSecurity.normalize(text, INPUT_LIMITS.maxStringLength);
            value = value.replace(/[\[\]\{\};"'`]/g, '');
            return value;
        }

        function sanitizeImportedString(str, maxLength = INPUT_LIMITS.maxStringLength) {
            if (str === null || str === undefined) return '';
            if (typeof str !== 'string') return '';
            return String(str)
                .replace(/[\x00-\x1F\x7F]/g, '')
                .replace(/[\[\]\{\};"'`]/g, '')
                .replace(/</g, '&lt;').replace(/>/g, '&gt;')
                .trim()
                .slice(0, maxLength);
        }

        function applyInputGuards() {
            document.addEventListener('keydown', (e) => {
                if (!isTextInputElement(e.target)) return;
                if (BLOCKED_INPUT_CHARS.has(e.key)) e.preventDefault();
            });
            document.addEventListener('beforeinput', (e) => {
                if (!isTextInputElement(e.target)) return;
                if (!e.data) return;
                for (const ch of e.data) {
                    if (BLOCKED_INPUT_CHARS.has(ch)) {
                        e.preventDefault();
                        return;
                    }
                }
            });
            document.addEventListener('paste', (e) => {
                if (!isTextInputElement(e.target)) return;
                const text = (e.clipboardData || window.clipboardData)?.getData('text') || '';
                const sanitized = sanitizeUserInputText(text);
                if (sanitized !== text) {
                    e.preventDefault();
                    document.execCommand('insertText', false, sanitized);
                }
            });
        }

        function isTextInputElement(el) {
            return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable);
        }

        function isSafeHttpUrl(url) {
            if (typeof url !== 'string') return false;
            const trimmed = url.trim();
            if (!trimmed) return false;
            try {
                const parsed = new URL(trimmed);
                return parsed.protocol === 'http:' || parsed.protocol === 'https:';
            } catch (e) {
                return false;
            }
        }

        const ACTIVE_STIX_VERSION = (typeof STIX_VERSION !== 'undefined' && typeof STIX_VERSION === 'string' && STIX_VERSION)
            ? STIX_VERSION
            : (typeof window !== 'undefined' && typeof window.STIX_VERSION === 'string' && window.STIX_VERSION)
            ? window.STIX_VERSION
            : '2.1';

        const ACTIVE_STIX_ID_PATTERN = (typeof STIX_ID_PATTERN !== 'undefined' && STIX_ID_PATTERN instanceof RegExp)
            ? STIX_ID_PATTERN
            : (typeof window !== 'undefined' && window.STIX_ID_PATTERN instanceof RegExp)
            ? window.STIX_ID_PATTERN
            : /^[a-z][a-z0-9-]*--[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;

        const ACTIVE_STIX_OBJECT_DEFS = (typeof STIX_OBJECT_DEFS !== 'undefined' && STIX_OBJECT_DEFS)
            ? STIX_OBJECT_DEFS
            : (typeof window !== 'undefined' && window.STIX_OBJECT_DEFS)
            ? window.STIX_OBJECT_DEFS
            : {};

        const ACTIVE_STIX_COMMON_PROPERTIES = (typeof STIX_COMMON_PROPERTIES !== 'undefined' && STIX_COMMON_PROPERTIES)
            ? STIX_COMMON_PROPERTIES
            : (typeof window !== 'undefined' && window.STIX_COMMON_PROPERTIES)
            ? window.STIX_COMMON_PROPERTIES
            : { required: [], optional: [] };

        const ACTIVE_STIX_KILL_CHAIN_PHASES = (typeof STIX_KILL_CHAIN_PHASES !== 'undefined' && STIX_KILL_CHAIN_PHASES)
            ? STIX_KILL_CHAIN_PHASES
            : (typeof window !== 'undefined' && window.STIX_KILL_CHAIN_PHASES)
            ? window.STIX_KILL_CHAIN_PHASES
            : {};

        const resolveStixObjectDefinition = (typeof getStixObjectDefinition === 'function')
            ? getStixObjectDefinition
            : (typeof window !== 'undefined' && typeof window.getStixObjectDefinition === 'function')
            ? window.getStixObjectDefinition.bind(window)
            : function (type) {
                return ACTIVE_STIX_OBJECT_DEFS[type] || null;
            };

        const resolveVocabulary = (typeof getVocabulary === 'function')
            ? getVocabulary
            : (typeof window !== 'undefined' && typeof window.getVocabulary === 'function')
            ? window.getVocabulary.bind(window)
            : function () {
                return [];
            };

        const state = {
            bundle: {
                type: 'bundle',
                id: 'bundle--' + generateUUID(),
                spec_version: ACTIVE_STIX_VERSION,
                objects: []
            },
            objectsById: new Map(),
            ui: {
                activeTab: 'sdo',
                activeObjectId: null,
                search: '',
                centerMode: 'editor'
            },
            validation: {
                ok: false,
                issues: []
            }
        };

        const CATEGORY_LABELS = {
            all: 'All',
            sdo: 'SDO',
            sro: 'SRO',
            sco: 'SCO',
            marking: 'Marking',
            extension: 'Extension'
        };

        function getObjectCategory(type) {
            const def = resolveStixObjectDefinition(type);
            return def?.category || 'sdo';
        }

        function getObjectDisplayName(obj) {
            return obj.name || obj.label || obj.subject || obj.value || obj.id;
        }

        function buildAddTypeOptions() {
            const select = document.getElementById('add-type');
            select.innerHTML = '';
            Object.keys(ACTIVE_STIX_OBJECT_DEFS).forEach((type) => {
                const def = resolveStixObjectDefinition(type);
                const option = document.createElement('option');
                option.value = type;
                option.textContent = def?.label || type;
                select.appendChild(option);
            });
        }

        function setActiveTab(tabKey) {
            state.ui.activeTab = tabKey;
            renderTabs();
            renderObjectList();
        }

        function renderTabs() {
            const tabs = document.getElementById('type-tabs');
            tabs.innerHTML = '';
            Object.keys(CATEGORY_LABELS).forEach((key) => {
                const btn = document.createElement('button');
                btn.className = 'tab' + (state.ui.activeTab === key ? ' active' : '');
                btn.textContent = CATEGORY_LABELS[key];
                btn.addEventListener('click', () => setActiveTab(key));
                tabs.appendChild(btn);
            });
        }

        function renderObjectList() {
            const list = document.getElementById('object-list');
            const search = state.ui.search.toLowerCase();
            list.innerHTML = '';

            const filtered = state.bundle.objects.filter((obj) => {
                if (state.ui.activeTab !== 'all' && getObjectCategory(obj.type) !== state.ui.activeTab) return false;
                const hay = `${obj.id} ${getObjectDisplayName(obj)}`.toLowerCase();
                return !search || hay.includes(search);
            });

            let visible = filtered;
            if (state.ui.activeTab === 'all' && filtered.length > LIST_LIMITS.maxAllResults) {
                visible = filtered.slice(0, LIST_LIMITS.maxAllResults);
                if (state.ui.activeObjectId) {
                    const activeIdx = filtered.findIndex((obj) => obj.id === state.ui.activeObjectId);
                    if (activeIdx >= LIST_LIMITS.maxAllResults && activeIdx !== -1) {
                        visible = visible.slice(0, LIST_LIMITS.maxAllResults - 1);
                        visible.push(filtered[activeIdx]);
                    }
                }
                const info = document.createElement('div');
                info.className = 'list-info';
                info.textContent = `Showing first ${LIST_LIMITS.maxAllResults} of ${filtered.length} objects.`;
                list.appendChild(info);
            }

            if (!filtered.length) {
                list.innerHTML = '<div class="empty">No objects in this category.</div>';
                return;
            }

            visible.forEach((obj) => {
                const row = document.createElement('div');
                row.className = 'object-item' + (state.ui.activeObjectId === obj.id ? ' selected' : '');
                row.addEventListener('click', () => selectObject(obj.id));
                row.innerHTML = `
                    <div class="object-id">${esc(obj.id)}</div>
                    <div class="object-name">${esc(getObjectDisplayName(obj))}</div>
                `;
                list.appendChild(row);
            });

            const selected = list.querySelector('.object-item.selected');
            if (selected) selected.scrollIntoView({ block: 'nearest' });
        }

        function selectObject(id) {
            state.ui.activeObjectId = id;
            renderObjectList();
            renderEditor();
            if (state.ui.centerMode === 'visualizer') {
                window.AttackFlowStixViz?.selectAndPopulate?.(id);
            }
        }

        function getActiveObject() {
            return state.bundle.objects.find((obj) => obj.id === state.ui.activeObjectId) || null;
        }

        function createDefaultObject(type) {
            const def = resolveStixObjectDefinition(type);
            if (!def) return null;
            const obj = {
                type: type,
                id: type + '--' + generateUUID(),
                spec_version: ACTIVE_STIX_VERSION
            };
            if (def.category !== 'sco') {
                const now = new Date().toISOString();
                obj.created = now;
                obj.modified = now;
            }
            const requiredFields = def.required || [];
            requiredFields.forEach((field) => {
                if (hasOwn(obj, field.key)) return;
                obj[field.key] = getDefaultForField(field);
            });
            return obj;
        }

        function getDefaultForField(field) {
            if (field.default !== undefined) return field.default;
            switch (field.type) {
                case 'boolean': return false;
                case 'integer':
                case 'number': return null;
                case 'list':
                case 'list:open-vocab':
                case 'object-refs':
                case 'object-marking-refs':
                case 'kill-chain-phases':
                case 'granular-markings':
                case 'external-references':
                    return [];
                case 'dictionary':
                case 'hashes':
                case 'extensions':
                case 'marking-definition':
                    return {};
                default:
                    return '';
            }
        }

        function addObject(type) {
            if (state.bundle.objects.length >= INPUT_LIMITS.maxObjects) {
                showToast('Bundle object limit reached');
                return;
            }
            const obj = createDefaultObject(type);
            if (!obj) return;
            if (state.objectsById.has(obj.id)) {
                showToast('Duplicate ID generated, try again');
                return;
            }
            state.bundle.objects.push(obj);
            state.objectsById.set(obj.id, obj);
            selectObject(obj.id);
            renderObjectList();
            renderBundlePreview();
        }

        function deleteActiveObject() {
            const obj = getActiveObject();
            if (!obj) return;
            if (!confirm(`Delete ${obj.type} ${obj.id}?`)) return;
            state.bundle.objects = state.bundle.objects.filter((item) => item.id !== obj.id);
            state.objectsById.delete(obj.id);
            state.ui.activeObjectId = state.bundle.objects[0]?.id || null;
            renderObjectList();
            renderEditor();
            renderBundlePreview();
        }

        function renderEditor() {
            const panel = document.getElementById('editor-panel');
            const obj = getActiveObject();
            if (!obj) {
                panel.innerHTML = '<div class="empty">Select an object to edit.</div>';
                return;
            }

            const def = resolveStixObjectDefinition(obj.type);
            const commonFields = def?.category !== 'sco'
                ? [...(ACTIVE_STIX_COMMON_PROPERTIES.required || []), ...(ACTIVE_STIX_COMMON_PROPERTIES.optional || [])]
                : [
                    { key: 'type', label: 'Type', type: 'string', description: 'STIX object type.' },
                    { key: 'spec_version', label: 'Spec Version', type: 'string', description: 'STIX spec version.' },
                    { key: 'id', label: 'ID', type: 'identifier', description: 'STIX identifier.' }
                ];

            const typeFields = [ ...(def?.required || []), ...(def?.optional || []) ];

            panel.innerHTML = `
                <div class="form-section">
                    <div class="section-title">${esc(def?.label || obj.type)} Fields</div>
                    ${typeFields.map((field) => renderField(obj, field, isRequiredField(field, def, false))).join('')}
                </div>
                <div class="form-section">
                    <div class="section-title">Common Properties</div>
                    ${commonFields.map((field) => renderField(obj, field, isRequiredField(field, def, true))).join('')}
                </div>
            `;
        }

        function setCenterMode(mode) {
            if (mode === 'visualizer' && !VISUALIZER_ENABLED) {
                state.ui.centerMode = 'editor';
                showToast('Visualizer is disabled by configuration');
                renderCenterMode();
                return;
            }
            state.ui.centerMode = mode;
            renderCenterMode();
        }

        function renderCenterMode() {
            const editor = document.getElementById('editor-panel');
            const visualizer = document.getElementById('visualizer-pane');
            const modeEditor = document.getElementById('mode-editor');
            const modeVisualizer = document.getElementById('mode-visualizer');
            const visualizeBundle = document.getElementById('visualize-bundle');
            const bundlePane = document.getElementById('bundle-pane');
            const visualizerSidePane = document.getElementById('visualizer-side-pane');
            const rightPaneBody = document.getElementById('right-pane-body');
            if (!VISUALIZER_ENABLED && state.ui.centerMode === 'visualizer') {
                state.ui.centerMode = 'editor';
            }
            const isVisualizer = VISUALIZER_ENABLED && state.ui.centerMode === 'visualizer';

            editor.classList.toggle('hidden', isVisualizer);
            visualizer.classList.toggle('active', isVisualizer);
            modeEditor.classList.toggle('active', !isVisualizer);
            modeVisualizer.classList.toggle('active', isVisualizer);
            modeVisualizer.classList.toggle('hidden', !VISUALIZER_ENABLED);
            visualizeBundle.classList.toggle('hidden', !VISUALIZER_ENABLED);
            bundlePane.classList.toggle('hidden', isVisualizer);
            visualizerSidePane.classList.toggle('active', isVisualizer);
            rightPaneBody.classList.toggle('no-scroll', isVisualizer);
        }

        function isRequiredField(field, def, isCommon) {
            if (isCommon) return (ACTIVE_STIX_COMMON_PROPERTIES.required || []).some((f) => f.key === field.key);
            return (def?.required || []).some((f) => f.key === field.key);
        }

        function renderField(obj, field, required) {
            const value = obj[field.key];
            const reqMark = required ? '<span class="req">*</span>' : '';
            const label = `${esc(field.label || field.key)}${reqMark}`;
            return `
                <div class="field">
                    <div class="field-label">${label}</div>
                    <div class="field-input">
                        ${renderFieldInput(obj, field, value)}
                        ${field.description ? `<div class="hint">${esc(field.description)}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function renderFieldInput(obj, field, value) {
            const key = escAttr(field.key);
            const isReadOnly = field.key === 'type' || field.key === 'spec_version';
            const roAttr = isReadOnly ? 'readonly' : '';
            switch (field.type) {
                case 'text':
                    return `<textarea data-field="${key}" data-type="text" ${roAttr}>${esc(value || '')}</textarea>`;
                case 'boolean':
                    return `<input type="checkbox" data-field="${key}" data-type="boolean" ${value ? 'checked' : ''}>`;
                case 'integer':
                case 'number':
                    return `<input type="number" data-field="${key}" data-type="${field.type}" value="${value ?? ''}" ${roAttr}>`;
                case 'timestamp':
                    return `<input type="text" data-field="${key}" data-type="timestamp" value="${escAttr(value || '')}" placeholder="2026-02-19T12:00:00Z" ${roAttr}>`;
                case 'identifier':
                    return `<div class="inline-actions">
                        <input type="text" data-field="${key}" data-type="identifier" value="${escAttr(value || '')}" ${roAttr}>
                        <button class="mini-btn" data-action="regen-id">Regenerate</button>
                    </div>`;
                case 'enum':
                    return renderEnumField(field, key, value);
                case 'open-vocab':
                    return renderOpenVocabField(field, key, value);
                case 'list':
                case 'list:open-vocab':
                    return renderListField(field, key, value || []);
                case 'object-refs':
                    return renderObjectRefsField(field, key, value || []);
                case 'object-marking-refs':
                    return renderObjectRefsField(field, key, value || []);
                case 'kill-chain-phases':
                    return renderKillChainField(key, value || []);
                case 'granular-markings':
                    return renderGranularMarkingsField(key, value || []);
                case 'external-references':
                    return renderExternalReferencesField(key, value || []);
                case 'dictionary':
                    return renderDictionaryField(key, value || {});
                case 'hashes':
                    return renderHashesField(key, value || {});
                case 'extensions':
                    return renderExtensionsField(key, value || {});
                case 'marking-definition':
                    return renderMarkingDefinitionField(obj, key, value || {});
                default:
                    return `<input type="text" data-field="${key}" data-type="string" value="${escAttr(value || '')}" ${roAttr}>`;
            }
        }

        function renderEnumField(field, key, value) {
            const options = field.options || (field.vocabulary ? resolveVocabulary(field.vocabulary) : []);
            return `
                <select data-field="${key}" data-type="enum">
                    <option value="">Select...</option>
                    ${options.map((opt) => `<option value="${escAttr(opt)}" ${opt === value ? 'selected' : ''}>${esc(opt)}</option>`).join('')}
                </select>
            `;
        }

        function renderOpenVocabField(field, key, value) {
            const options = field.vocabulary ? resolveVocabulary(field.vocabulary) : [];
            const listId = `list-${key}`;
            return `
                <input type="text" data-field="${key}" data-type="open-vocab" list="${listId}" value="${escAttr(value || '')}">
                <datalist id="${listId}">
                    ${options.map((opt) => `<option value="${escAttr(opt)}"></option>`).join('')}
                </datalist>
            `;
        }

        function renderListField(field, key, values) {
            const listId = `list-${key}-${Math.random().toString(36).slice(2, 7)}`;
            const options = field.vocabulary ? resolveVocabulary(field.vocabulary) : [];
            const items = (values || []).map((item, index) => {
                const input = field.type === 'list:open-vocab'
                    ? `<input type="text" data-list-field="${key}" data-index="${index}" list="${listId}" value="${escAttr(item || '')}">`
                    : `<input type="text" data-list-field="${key}" data-index="${index}" value="${escAttr(item || '')}">`;
                return `
                    <div class="list-item">
                        ${input}
                        <button class="mini-btn danger" data-action="remove-list" data-list-field="${key}" data-index="${index}">Remove</button>
                    </div>
                `;
            }).join('');

            return `
                <div>
                    ${items || '<div class="empty">No items yet.</div>'}
                    <button class="mini-btn" data-action="add-list" data-list-field="${key}">Add Item</button>
                </div>
                ${options.length ? `<datalist id="${listId}">${options.map((opt) => `<option value="${escAttr(opt)}"></option>`).join('')}</datalist>` : ''}
            `;
        }

        function renderObjectRefsField(field, key, values) {
            const options = state.bundle.objects.map((obj) => obj.id);
            const listId = `refs-${key}-${Math.random().toString(36).slice(2, 7)}`;
            const items = (values || []).map((item, index) => `
                <div class="list-item">
                    <input type="text" data-list-field="${key}" data-index="${index}" list="${listId}" value="${escAttr(item || '')}">
                    <button class="mini-btn danger" data-action="remove-list" data-list-field="${key}" data-index="${index}">Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No references yet.</div>'}
                    <button class="mini-btn" data-action="add-list" data-list-field="${key}">Add Ref</button>
                </div>
                <datalist id="${listId}">
                    ${options.map((id) => `<option value="${escAttr(id)}"></option>`).join('')}
                </datalist>
            `;
        }

        function renderKillChainField(key, values) {
            const items = (values || []).map((item, index) => {
                const chainOptions = Object.keys(ACTIVE_STIX_KILL_CHAIN_PHASES).map((kc) =>
                    `<option value="${escAttr(kc)}" ${kc === item.kill_chain_name ? 'selected' : ''}>${esc(kc)}</option>`
                ).join('');
                const phaseOptions = (ACTIVE_STIX_KILL_CHAIN_PHASES[item.kill_chain_name] || []).map((p) =>
                    `<option value="${escAttr(p)}" ${p === item.phase_name ? 'selected' : ''}>${esc(p)}</option>`
                ).join('');
                return `
                    <div class="list-item">
                        <div>
                            <select data-kc-field="${key}" data-index="${index}" data-kc-key="kill_chain_name">${chainOptions}</select>
                            <select data-kc-field="${key}" data-index="${index}" data-kc-key="phase_name">${phaseOptions}</select>
                        </div>
                        <button class="mini-btn danger" data-action="remove-kc" data-kc-field="${key}" data-index="${index}">Remove</button>
                    </div>
                `;
            }).join('');
            return `
                <div>
                    ${items || '<div class="empty">No kill chain phases yet.</div>'}
                    <button class="mini-btn" data-action="add-kc" data-kc-field="${key}">Add Phase</button>
                </div>
            `;
        }

        function renderExternalReferencesField(key, values) {
            const items = (values || []).map((item, index) => `
                <div class="list-item">
                    <div>
                        <input type="text" data-ref-field="${key}" data-index="${index}" data-ref-key="source_name" placeholder="source_name" value="${escAttr(item.source_name || '')}">
                        <input type="text" data-ref-field="${key}" data-index="${index}" data-ref-key="description" placeholder="description" value="${escAttr(item.description || '')}">
                        <input type="text" data-ref-field="${key}" data-index="${index}" data-ref-key="url" placeholder="url" value="${escAttr(item.url || '')}">
                        <input type="text" data-ref-field="${key}" data-index="${index}" data-ref-key="external_id" placeholder="external_id" value="${escAttr(item.external_id || '')}">
                        ${renderReferenceHashesField(key, index, item.hashes || {})}
                    </div>
                    <button class="mini-btn danger" data-action="remove-ref" data-ref-field="${key}" data-index="${index}">Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No references yet.</div>'}
                    <button class="mini-btn" data-action="add-ref" data-ref-field="${key}">Add Reference</button>
                </div>
            `;
        }

        function renderReferenceHashesField(refKey, index, hashes) {
            const fieldKey = `refhash-${refKey}-${index}`;
            const entries = Object.entries(hashes || {});
            const items = entries.map(([k, v], idx) => `
                <div class="list-item">
                    <div>
                        <input type="text" data-refhash-field="${fieldKey}" data-ref-root="${refKey}" data-ref-index="${index}" data-index="${idx}" data-refhash-role="key" value="${escAttr(k || '')}" placeholder="hash type">
                        <input type="text" data-refhash-field="${fieldKey}" data-ref-root="${refKey}" data-ref-index="${index}" data-index="${idx}" data-refhash-role="value" value="${escAttr(v || '')}" placeholder="hash value">
                    </div>
                    <button class="mini-btn danger" data-action="remove-refhash" data-refhash-field="${fieldKey}" data-ref-root="${refKey}" data-ref-index="${index}" data-index="${idx}">Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No hashes yet.</div>'}
                    <button class="mini-btn" data-action="add-refhash" data-refhash-field="${fieldKey}" data-ref-root="${refKey}" data-ref-index="${index}">Add Hash</button>
                </div>
            `;
        }

        function renderGranularMarkingsField(key, values) {
            const options = state.bundle.objects.filter((obj) => obj.type === 'marking-definition').map((obj) => obj.id);
            const listId = `gm-${key}-${Math.random().toString(36).slice(2, 7)}`;
            const items = (values || []).map((item, index) => `
                <div class="list-item">
                    <div>
                        <textarea data-gm-field="${key}" data-index="${index}" data-gm-key="selectors" placeholder="one selector per line">${esc(item.selectors ? item.selectors.join('\n') : '')}</textarea>
                        <input type="text" data-gm-field="${key}" data-index="${index}" data-gm-key="marking_ref" list="${listId}" value="${escAttr(item.marking_ref || '')}">
                    </div>
                    <button class="mini-btn danger" data-action="remove-gm" data-gm-field="${key}" data-index="${index}">Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No granular markings yet.</div>'}
                    <button class="mini-btn" data-action="add-gm" data-gm-field="${key}">Add Granular Marking</button>
                </div>
                <datalist id="${listId}">
                    ${options.map((id) => `<option value="${escAttr(id)}"></option>`).join('')}
                </datalist>
            `;
        }

        function renderDictionaryField(key, values, prefix = 'dict', meta = {}) {
            const entries = Object.entries(values || {});
            const items = entries.map(([k, v], index) => `
                <div class="list-item">
                    <div>
                        <input type="text" data-${prefix}-field="${key}" data-index="${index}" data-${prefix}-role="key" ${meta.root ? `data-ext-root="${meta.root}" data-ext-index="${meta.extIndex}"` : ''} value="${escAttr(k || '')}" placeholder="key">
                        <input type="text" data-${prefix}-field="${key}" data-index="${index}" data-${prefix}-role="value" ${meta.root ? `data-ext-root="${meta.root}" data-ext-index="${meta.extIndex}"` : ''} value="${escAttr(v || '')}" placeholder="value">
                    </div>
                    <button class="mini-btn danger" data-action="remove-${prefix}" data-${prefix}-field="${key}" data-index="${index}" ${meta.root ? `data-ext-root="${meta.root}" data-ext-index="${meta.extIndex}"` : ''}>Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No entries yet.</div>'}
                    <button class="mini-btn" data-action="add-${prefix}" data-${prefix}-field="${key}" ${meta.root ? `data-ext-root="${meta.root}" data-ext-index="${meta.extIndex}"` : ''}>Add Entry</button>
                </div>
            `;
        }

        function renderHashesField(key, values, inline, prefix = 'hash') {
            const entries = Object.entries(values || {});
            const items = entries.map(([k, v], index) => `
                <div class="list-item">
                    <div>
                        <input type="text" data-${prefix}-field="${key}" data-index="${index}" data-${prefix}-role="key" value="${escAttr(k || '')}" placeholder="hash type">
                        <input type="text" data-${prefix}-field="${key}" data-index="${index}" data-${prefix}-role="value" value="${escAttr(v || '')}" placeholder="hash value">
                    </div>
                    <button class="mini-btn danger" data-action="remove-${prefix}" data-${prefix}-field="${key}" data-index="${index}">Remove</button>
                </div>
            `).join('');
            const wrapper = `
                <div>
                    ${items || '<div class="empty">No hashes yet.</div>'}
                    <button class="mini-btn" data-action="add-${prefix}" data-${prefix}-field="${key}">Add Hash</button>
                </div>
            `;
            return inline ? wrapper : `<div class="hint">${wrapper}</div>`;
        }

        function renderExtensionsField(key, values) {
            const entries = Object.entries(values || {});
            const items = entries.map(([k, v], index) => `
                <div class="list-item">
                    <div>
                        <input type="text" data-ext-field="${key}" data-index="${index}" data-ext-role="key" value="${escAttr(k || '')}" placeholder="extension id">
                        ${renderDictionaryField(`${key}-ext-${index}`, v || {}, 'extdict', { root: key, extIndex: index })}
                    </div>
                    <button class="mini-btn danger" data-action="remove-ext" data-ext-field="${key}" data-index="${index}">Remove</button>
                </div>
            `).join('');
            return `
                <div>
                    ${items || '<div class="empty">No extensions yet.</div>'}
                    <button class="mini-btn" data-action="add-ext" data-ext-field="${key}">Add Extension</button>
                </div>
            `;
        }

        function renderMarkingDefinitionField(obj, key, value) {
            const type = obj.definition_type || '';
            if (type === 'tlp') {
                const options = resolveVocabulary('tlp-ov');
                return `
                    <select data-marking-field="${key}" data-marking-type="tlp">
                        <option value="">Select...</option>
                        ${options.map((opt) => `<option value="${escAttr(opt)}" ${value.tlp === opt ? 'selected' : ''}>${esc(opt)}</option>`).join('')}
                    </select>
                `;
            }
            if (type === 'statement') {
                return `<textarea data-marking-field="${key}" data-marking-type="statement">${esc(value.statement || '')}</textarea>`;
            }
            return '<div class="hint">Select definition_type to configure.</div>';
        }

        function updateBundlePreview() {
            document.getElementById('bundle-preview').textContent = JSON.stringify(state.bundle, null, 2);
        }

        function renderBundleSummary() {
            const counts = {};
            state.bundle.objects.forEach((obj) => {
                counts[obj.type] = (counts[obj.type] || 0) + 1;
            });
            const lines = Object.keys(counts).sort().map((type) => `${type}: ${counts[type]}`);
            document.getElementById('bundle-summary').textContent = lines.length ? lines.join(' | ') : 'No objects yet.';
        }

        function renderBundlePreview() {
            updateBundlePreview();
            renderBundleSummary();
            setVisualizerButtonState();
        }

        function setVisualizerButtonState() {
            const btn = document.getElementById('visualize-bundle');
            const issues = validateBundle();
            const isEmpty = state.bundle.objects.length === 0;
            btn.disabled = isEmpty || issues.length > 0;
        }

        function updateStatus(ok, message) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            const statusRow = document.getElementById('bundle-status');
            dot.classList.toggle('ok', ok);
            dot.classList.toggle('bad', !ok);
            text.textContent = message;
            if (statusRow) {
                const hasIssues = !ok && (state.validation.issues || []).length > 0;
                statusRow.classList.toggle('clickable', hasIssues);
                statusRow.classList.toggle('btn', hasIssues);
                statusRow.setAttribute('aria-disabled', hasIssues ? 'false' : 'true');
            }
        }

        function openBundleIssues() {
            const issues = state.validation.issues || [];
            if (!issues.length) return;
            const list = document.getElementById('bundle-issues-list');
            list.innerHTML = '';
            issues.forEach((issue, index) => {
                const item = document.createElement('div');
                const STIX_ID_PATTERN_CHECK = /(?<![a-z0-9-])([a-z0-9-]+--[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?![a-z0-9-])/i;
                const issue_id = STIX_ID_PATTERN_CHECK.test(issue)
                    ? issue.match(STIX_ID_PATTERN_CHECK)[1]
                    : '';
                item.className = 'issue-item';
                item.style.fontSize = '0.75rem';
                item.style.color = "var(--text-primary)";
                item.textContent = `${index + 1}. ${issue}`;
                if (issue_id !== '') {
                    item.title = 'Click to select related object';
                    item.classList.add('btn');
                    item.style.cursor = 'pointer';
                    item.addEventListener('click', () => selectObject(issue_id));
                }
                list.appendChild(item);
            });
            setActiveTab("all");
            document.getElementById('bundle-issues-modal').classList.add('visible');
        }

        function closeBundleIssues(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('bundle-issues-modal').classList.remove('visible');
        }

        function clearBundle() {
            if (!confirm('Clear all STIX objects from this bundle?')) return;
            state.bundle = {
                type: 'bundle',
                id: 'bundle--' + generateUUID(),
                spec_version: ACTIVE_STIX_VERSION,
                objects: []
            };
            state.objectsById = new Map();
            state.ui.activeObjectId = null;
            state.validation.ok = false;
            state.validation.issues = [];
            if (window.AttackFlowStixViz?.reset) {
                window.AttackFlowStixViz.reset();
            }
            if (state.ui.centerMode !== 'editor') {
                setCenterMode('editor');
            }
            renderTabs();
            renderObjectList();
            renderEditor();
            renderBundlePreview();
            updateStatus(false, 'Not validated');
            showToast('Bundle cleared');
        }

        function sanitizeDictionary(raw, maxItems = INPUT_LIMITS.maxListItems) {
            const out = createSafeObject();
            if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return out;
            Object.entries(raw).slice(0, maxItems).forEach(([k, v]) => {
                const key = sanitizeImportedString(k, 200);
                if (isDangerousObjectKey(key)) return;
                const value = sanitizeImportedString(String(v ?? ''), INPUT_LIMITS.maxStringLength);
                if (key) out[key] = value;
            });
            return out;
        }

        function sanitizeExtensions(raw, maxItems = INPUT_LIMITS.maxListItems) {
            const out = createSafeObject();
            if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return out;
            Object.entries(raw).slice(0, maxItems).forEach(([k, v]) => {
                const key = sanitizeImportedString(k, 200);
                if (isDangerousObjectKey(key)) return;
                if (!key) return;
                out[key] = sanitizeDictionary(v || {});
            });
            return out;
        }

        function sanitizeImportedFieldValue(field, raw) {
            switch (field.type) {
                case 'boolean':
                    return !!raw;
                case 'integer': {
                    const num = parseInt(raw, 10);
                    if (Number.isNaN(num)) return null;
                    if (field.min !== undefined && num < field.min) return null;
                    if (field.max !== undefined && num > field.max) return null;
                    return num;
                }
                case 'number': {
                    const num = Number(raw);
                    if (!Number.isFinite(num)) return null;
                    return num;
                }
                case 'list':
                case 'list:open-vocab':
                case 'object-refs':
                case 'object-marking-refs':
                    if (!Array.isArray(raw)) return [];
                    return raw.slice(0, INPUT_LIMITS.maxListItems)
                        .map((v) => sanitizeImportedString(String(v ?? ''), 500))
                        .filter(Boolean);
                case 'kill-chain-phases':
                    if (!Array.isArray(raw)) return [];
                    return raw.slice(0, INPUT_LIMITS.maxListItems).map((v) => ({
                        kill_chain_name: sanitizeImportedString(v?.kill_chain_name || ''),
                        phase_name: sanitizeImportedString(v?.phase_name || '')
                    })).filter((v) => v.kill_chain_name && v.phase_name);
                case 'granular-markings':
                    if (!Array.isArray(raw)) return [];
                    return raw.slice(0, INPUT_LIMITS.maxListItems).map((v) => ({
                        selectors: Array.isArray(v?.selectors) ? v.selectors.map((s) => sanitizeImportedString(s, 500)).filter(Boolean) : [],
                        marking_ref: sanitizeImportedString(v?.marking_ref || '')
                    }));
                case 'external-references':
                    if (!Array.isArray(raw)) return [];
                    return raw.slice(0, INPUT_LIMITS.maxListItems).map((ref) => ({
                        source_name: sanitizeImportedString(ref?.source_name || '', 200),
                        description: sanitizeImportedString(ref?.description || '', 1000),
                        url: sanitizeImportedString(ref?.url || '', 2000),
                        external_id: sanitizeImportedString(ref?.external_id || '', 200),
                        hashes: sanitizeDictionary(ref?.hashes || {})
                    })).filter((ref) => ref.source_name);
                case 'dictionary':
                case 'hashes':
                    return sanitizeDictionary(raw || {});
                case 'extensions':
                    return sanitizeExtensions(raw || {});
                case 'marking-definition':
                    return raw && typeof raw === 'object'
                        ? sanitizeDictionary(raw || {}, INPUT_LIMITS.maxListItems)
                        : {};
                default:
                    return sanitizeImportedString(String(raw ?? ''), INPUT_LIMITS.maxStringLength);
            }
        }

        function sanitizeImportedObject(obj) {
            if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return null;
            const def = resolveStixObjectDefinition(obj.type);
            if (!def) return null;
            if (!obj.id || typeof obj.id !== 'string' || !ACTIVE_STIX_ID_PATTERN.test(obj.id)) return null;
            if (obj.id.split('--')[0] !== obj.type) return null;

            const clean = {
                type: obj.type,
                id: obj.id,
                spec_version: ACTIVE_STIX_VERSION
            };

            if (def.category !== 'sco') {
                clean.created = typeof obj.created === 'string' ? sanitizeImportedString(obj.created, 100) : new Date().toISOString();
                clean.modified = typeof obj.modified === 'string' ? sanitizeImportedString(obj.modified, 100) : new Date().toISOString();
            }

            const commonFields = def.category !== 'sco'
                ? [...(ACTIVE_STIX_COMMON_PROPERTIES.optional || [])]
                : [];
            const fields = [...commonFields, ...(def.required || []), ...(def.optional || [])];
            fields.forEach((field) => {
                if (!field || isDangerousObjectKey(field.key)) return;
                if (!hasOwn(obj, field.key)) return;
                const value = sanitizeImportedFieldValue(field, obj[field.key]);
                if (value !== null && value !== undefined && value !== '') {
                    clean[field.key] = value;
                }
            });

            return clean;
        }

        function sanitizeBundleForVisualizer(bundle) {
            const clean = {
                type: 'bundle',
                id: bundle.id,
                spec_version: ACTIVE_STIX_VERSION,
                objects: []
            };
            for (const obj of bundle.objects) {
                const sanitized = sanitizeImportedObject(obj);
                if (!sanitized) return null;
                clean.objects.push(sanitized);
            }
            return clean;
        }

        function renderVisualizer() {
            if (!VISUALIZER_ENABLED) {
                showToast('Visualizer is disabled by configuration');
                return;
            }
            const issues = validateBundle();
            if (issues.length) {
                showToast(issues[0]);
                return;
            }
            const sanitized = sanitizeBundleForVisualizer(state.bundle);
            if (!sanitized) {
                showToast('Sanitization failed');
                return;
            }
            setCenterMode('visualizer');
            if (window.AttackFlowStixViz?.render) {
                window.AttackFlowStixViz.render(sanitized, null);
                if (state.ui.activeObjectId) {
                    window.AttackFlowStixViz.selectAndPopulate?.(state.ui.activeObjectId);
                }
                window.AttackFlowStixViz.onSelect = (id) => {
                    if (!id || state.ui.activeObjectId === id) return;
                    state.ui.activeObjectId = id;
                    state.ui.activeTab = 'all';
                    renderTabs();
                    renderObjectList();
                    renderEditor();
                };
            } else {
                showToast('Visualizer not ready');
            }
        }

        function validateBundle() {
            const issues = [];
            if (state.bundle.type !== 'bundle') issues.push('Bundle type must be "bundle"');
            if (!ACTIVE_STIX_ID_PATTERN.test(state.bundle.id)) issues.push('Bundle id must be a valid STIX id');
            if (state.bundle.spec_version !== ACTIVE_STIX_VERSION) issues.push('Bundle spec_version must be 2.1');
            if (!Array.isArray(state.bundle.objects)) issues.push('Bundle objects must be an array');

            const ids = new Set();
            state.bundle.objects.forEach((obj) => {
                if (!obj || typeof obj !== 'object') {
                    issues.push('Bundle contains invalid object');
                    return;
                }
                if (!obj.type || !ACTIVE_STIX_OBJECT_DEFS[obj.type]) {
                    issues.push(`Unknown object type: ${obj.type}`);
                    return;
                }
                if (!obj.id || !ACTIVE_STIX_ID_PATTERN.test(obj.id)) {
                    issues.push(`Invalid id for ${obj.type}`);
                } else if (ids.has(obj.id)) {
                    issues.push(`Duplicate id: ${obj.id}`);
                } else {
                    ids.add(obj.id);
                }
                if (obj.spec_version !== ACTIVE_STIX_VERSION) {
                    issues.push(`${obj.type} ${obj.id} spec_version must be 2.1`);
                }
                const def = resolveStixObjectDefinition(obj.type);
                const required = def?.required || [];
                const common = def?.category !== 'sco' ? (ACTIVE_STIX_COMMON_PROPERTIES.required || []) : [];
                [...common, ...required].forEach((field) => {
                    if (!hasValue(obj[field.key], field.type)) {
                        issues.push(`${obj.type} ${obj.id} missing ${field.key}`);
                    }
                });

                validateObjectFields(obj, def, issues);
            });

            state.validation.ok = issues.length === 0;
            state.validation.issues = issues;
            updateStatus(state.validation.ok, state.validation.ok ? 'Valid bundle' : `${issues.length} issue(s)`);
            return issues;
        }

        function hasValue(value, type) {
            if (type === 'boolean') return value === true || value === false;
            if (type === 'integer' || type === 'number') return value !== null && value !== undefined && value !== '';
            if (type === 'list' || type === 'list:open-vocab' || type === 'object-refs' || type === 'object-marking-refs') return Array.isArray(value) && value.length > 0;
            if (type === 'dictionary' || type === 'hashes' || type === 'extensions' || type === 'marking-definition') return value && typeof value === 'object';
            return value !== null && value !== undefined && String(value).trim() !== '';
        }

        function validateObjectFields(obj, def, issues) {
            const fields = [...(def?.required || []), ...(def?.optional || [])];
            fields.forEach((field) => {
                const value = obj[field.key];
                if (value === undefined || value === null || value === '') return;
                switch (field.type) {
                    case 'identifier':
                        if (!ACTIVE_STIX_ID_PATTERN.test(value)) issues.push(`${obj.type} ${obj.id} invalid ${field.key}`);
                        break;
                    case 'timestamp':
                        if (Number.isNaN(Date.parse(value))) issues.push(`${obj.type} ${obj.id} invalid ${field.key} timestamp`);
                        break;
                    case 'integer':
                        if (!Number.isInteger(value)) issues.push(`${obj.type} ${obj.id} ${field.key} must be integer`);
                        if (field.min !== undefined && value < field.min) issues.push(`${obj.type} ${obj.id} ${field.key} below min`);
                        if (field.max !== undefined && value > field.max) issues.push(`${obj.type} ${obj.id} ${field.key} above max`);
                        break;
                    case 'number':
                        if (typeof value !== 'number') issues.push(`${obj.type} ${obj.id} ${field.key} must be number`);
                        break;
                    case 'enum':
                        if (field.options && !field.options.includes(value)) issues.push(`${obj.type} ${obj.id} ${field.key} invalid enum`);
                        if (field.vocabulary && !resolveVocabulary(field.vocabulary).includes(value)) issues.push(`${obj.type} ${obj.id} ${field.key} invalid enum`);
                        break;
                    case 'open-vocab':
                        if (typeof value !== 'string' || !value.trim()) issues.push(`${obj.type} ${obj.id} ${field.key} required`);
                        break;
                    case 'object-refs':
                    case 'object-marking-refs':
                        if (!Array.isArray(value)) issues.push(`${obj.type} ${obj.id} ${field.key} must be list`);
                        (value || []).forEach((id) => {
                            if (!ACTIVE_STIX_ID_PATTERN.test(id)) issues.push(`${obj.type} ${obj.id} ${field.key} has invalid ref`);
                        });
                        break;
                    case 'kill-chain-phases':
                        if (!Array.isArray(value)) issues.push(`${obj.type} ${obj.id} ${field.key} must be list`);
                        (value || []).forEach((phase) => {
                            if (!phase.kill_chain_name || !phase.phase_name) issues.push(`${obj.type} ${obj.id} invalid kill_chain_phases entry`);
                        });
                        break;
                    case 'external-references':
                        (value || []).forEach((ref) => {
                            if (!ref.source_name) issues.push(`${obj.type} ${obj.id} external_references missing source_name`);
                            if (ref.url && !isSafeHttpUrl(ref.url)) issues.push(`${obj.type} ${obj.id} external_references invalid url`);
                        });
                        break;
                    case 'marking-definition':
                        if (obj.definition_type === 'tlp') {
                            if (!value.tlp || !resolveVocabulary('tlp-ov').includes(value.tlp)) issues.push(`${obj.type} ${obj.id} invalid tlp marking`);
                        } else if (obj.definition_type === 'statement') {
                            if (!value.statement) issues.push(`${obj.type} ${obj.id} invalid statement marking`);
                        }
                        break;
                    default:
                        break;
                }
            });

            if (obj.type === 'artifact') {
                if (!obj.payload_bin && !obj.url) issues.push('artifact requires payload_bin or url');
            }
            if (obj.type === 'network-traffic') {
                if (!Array.isArray(obj.protocols) || obj.protocols.length === 0) issues.push('network-traffic requires protocols');
            }
            if (obj.type === 'sighting') {
                const hasObserved = Array.isArray(obj.observed_data_refs) && obj.observed_data_refs.length > 0;
                const hasWhere = Array.isArray(obj.where_sighted_refs) && obj.where_sighted_refs.length > 0;
                if (!hasObserved && !hasWhere) issues.push('sighting requires observed_data_refs or where_sighted_refs');
            }
        }

        function sanitizeValue(value) {
            if (typeof value === 'string') return InputSecurity.normalize(value, INPUT_LIMITS.maxStringLength);
            return value;
        }

        function handleEditorInput(event) {
            const target = event.target;
            const obj = getActiveObject();
            if (!obj) return;

            if (target.dataset.field) {
                const key = target.dataset.field;
                const type = target.dataset.type || 'string';
                const oldId = obj.id;
                let value = target.value;
                if (type === 'boolean') value = target.checked;
                if (type === 'integer' || type === 'number') value = value === '' ? null : Number(value);
                obj[key] = sanitizeValue(value);
                if (key === 'id' && oldId !== obj.id) {
                    state.objectsById.delete(oldId);
                    state.objectsById.set(obj.id, obj);
                    state.ui.activeObjectId = obj.id;
                    renderObjectList();
                }
                if (key === 'definition_type') {
                    renderEditor();
                }
                renderBundlePreview();
                return;
            }

            if (target.dataset.listField) {
                const key = target.dataset.listField;
                const index = parseInt(target.dataset.index, 10);
                if (!Array.isArray(obj[key])) obj[key] = [];
                obj[key][index] = sanitizeValue(target.value);
                renderBundlePreview();
                return;
            }

            if (target.dataset.refField) {
                const key = target.dataset.refField;
                const index = parseInt(target.dataset.index, 10);
                const refKey = target.dataset.refKey;
                if (!Array.isArray(obj[key])) obj[key] = [];
                if (!obj[key][index]) obj[key][index] = {};
                obj[key][index][refKey] = sanitizeValue(target.value);
                renderBundlePreview();
                return;
            }

            if (target.dataset.kcField) {
                const key = target.dataset.kcField;
                const index = parseInt(target.dataset.index, 10);
                const kcKey = target.dataset.kcKey;
                if (!Array.isArray(obj[key])) obj[key] = [];
                if (!obj[key][index]) obj[key][index] = { kill_chain_name: 'unified-kill-chain', phase_name: '' };
                obj[key][index][kcKey] = sanitizeValue(target.value);
                renderEditor();
                renderBundlePreview();
                return;
            }

            if (target.dataset.gmField) {
                const key = target.dataset.gmField;
                const index = parseInt(target.dataset.index, 10);
                const gmKey = target.dataset.gmKey;
                if (!Array.isArray(obj[key])) obj[key] = [];
                if (!obj[key][index]) obj[key][index] = { selectors: [], marking_ref: '' };
                if (gmKey === 'selectors') {
                    obj[key][index].selectors = sanitizeValue(target.value)
                        .split('\n')
                        .map((v) => v.trim())
                        .filter(Boolean);
                } else {
                    obj[key][index][gmKey] = sanitizeValue(target.value);
                }
                renderBundlePreview();
                return;
            }

            if (target.dataset.dictField) {
                const key = target.dataset.dictField;
                obj[key] = collectDictionary(key, 'dict');
                renderBundlePreview();
                return;
            }

            if (target.dataset.hashField) {
                const key = target.dataset.hashField;
                obj[key] = collectDictionary(key, 'hash');
                renderBundlePreview();
                return;
            }

            if (target.dataset.refhashField && target.dataset.refRoot) {
                const fieldKey = target.dataset.refhashField;
                const root = target.dataset.refRoot;
                const index = parseInt(target.dataset.refIndex, 10);
                if (!Array.isArray(obj[root])) obj[root] = [];
                if (!obj[root][index]) obj[root][index] = {};
                obj[root][index].hashes = collectDictionary(fieldKey, 'refhash');
                renderBundlePreview();
                return;
            }

            if (target.dataset.extRoot) {
                const key = target.dataset.extRoot;
                obj[key] = collectExtensions(key);
                renderBundlePreview();
                return;
            }

            if (target.dataset.markingField) {
                const key = target.dataset.markingField;
                const type = target.dataset.markingType;
                if (!obj[key]) obj[key] = {};
                if (type === 'tlp') obj[key] = { tlp: sanitizeValue(target.value) };
                if (type === 'statement') obj[key] = { statement: sanitizeValue(target.value) };
                renderBundlePreview();
            }
        }

        function collectDictionary(fieldKey, prefix) {
            const keyInputs = document.querySelectorAll(`[data-${prefix}-field="${fieldKey}"][data-${prefix}-role="key"]`);
            const valInputs = document.querySelectorAll(`[data-${prefix}-field="${fieldKey}"][data-${prefix}-role="value"]`);
            const dict = {};
            keyInputs.forEach((input, index) => {
                const key = sanitizeValue(input.value.trim());
                const value = sanitizeValue(valInputs[index]?.value || '');
                if (key) dict[key] = value;
            });
            return dict;
        }

        function collectExtensions(fieldKey) {
            const extKeys = document.querySelectorAll(`[data-ext-field="${fieldKey}"][data-ext-role="key"]`);
            const dict = {};
            extKeys.forEach((input, index) => {
                const key = sanitizeValue(input.value.trim());
                if (!key) return;
                const nestedKey = `${fieldKey}-ext-${index}`;
                dict[key] = collectDictionary(nestedKey, 'extdict');
            });
            return dict;
        }

        function handleEditorClick(event) {
            const target = event.target;
            const obj = getActiveObject();
            if (!obj) return;

            if (target.dataset.action === 'regen-id') {
                const oldId = obj.id;
                obj.id = obj.type + '--' + generateUUID();
                state.objectsById.delete(oldId);
                state.objectsById.set(obj.id, obj);
                state.ui.activeObjectId = obj.id;
                renderObjectList();
                renderEditor();
                renderBundlePreview();
                return;
            }

            if (target.dataset.action === 'add-list') {
                const key = target.dataset.listField;
                if (!Array.isArray(obj[key])) obj[key] = [];
                obj[key].push('');
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-list') {
                const key = target.dataset.listField;
                const index = parseInt(target.dataset.index, 10);
                obj[key].splice(index, 1);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-ref') {
                const key = target.dataset.refField;
                if (!Array.isArray(obj[key])) obj[key] = [];
                obj[key].push({ source_name: '' });
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-ref') {
                const key = target.dataset.refField;
                const index = parseInt(target.dataset.index, 10);
                obj[key].splice(index, 1);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-kc') {
                const key = target.dataset.kcField;
                if (!Array.isArray(obj[key])) obj[key] = [];
                obj[key].push({ kill_chain_name: 'unified-kill-chain', phase_name: '' });
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-kc') {
                const key = target.dataset.kcField;
                const index = parseInt(target.dataset.index, 10);
                obj[key].splice(index, 1);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-gm') {
                const key = target.dataset.gmField;
                if (!Array.isArray(obj[key])) obj[key] = [];
                obj[key].push({ selectors: [], marking_ref: '' });
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-gm') {
                const key = target.dataset.gmField;
                const index = parseInt(target.dataset.index, 10);
                obj[key].splice(index, 1);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-dict') {
                const key = target.dataset.dictField;
                obj[key] = obj[key] || {};
                obj[key]['key-' + Math.random().toString(36).slice(2, 7)] = '';
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-dict') {
                const key = target.dataset.dictField;
                const entries = Object.entries(obj[key] || {});
                entries.splice(parseInt(target.dataset.index, 10), 1);
                obj[key] = Object.fromEntries(entries);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-hash') {
                const key = target.dataset.hashField;
                obj[key] = obj[key] || {};
                obj[key]['hash-' + Math.random().toString(36).slice(2, 7)] = '';
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-refhash') {
                const root = target.dataset.refRoot;
                const index = parseInt(target.dataset.refIndex, 10);
                if (!Array.isArray(obj[root])) obj[root] = [];
                if (!obj[root][index]) obj[root][index] = {};
                obj[root][index].hashes = obj[root][index].hashes || {};
                obj[root][index].hashes['hash-' + Math.random().toString(36).slice(2, 7)] = '';
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-hash') {
                const key = target.dataset.hashField;
                const entries = Object.entries(obj[key] || {});
                entries.splice(parseInt(target.dataset.index, 10), 1);
                obj[key] = Object.fromEntries(entries);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-refhash') {
                const root = target.dataset.refRoot;
                const index = parseInt(target.dataset.refIndex, 10);
                if (!Array.isArray(obj[root])) return;
                if (!obj[root][index]) return;
                const entries = Object.entries(obj[root][index].hashes || {});
                entries.splice(parseInt(target.dataset.index, 10), 1);
                obj[root][index].hashes = Object.fromEntries(entries);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-ext') {
                const key = target.dataset.extField;
                obj[key] = obj[key] || {};
                obj[key]['extension-' + Math.random().toString(36).slice(2, 7)] = {};
                renderEditor();
                return;
            }

            if (target.dataset.action === 'add-extdict') {
                const root = target.dataset.extRoot;
                const extIndex = parseInt(target.dataset.extIndex, 10);
                const entries = Object.entries(obj[root] || {});
                const extKey = entries[extIndex]?.[0];
                if (!extKey) return;
                obj[root][extKey] = obj[root][extKey] || {};
                obj[root][extKey]['key-' + Math.random().toString(36).slice(2, 7)] = '';
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-ext') {
                const key = target.dataset.extField;
                const entries = Object.entries(obj[key] || {});
                entries.splice(parseInt(target.dataset.index, 10), 1);
                obj[key] = Object.fromEntries(entries);
                renderEditor();
                return;
            }

            if (target.dataset.action === 'remove-extdict') {
                const root = target.dataset.extRoot;
                const extIndex = parseInt(target.dataset.extIndex, 10);
                const entries = Object.entries(obj[root] || {});
                const extKey = entries[extIndex]?.[0];
                if (!extKey) return;
                const dictEntries = Object.entries(obj[root][extKey] || {});
                dictEntries.splice(parseInt(target.dataset.index, 10), 1);
                obj[root][extKey] = Object.fromEntries(dictEntries);
                renderEditor();
                return;
            }
        }

        function exportBundle() {
            const issues = validateBundle();
            if (issues.length) {
                if (!confirm('Bundle has validation issues. Export anyway?')) return;
            }
            const blob = new Blob([JSON.stringify(state.bundle, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'stix-bundle.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importBundle(file) {
            if (!file) return;
            if (file.size > INPUT_LIMITS.maxFileSize) {
                showToast('File too large');
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const rawData = parseJsonSafe(e.target.result);
                    const raw = stripAngleBracketsFromJson(rawData);
                    if (!raw || typeof raw !== 'object' || raw.type !== 'bundle') throw new Error('Invalid bundle');
                    if (!Array.isArray(raw.objects)) throw new Error('Bundle objects missing');
                    if (raw.objects.length > INPUT_LIMITS.maxObjects) throw new Error('Too many objects');

                    let merge = false;
                    const hasObjects = state.bundle.objects.length > 0;
                    if (hasObjects && !confirm('Replace current bundle with imported bundle?')) {
                        if (!confirm('Merge imported bundle into current bundle?')) return;
                        merge = true;
                    }
                    if (!merge) {
                        state.bundle = {
                            type: 'bundle',
                            id: raw.id || ('bundle--' + generateUUID()),
                            spec_version: raw.spec_version || ACTIVE_STIX_VERSION,
                            objects: []
                        };
                        state.objectsById = new Map();
                    }
                    raw.objects.forEach((obj) => {
                        const clean = sanitizeImportedObject(obj);
                        if (!clean) return;
                        if (state.objectsById.has(clean.id)) return;
                        state.bundle.objects.push(clean);
                        state.objectsById.set(clean.id, clean);
                    });
                    state.ui.activeObjectId = state.bundle.objects[0]?.id || null;
                    renderTabs();
                    renderObjectList();
                    renderEditor();
                    renderBundlePreview();
                    if (state.ui.centerMode === 'visualizer') {
                        renderVisualizer();
                    }
                    showToast('Bundle imported');
                } catch (err) {
                    showToast('Import failed: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function copyActiveJson() {
            const obj = getActiveObject();
            if (!obj) return;
            const text = JSON.stringify(obj, null, 2);
            navigator.clipboard.writeText(text).then(() => showToast('Copied object JSON'));
        }

        function initEvents() {
            document.getElementById('add-object').addEventListener('click', () => {
                const type = document.getElementById('add-type').value;
                addObject(type);
            });
            document.getElementById('clear-bundle').addEventListener('click', clearBundle);
            document.getElementById('delete-object').addEventListener('click', deleteActiveObject);
            document.getElementById('export-bundle').addEventListener('click', exportBundle);
            document.getElementById('validate-bundle').addEventListener('click', () => {
                const issues = validateBundle();
                if (issues.length) showToast(issues[0]);
                renderBundlePreview();
            });
            document.getElementById('import-bundle').addEventListener('click', () => {
                document.getElementById('bundle-file').click();
            });
            document.getElementById('bundle-file').addEventListener('change', (e) => {
                importBundle(e.target.files[0]);
                e.target.value = '';
            });
            document.getElementById('search-input').addEventListener('input', (e) => {
                state.ui.search = e.target.value || '';
                renderObjectList();
            });
            document.getElementById('editor-panel').addEventListener('input', handleEditorInput);
            document.getElementById('editor-panel').addEventListener('click', handleEditorClick);
            document.getElementById('copy-json').addEventListener('click', copyActiveJson);
            document.getElementById('mode-editor').addEventListener('click', () => setCenterMode('editor'));
            document.getElementById('mode-visualizer').addEventListener('click', () => setCenterMode('visualizer'));
            document.getElementById('visualize-bundle').addEventListener('click', renderVisualizer);

            const statusRow = document.getElementById('bundle-status');
            statusRow.addEventListener('click', openBundleIssues);
            statusRow.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    openBundleIssues();
                }
            });
        }

        function enableLeaveSiteConfirmation() {
            window.addEventListener('beforeunload', (e) => {
                e.preventDefault();
                e.returnValue = '';
                return '';
            });
        }

        initThemeControls();
        logLocalIframeIPCSplash('stix-builder');
        initParentThemeBridge();
        requestParentTheme();
        window.addEventListener('storage', (e) => {
            if (e.key === THEME_STORAGE_KEYS.mode) {
                syncThemeFromStorage();
            }
        });
        if (typeof CONFIG !== 'undefined') {
            if (CONFIG.navigation?.confirmOnLeave !== false) {
                enableLeaveSiteConfirmation();
            }
        } else {
            enableLeaveSiteConfirmation();
        }
        applyInputGuards();
        if (!Object.keys(ACTIVE_STIX_OBJECT_DEFS).length) {
            updateStatus(false, 'STIX config failed to load');
            showToast('Error: STIX configuration unavailable');
            initEvents();
        } else {
            buildAddTypeOptions();
        }
        renderTabs();
        renderObjectList();
        renderEditor();
        renderBundlePreview();
        renderCenterMode();
        initEvents();
    </script>
</body>
</html>
