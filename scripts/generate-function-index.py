#!/usr/bin/env python3
"""
Generate docs/FUNCTION_INDEX.generated.md from runtime source files.

Usage:
  python3 scripts/generate-function-index.py
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
import re


@dataclass
class FunctionHit:
    name: str
    line: int
    signature: str
    kind: str


PROJECT_ROOT = Path(__file__).resolve().parent.parent
OUTPUT_FILE = PROJECT_ROOT / "docs" / "FUNCTION_INDEX.generated.md"

TARGET_FILES = [
    "index.html",
    "explorer.html",
    "stix-builder.html",
    "config.js",
    "stix-config.js",
]

DECLARATION_PATTERNS = [
    ("declaration", re.compile(r"^\s*function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(")),
    ("async-declaration", re.compile(r"^\s*async\s+function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(")),
    (
        "const-function",
        re.compile(
            r"^\s*(?:const|let|var)\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(?:async\s+)?function\s*\("
        ),
    ),
    (
        "arrow-function",
        re.compile(
            r"^\s*(?:const|let|var)\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(?:async\s+)?(?:\([^\)]*\)|[A-Za-z_][A-Za-z0-9_]*)\s*=>"
        ),
    ),
]


def extract_functions(file_path: Path) -> list[FunctionHit]:
    lines = file_path.read_text(encoding="utf-8", errors="replace").splitlines()
    seen: set[tuple[str, int]] = set()
    hits: list[FunctionHit] = []

    for index, line in enumerate(lines, start=1):
        for kind, pattern in DECLARATION_PATTERNS:
            match = pattern.match(line)
            if not match:
                continue

            name = match.group(1)
            key = (name, index)
            if key in seen:
                break

            seen.add(key)
            hits.append(
                FunctionHit(
                    name=name,
                    line=index,
                    signature=line.strip(),
                    kind=kind,
                )
            )
            break

    hits.sort(key=lambda item: (item.line, item.name.lower()))
    return hits


def render_markdown(function_map: dict[str, list[FunctionHit]]) -> str:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    lines: list[str] = []
    lines.append("# AttackFlow — Generated Function Index")
    lines.append("")
    lines.append(
        "This file is auto-generated by `scripts/generate-function-index.py`. Do not edit manually."
    )
    lines.append("")
    lines.append(f"Generated: {timestamp}")
    lines.append("")
    lines.append("## Coverage")
    lines.append("")

    total = 0
    for rel_path in TARGET_FILES:
        count = len(function_map.get(rel_path, []))
        total += count
        lines.append(f"- `{rel_path}`: {count} functions")

    lines.append(f"- **Total**: {total} functions")
    lines.append("")
    lines.append("---")
    lines.append("")

    for rel_path in TARGET_FILES:
        functions = function_map.get(rel_path, [])
        lines.append(f"## `{rel_path}`")
        lines.append("")

        if not functions:
            lines.append("_No function declarations detected._")
            lines.append("")
            continue

        for hit in functions:
            lines.append(
                f"- `L{hit.line}` `{hit.name}` ({hit.kind}) — `{hit.signature}`"
            )

        lines.append("")

    return "\n".join(lines)


def main() -> None:
    function_map: dict[str, list[FunctionHit]] = {}

    for rel_path in TARGET_FILES:
        abs_path = PROJECT_ROOT / rel_path
        if not abs_path.exists():
            function_map[rel_path] = []
            continue

        function_map[rel_path] = extract_functions(abs_path)

    OUTPUT_FILE.write_text(render_markdown(function_map), encoding="utf-8")
    print(f"Generated {OUTPUT_FILE.relative_to(PROJECT_ROOT)}")


if __name__ == "__main__":
    main()
